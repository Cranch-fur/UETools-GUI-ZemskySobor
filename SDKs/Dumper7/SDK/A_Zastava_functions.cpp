#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: A_Zastava

#include "Basic.hpp"

#include "A_Zastava_classes.hpp"
#include "A_Zastava_parameters.hpp"


namespace SDK
{

// Function A_Zastava.A_Zastava_C.ActivatingSpawn
// (BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::ActivatingSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "ActivatingSpawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.ActorLoaded
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::ActorLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "ActorLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.AfterForceCaptured
// (BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::AfterForceCaptured()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "AfterForceCaptured");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.AfterLoadedBorberState
// (BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::AfterLoadedBorberState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "AfterLoadedBorberState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.AgrOnPlayer
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANPC_CH_NewBattleSystem_C*        Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::AgrOnPlayer(class ANPC_CH_NewBattleSystem_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "AgrOnPlayer");

	Params::A_Zastava_C_AgrOnPlayer Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.Alarm
// (BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::Alarm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "Alarm");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.AlarmOnMain
// (BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::AlarmOnMain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "AlarmOnMain");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.BellActivate
// (BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::BellActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "BellActivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.Bind in Border
// (Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::Bind_in_Border()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "Bind in Border");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.BindOnDead
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANPC_CH_NewBattleSystem_C*        Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::BindOnDead(class ANPC_CH_NewBattleSystem_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "BindOnDead");

	Params::A_Zastava_C_BindOnDead Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.BindOnDeadRinger
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANPC_CH_NewBattleSystem_C*        Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::BindOnDeadRinger(class ANPC_CH_NewBattleSystem_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "BindOnDeadRinger");

	Params::A_Zastava_C_BindOnDeadRinger Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.BindOutBorder
// (Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::BindOutBorder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "BindOutBorder");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.BindOverlappedInBorder
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void AA_Zastava_C::BindOverlappedInBorder(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "BindOverlappedInBorder");

	Params::A_Zastava_C_BindOverlappedInBorder Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.BindOverlappedOutBorder
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void AA_Zastava_C::BindOverlappedOutBorder(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "BindOverlappedOutBorder");

	Params::A_Zastava_C_BindOverlappedOutBorder Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.BndEvt__A_Zastava_UISphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void AA_Zastava_C::BndEvt__A_Zastava_UISphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "BndEvt__A_Zastava_UISphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature");

	Params::A_Zastava_C_BndEvt__A_Zastava_UISphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.BndEvt__A_Zastava_UISphere_K2Node_ComponentBoundEvent_1_ComponentEndOverlapSignature__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::BndEvt__A_Zastava_UISphere_K2Node_ComponentBoundEvent_1_ComponentEndOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "BndEvt__A_Zastava_UISphere_K2Node_ComponentBoundEvent_1_ComponentEndOverlapSignature__DelegateSignature");

	Params::A_Zastava_C_BndEvt__A_Zastava_UISphere_K2Node_ComponentBoundEvent_1_ComponentEndOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.CastToDayNightController
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Day                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::CastToDayNightController(bool* Day)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "CastToDayNightController");

	Params::A_Zastava_C_CastToDayNightController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Day != nullptr)
		*Day = Parms.Day;
}


// Function A_Zastava.A_Zastava_C.CheckChars
// (Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::CheckChars()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "CheckChars");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.CheckFreePOI
// (Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::CheckFreePOI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "CheckFreePOI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.CheckMercyCounter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ETeamAttitude*                          TeamAttitude                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::CheckMercyCounter(ETeamAttitude* TeamAttitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "CheckMercyCounter");

	Params::A_Zastava_C_CheckMercyCounter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TeamAttitude != nullptr)
		*TeamAttitude = Parms.TeamAttitude;
}


// Function A_Zastava.A_Zastava_C.DayNightChanged
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsDay_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::DayNightChanged(bool IsDay_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "DayNightChanged");

	Params::A_Zastava_C_DayNightChanged Parms{};

	Parms.IsDay_0 = IsDay_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.DestroyStuffOnZastava
// (BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::DestroyStuffOnZastava()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "DestroyStuffOnZastava");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.DontWorkAfterCapture
// (Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::DontWorkAfterCapture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "DontWorkAfterCapture");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.EmptyGarrison
// (BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::EmptyGarrison()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "EmptyGarrison");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.ExecuteUbergraph_A_Zastava
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::ExecuteUbergraph_A_Zastava(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "ExecuteUbergraph_A_Zastava");

	Params::A_Zastava_C_ExecuteUbergraph_A_Zastava Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.GarrisonOnMainDead
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool                                    Exists                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::GarrisonOnMainDead(const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "GarrisonOnMainDead");

	Params::A_Zastava_C_GarrisonOnMainDead Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.GenSplineCollision
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::GenSplineCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "GenSplineCollision");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.HasCaptured
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   MayCapturing_0                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::HasCaptured(bool* MayCapturing_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "HasCaptured");

	Params::A_Zastava_C_HasCaptured Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MayCapturing_0 != nullptr)
		*MayCapturing_0 = Parms.MayCapturing_0;
}


// Function A_Zastava.A_Zastava_C.InitFlagZastava
// (Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::InitFlagZastava()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "InitFlagZastava");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.InitRingerForAlarm
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANPC_CH_C*                        Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::InitRingerForAlarm(class ANPC_CH_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "InitRingerForAlarm");

	Params::A_Zastava_C_InitRingerForAlarm Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.IsDead
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool                                    Exists                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::IsDead(const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "IsDead");

	Params::A_Zastava_C_IsDead Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.IsDeadUpdated
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool                                    Exists                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::IsDeadUpdated(class UAbilitySystemComponent* ASC, const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "IsDeadUpdated");

	Params::A_Zastava_C_IsDeadUpdated Parms{};

	Parms.ASC = ASC;
	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.IsRingerDead
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool                                    Exists                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::IsRingerDead(const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "IsRingerDead");

	Params::A_Zastava_C_IsRingerDead Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.MakeRouteAlongSpline
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASpawnerPointZastava*             SpawnerPoint                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::MakeRouteAlongSpline(class ASpawnerPointZastava* SpawnerPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "MakeRouteAlongSpline");

	Params::A_Zastava_C_MakeRouteAlongSpline Parms{};

	Parms.SpawnerPoint = SpawnerPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.PanoramaAfterCapture
// (BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::PanoramaAfterCapture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "PanoramaAfterCapture");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.PausedCycle
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UGenericQuest*                    Quest                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::PausedCycle(class UGenericQuest* Quest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "PausedCycle");

	Params::A_Zastava_C_PausedCycle Parms{};

	Parms.Quest = Quest;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.PlayerIsHere
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AZastavaBase*                     Zastava                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::PlayerIsHere(class AZastavaBase* Zastava)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "PlayerIsHere");

	Params::A_Zastava_C_PlayerIsHere Parms{};

	Parms.Zastava = Zastava;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AA_Zastava_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.ResetFreePOI
// (Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::ResetFreePOI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "ResetFreePOI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.SetCapturing
// (Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::SetCapturing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "SetCapturing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.SetPeacefulTreeForGuards
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       NPC                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ASpawnerPointZastava*             Spawner                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::SetPeacefulTreeForGuards(class ACharacter* NPC, class ASpawnerPointZastava* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "SetPeacefulTreeForGuards");

	Params::A_Zastava_C_SetPeacefulTreeForGuards Parms{};

	Parms.NPC = NPC;
	Parms.Spawner = Spawner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.SetSprite
// (Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::SetSprite()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "SetSprite");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.Settings Night Guards
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<class ASpawnerPointZastava*, struct FEnemyData>&TargetMap                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AA_Zastava_C::Settings_Night_Guards(const TMap<class ASpawnerPointZastava*, struct FEnemyData>& TargetMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "Settings Night Guards");

	Params::A_Zastava_C_Settings_Night_Guards Parms{};

	Parms.TargetMap = std::move(TargetMap);

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.SetZastavaFlagByFraction
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AA_ZastavaFlag_C**                Flag_0                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::SetZastavaFlagByFraction(class AA_ZastavaFlag_C** Flag_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "SetZastavaFlagByFraction");

	Params::A_Zastava_C_SetZastavaFlagByFraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Flag_0 != nullptr)
		*Flag_0 = Parms.Flag_0;
}


// Function A_Zastava.A_Zastava_C.SkipAlarmOnZastava
// (Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::SkipAlarmOnZastava()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "SkipAlarmOnZastava");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.Spawn Guards
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASpawnerPointZastava*             Spawner                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FEnemyData&                Data                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class ANPC_CH_NewBattleSystem_C**       SpawnedGuardNPC_0                                      (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::Spawn_Guards(class ASpawnerPointZastava* Spawner, const struct FEnemyData& Data, class ANPC_CH_NewBattleSystem_C** SpawnedGuardNPC_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "Spawn Guards");

	Params::A_Zastava_C_Spawn_Guards Parms{};

	Parms.Spawner = Spawner;
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnedGuardNPC_0 != nullptr)
		*SpawnedGuardNPC_0 = Parms.SpawnedGuardNPC_0;
}


// Function A_Zastava.A_Zastava_C.Spawn Night Guard
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASpawnerPointZastava*             Spawner                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::Spawn_Night_Guard(class ASpawnerPointZastava* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "Spawn Night Guard");

	Params::A_Zastava_C_Spawn_Night_Guard Parms{};

	Parms.Spawner = Spawner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.Spawn Night GuardOnSub
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AA_SubZastava_C*                  Sub_0                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::Spawn_Night_GuardOnSub(class AA_SubZastava_C* Sub_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "Spawn Night GuardOnSub");

	Params::A_Zastava_C_Spawn_Night_GuardOnSub Parms{};

	Parms.Sub_0 = Sub_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.SpawnPatrols
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<class ASpawnerPointZastava*, struct FPatrolData>&SpawnSettings                                          (BlueprintVisible, BlueprintReadOnly, Parm)

void AA_Zastava_C::SpawnPatrols(const TMap<class ASpawnerPointZastava*, struct FPatrolData>& SpawnSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "SpawnPatrols");

	Params::A_Zastava_C_SpawnPatrols Parms{};

	Parms.SpawnSettings = std::move(SpawnSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.StopCameraView
// (BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::StopCameraView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "StopCameraView");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.SubCatured
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AZastavaSub*                      Sub_0                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::SubCatured(class AZastavaSub* Sub_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "SubCatured");

	Params::A_Zastava_C_SubCatured Parms{};

	Parms.Sub_0 = Sub_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.Timeline_0__FinishedFunc
// (BlueprintEvent)

void AA_Zastava_C::Timeline_0__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "Timeline_0__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.Timeline_0__UpdateFunc
// (BlueprintEvent)

void AA_Zastava_C::Timeline_0__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "Timeline_0__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.TraceBeforeSpawn
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Spawner                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         SpawnLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::TraceBeforeSpawn(class AActor* Spawner, struct FVector* SpawnLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "TraceBeforeSpawn");

	Params::A_Zastava_C_TraceBeforeSpawn Parms{};

	Parms.Spawner = Spawner;

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnLocation != nullptr)
		*SpawnLocation = std::move(Parms.SpawnLocation);
}


// Function A_Zastava.A_Zastava_C.UnPausedCycle
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UGenericQuest*                    Quest                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AA_Zastava_C::UnPausedCycle(class UGenericQuest* Quest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "UnPausedCycle");

	Params::A_Zastava_C_UnPausedCycle Parms{};

	Parms.Quest = Quest;

	UObject::ProcessEvent(Func, &Parms);
}


// Function A_Zastava.A_Zastava_C.UpdateAttitude
// (Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::UpdateAttitude()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "UpdateAttitude");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function A_Zastava.A_Zastava_C.ZastavaCaptured
// (BlueprintCallable, BlueprintEvent)

void AA_Zastava_C::ZastavaCaptured()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("A_Zastava_C", "ZastavaCaptured");

	UObject::ProcessEvent(Func, nullptr);
}

}

