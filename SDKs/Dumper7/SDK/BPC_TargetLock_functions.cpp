#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPC_TargetLock

#include "Basic.hpp"

#include "BPC_TargetLock_classes.hpp"
#include "BPC_TargetLock_parameters.hpp"


namespace SDK
{

// Function BPC_TargetLock.BPC_TargetLock_C.AllowChangeHardLockTarget
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::AllowChangeHardLockTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "AllowChangeHardLockTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.BlockHardLockTargetSwitch
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::BlockHardLockTargetSwitch(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "BlockHardLockTargetSwitch");

	Params::BPC_TargetLock_C_BlockHardLockTargetSwitch Parms{};

	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.CameraTimerHandle
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::CameraTimerHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "CameraTimerHandle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.CanEnableHardLock
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::CanEnableHardLock(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "CanEnableHardLock");

	Params::BPC_TargetLock_C_CanEnableHardLock Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BPC_TargetLock.BPC_TargetLock_C.CanEnableSoftLock
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::CanEnableSoftLock(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "CanEnableSoftLock");

	Params::BPC_TargetLock_C_CanEnableSoftLock Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPC_TargetLock.BPC_TargetLock_C.CheckForResetHitActor
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::CheckForResetHitActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "CheckForResetHitActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.CheckTargetsToUpdateByAttack
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::CheckTargetsToUpdateByAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "CheckTargetsToUpdateByAttack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.CheckTargetsToUpdateByDodge
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::CheckTargetsToUpdateByDodge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "CheckTargetsToUpdateByDodge");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.CheckTraceBetweenActor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           ActorToCheck                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::CheckTraceBetweenActor(class AActor* ActorToCheck, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "CheckTraceBetweenActor");

	Params::BPC_TargetLock_C_CheckTraceBetweenActor Parms{};

	Parms.ActorToCheck = ActorToCheck;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPC_TargetLock.BPC_TargetLock_C.ExecuteUbergraph_BPC_TargetLock
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::ExecuteUbergraph_BPC_TargetLock(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "ExecuteUbergraph_BPC_TargetLock");

	Params::BPC_TargetLock_C_ExecuteUbergraph_BPC_TargetLock Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.FilterActorsByCone
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>&                  Actors                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const struct FVector&                   ConeDirection                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Angle                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   ConeLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ConeRadius                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FLinearColor&              DebugColor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DebugDuration                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>*                  ActorsInCone                                           (Parm, OutParm)

void UBPC_TargetLock_C::FilterActorsByCone(TArray<class AActor*>& Actors, const struct FVector& ConeDirection, double Angle, const struct FVector& ConeLocation, double ConeRadius, bool Debug, const struct FLinearColor& DebugColor, double DebugDuration, TArray<class AActor*>* ActorsInCone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "FilterActorsByCone");

	Params::BPC_TargetLock_C_FilterActorsByCone Parms{};

	Parms.Actors = std::move(Actors);
	Parms.ConeDirection = std::move(ConeDirection);
	Parms.Angle = Angle;
	Parms.ConeLocation = std::move(ConeLocation);
	Parms.ConeRadius = ConeRadius;
	Parms.Debug = Debug;
	Parms.DebugColor = std::move(DebugColor);
	Parms.DebugDuration = DebugDuration;

	UObject::ProcessEvent(Func, &Parms);

	Actors = std::move(Parms.Actors);

	if (ActorsInCone != nullptr)
		*ActorsInCone = std::move(Parms.ActorsInCone);
}


// Function BPC_TargetLock.BPC_TargetLock_C.FilterTargetsInView
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::FilterTargetsInView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "FilterTargetsInView");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.FindAnyHardlockTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor**                          Result                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::FindAnyHardlockTarget(class AActor** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "FindAnyHardlockTarget");

	Params::BPC_TargetLock_C_FindAnyHardlockTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPC_TargetLock.BPC_TargetLock_C.FindCenteredTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor**                          ClosestTarget                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::FindCenteredTarget(class AActor** ClosestTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "FindCenteredTarget");

	Params::BPC_TargetLock_C_FindCenteredTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ClosestTarget != nullptr)
		*ClosestTarget = Parms.ClosestTarget;
}


// Function BPC_TargetLock.BPC_TargetLock_C.FindClosestTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>&                  Targets                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor**                          Output                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::FindClosestTarget(TArray<class AActor*>& Targets, class AActor** Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "FindClosestTarget");

	Params::BPC_TargetLock_C_FindClosestTarget Parms{};

	Parms.Targets = std::move(Targets);

	UObject::ProcessEvent(Func, &Parms);

	Targets = std::move(Parms.Targets);

	if (Output != nullptr)
		*Output = Parms.Output;
}


// Function BPC_TargetLock.BPC_TargetLock_C.FindClosestTargetToDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>&                  Targets                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const struct FVector&                   Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor**                          Output                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::FindClosestTargetToDirection(TArray<class AActor*>& Targets, const struct FVector& Direction, class AActor** Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "FindClosestTargetToDirection");

	Params::BPC_TargetLock_C_FindClosestTargetToDirection Parms{};

	Parms.Targets = std::move(Targets);
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);

	Targets = std::move(Parms.Targets);

	if (Output != nullptr)
		*Output = Parms.Output;
}


// Function BPC_TargetLock.BPC_TargetLock_C.Get Current Target Location
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector*                         TargetLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::Get_Current_Target_Location(struct FVector* TargetLocation, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "Get Current Target Location");

	Params::BPC_TargetLock_C_Get_Current_Target_Location Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TargetLocation != nullptr)
		*TargetLocation = std::move(Parms.TargetLocation);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPC_TargetLock.BPC_TargetLock_C.GetAttackingTargets
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>&                  Targets                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class AActor*>*                  AttackingTargets                                       (Parm, OutParm)

void UBPC_TargetLock_C::GetAttackingTargets(TArray<class AActor*>& Targets, TArray<class AActor*>* AttackingTargets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "GetAttackingTargets");

	Params::BPC_TargetLock_C_GetAttackingTargets Parms{};

	Parms.Targets = std::move(Targets);

	UObject::ProcessEvent(Func, &Parms);

	Targets = std::move(Parms.Targets);

	if (AttackingTargets != nullptr)
		*AttackingTargets = std::move(Parms.AttackingTargets);
}


// Function BPC_TargetLock.BPC_TargetLock_C.GetHostileActorsAround
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>*                  HostileActors                                          (Parm, OutParm)

void UBPC_TargetLock_C::GetHostileActorsAround(TArray<class AActor*>* HostileActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "GetHostileActorsAround");

	Params::BPC_TargetLock_C_GetHostileActorsAround Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HostileActors != nullptr)
		*HostileActors = std::move(Parms.HostileActors);
}


// Function BPC_TargetLock.BPC_TargetLock_C.GetMiddleLocationOfActors
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class AActor*>&                  Actors                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector*                         Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::GetMiddleLocationOfActors(TArray<class AActor*>& Actors, struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "GetMiddleLocationOfActors");

	Params::BPC_TargetLock_C_GetMiddleLocationOfActors Parms{};

	Parms.Actors = std::move(Actors);

	UObject::ProcessEvent(Func, &Parms);

	Actors = std::move(Parms.Actors);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function BPC_TargetLock.BPC_TargetLock_C.GetRangeAttackTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor**                          Target                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::GetRangeAttackTarget(class AActor** Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "GetRangeAttackTarget");

	Params::BPC_TargetLock_C_GetRangeAttackTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Target != nullptr)
		*Target = Parms.Target;
}


// Function BPC_TargetLock.BPC_TargetLock_C.Handle Owner Deal Hit
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADefaultCharacter*                HitInstigator                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ADefaultCharacter*                HitTarget                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::Handle_Owner_Deal_Hit(class ADefaultCharacter* HitInstigator, class ADefaultCharacter* HitTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "Handle Owner Deal Hit");

	Params::BPC_TargetLock_C_Handle_Owner_Deal_Hit Parms{};

	Parms.HitInstigator = HitInstigator;
	Parms.HitTarget = HitTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.Handle Owner Receive Hit
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADefaultCharacter*                HitInstigator                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ADefaultCharacter*                HitTarget                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::Handle_Owner_Receive_Hit(class ADefaultCharacter* HitInstigator, class ADefaultCharacter* HitTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "Handle Owner Receive Hit");

	Params::BPC_TargetLock_C_Handle_Owner_Receive_Hit Parms{};

	Parms.HitInstigator = HitInstigator;
	Parms.HitTarget = HitTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.HandleMovementInputChanged
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::HandleMovementInputChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "HandleMovementInputChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.HasTagOnPlayer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              TagToCheck                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBPC_TargetLock_C::HasTagOnPlayer(const struct FGameplayTag& TagToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "HasTagOnPlayer");

	Params::BPC_TargetLock_C_HasTagOnPlayer Parms{};

	Parms.TagToCheck = std::move(TagToCheck);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BPC_TargetLock.BPC_TargetLock_C.HorizontalCameraRotate
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RotateSpeedFR                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RotateSpeedR                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RotateSpeedRB                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::HorizontalCameraRotate(double DeltaTime, double RotateSpeedFR, double RotateSpeedR, double RotateSpeedRB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "HorizontalCameraRotate");

	Params::BPC_TargetLock_C_HorizontalCameraRotate Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.RotateSpeedFR = RotateSpeedFR;
	Parms.RotateSpeedR = RotateSpeedR;
	Parms.RotateSpeedRB = RotateSpeedRB;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.IsAttacking
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::IsAttacking(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "IsAttacking");

	Params::BPC_TargetLock_C_IsAttacking Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPC_TargetLock.BPC_TargetLock_C.IsHardLockEnabled?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::IsHardLockEnabled_(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "IsHardLockEnabled?");

	Params::BPC_TargetLock_C_IsHardLockEnabled_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPC_TargetLock.BPC_TargetLock_C.IsHostileActor?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class AActor*                     OwnerActor                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class AActor*                     EnemyActor                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBPC_TargetLock_C::IsHostileActor_(const class AActor* OwnerActor, const class AActor* EnemyActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "IsHostileActor?");

	Params::BPC_TargetLock_C_IsHostileActor_ Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.EnemyActor = EnemyActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BPC_TargetLock.BPC_TargetLock_C.IsInOneLine?
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class AActor*>&                  Targets                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// double                                  MaxDeltaDistance                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::IsInOneLine_(TArray<class AActor*>& Targets, double MaxDeltaDistance, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "IsInOneLine?");

	Params::BPC_TargetLock_C_IsInOneLine_ Parms{};

	Parms.Targets = std::move(Targets);
	Parms.MaxDeltaDistance = MaxDeltaDistance;

	UObject::ProcessEvent(Func, &Parms);

	Targets = std::move(Parms.Targets);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPC_TargetLock.BPC_TargetLock_C.IsMoving
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBPC_TargetLock_C::IsMoving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "IsMoving");

	Params::BPC_TargetLock_C_IsMoving Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BPC_TargetLock.BPC_TargetLock_C.IsNotTrackingMode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBPC_TargetLock_C::IsNotTrackingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "IsNotTrackingMode");

	Params::BPC_TargetLock_C_IsNotTrackingMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BPC_TargetLock.BPC_TargetLock_C.IsSoftLockEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::IsSoftLockEnabled(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "IsSoftLockEnabled");

	Params::BPC_TargetLock_C_IsSoftLockEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPC_TargetLock.BPC_TargetLock_C.NeedToUpdateTargetByAttack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           NewTarget                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::NeedToUpdateTargetByAttack(class AActor* NewTarget, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "NeedToUpdateTargetByAttack");

	Params::BPC_TargetLock_C_NeedToUpdateTargetByAttack Parms{};

	Parms.NewTarget = NewTarget;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPC_TargetLock.BPC_TargetLock_C.OnHitActorResetCooldownFinished
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::OnHitActorResetCooldownFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "OnHitActorResetCooldownFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.OnLevelsChanged_Event
// (BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::OnLevelsChanged_Event()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "OnLevelsChanged_Event");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.OnMovementTargetChangeTimeEnded
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::OnMovementTargetChangeTimeEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "OnMovementTargetChangeTimeEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.OnSoftlockCameraRotationCooldownFinished
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::OnSoftlockCameraRotationCooldownFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "OnSoftlockCameraRotationCooldownFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.OnTagChanged
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool                                    Exists                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::OnTagChanged(const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "OnTagChanged");

	Params::BPC_TargetLock_C_OnTagChanged Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.OnTargetChangeCooldownFinished
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::OnTargetChangeCooldownFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "OnTargetChangeCooldownFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.OnTargetDie
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADefaultCharacter*                DiedCharacter                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::OnTargetDie(class ADefaultCharacter* DiedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "OnTargetDie");

	Params::BPC_TargetLock_C_OnTargetDie Parms{};

	Parms.DiedCharacter = DiedCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UBPC_TargetLock_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "ReceiveTick");

	Params::BPC_TargetLock_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.RemoveCurrentTarget
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::RemoveCurrentTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "RemoveCurrentTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.SearchNextHardLockTarget
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    SearchLeft                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor**                          Result                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::SearchNextHardLockTarget(bool SearchLeft, class AActor** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "SearchNextHardLockTarget");

	Params::BPC_TargetLock_C_SearchNextHardLockTarget Parms{};

	Parms.SearchLeft = SearchLeft;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPC_TargetLock.BPC_TargetLock_C.Set NewSoftlockTarget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           NewTarget                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::Set_NewSoftlockTarget(class AActor* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "Set NewSoftlockTarget");

	Params::BPC_TargetLock_C_Set_NewSoftlockTarget Parms{};

	Parms.NewTarget = NewTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.SetCurrentAttackTarget
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANPC_CH_NewBattleSystem_C*        CurrentAttackTarget_0                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UAbilitySystemComponent*          CurrentAttackTargetASC_0                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::SetCurrentAttackTarget(class ANPC_CH_NewBattleSystem_C* CurrentAttackTarget_0, class UAbilitySystemComponent* CurrentAttackTargetASC_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "SetCurrentAttackTarget");

	Params::BPC_TargetLock_C_SetCurrentAttackTarget Parms{};

	Parms.CurrentAttackTarget_0 = CurrentAttackTarget_0;
	Parms.CurrentAttackTargetASC_0 = CurrentAttackTargetASC_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.SetEnabledHardLockCamera
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewValue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::SetEnabledHardLockCamera(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "SetEnabledHardLockCamera");

	Params::BPC_TargetLock_C_SetEnabledHardLockCamera Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.SetHardLockEnabled
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::SetHardLockEnabled(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "SetHardLockEnabled");

	Params::BPC_TargetLock_C_SetHardLockEnabled Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.SetLastHitCharacter
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADefaultCharacter*                Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::SetLastHitCharacter(class ADefaultCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "SetLastHitCharacter");

	Params::BPC_TargetLock_C_SetLastHitCharacter Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.SetSoftLockEnabled
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::SetSoftLockEnabled(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "SetSoftLockEnabled");

	Params::BPC_TargetLock_C_SetSoftLockEnabled Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.StartCameraInputTracking
// (Public, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::StartCameraInputTracking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "StartCameraInputTracking");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.StopCameraInputTracking
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::StopCameraInputTracking(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "StopCameraInputTracking");

	Params::BPC_TargetLock_C_StopCameraInputTracking Parms{};

	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.SwitchHardLockTarget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    LeftDirection                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::SwitchHardLockTarget(bool LeftDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "SwitchHardLockTarget");

	Params::BPC_TargetLock_C_SwitchHardLockTarget Parms{};

	Parms.LeftDirection = LeftDirection;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.TraceForTargets
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::TraceForTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "TraceForTargets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.UpdateClosestToCenterTarget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::UpdateClosestToCenterTarget(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "UpdateClosestToCenterTarget");

	Params::BPC_TargetLock_C_UpdateClosestToCenterTarget Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.UpdateCurrentAttackTarget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           AttackTarget                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::UpdateCurrentAttackTarget(class AActor* AttackTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "UpdateCurrentAttackTarget");

	Params::BPC_TargetLock_C_UpdateCurrentAttackTarget Parms{};

	Parms.AttackTarget = AttackTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.UpdateFriendlyTarget
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::UpdateFriendlyTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "UpdateFriendlyTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.UpdateHardlock
// (BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::UpdateHardlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "UpdateHardlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.UpdateSoftlock
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::UpdateSoftlock(double DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "UpdateSoftlock");

	Params::BPC_TargetLock_C_UpdateSoftlock Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.UpdateSoftlockCamera
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::UpdateSoftlockCamera(double DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "UpdateSoftlockCamera");

	Params::BPC_TargetLock_C_UpdateSoftlockCamera Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPC_TargetLock.BPC_TargetLock_C.UpdateSoftlockTarget
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBPC_TargetLock_C::UpdateSoftlockTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "UpdateSoftlockTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPC_TargetLock.BPC_TargetLock_C.VerticalCameraRotate
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RotateSpeed                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPC_TargetLock_C::VerticalCameraRotate(double DeltaTime, double RotateSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPC_TargetLock_C", "VerticalCameraRotate");

	Params::BPC_TargetLock_C_VerticalCameraRotate Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.RotateSpeed = RotateSpeed;

	UObject::ProcessEvent(Func, &Parms);
}

}

