#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DarkForestEvents

#include "Basic.hpp"

#include "DarkForestEvents_classes.hpp"
#include "DarkForestEvents_parameters.hpp"


namespace SDK
{

// Function DarkForestEvents.DFEventCondition.CheckCondition
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFEventCondition::CheckCondition(class UWorld* World) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventCondition", "CheckCondition");

	Params::DFEventCondition_CheckCondition Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarkForestEvents.DFEventObject.AsyncLoadClass
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             ClassToLoad                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(class UClass* Class)>&Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFEventObject::AsyncLoadClass(TSoftClassPtr<class UClass> ClassToLoad, const TDelegate<void(class UClass* Class)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventObject", "AsyncLoadClass");

	Params::DFEventObject_AsyncLoadClass Parms{};

	Parms.ClassToLoad = ClassToLoad;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarkForestEvents.DFEventObject.AsyncLoadObject
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UObject>           ObjectToLoad                                           (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(class UObject* Object)>&Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFEventObject::AsyncLoadObject(TSoftObjectPtr<class UObject> ObjectToLoad, const TDelegate<void(class UObject* Object)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventObject", "AsyncLoadObject");

	Params::DFEventObject_AsyncLoadObject Parms{};

	Parms.ObjectToLoad = ObjectToLoad;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarkForestEvents.DFEventObject.FinishDeferredSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToFinishSpawn                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFEventObject::FinishDeferredSpawn(class AActor* ActorToFinishSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventObject", "FinishDeferredSpawn");

	Params::DFEventObject_FinishDeferredSpawn Parms{};

	Parms.ActorToFinishSpawn = ActorToFinishSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarkForestEvents.DFEventObject.GetEventTransform
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FDFEffectSettings&         Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FTransform>*              OutTransform                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDFEventObject::GetEventTransform(const struct FDFEffectSettings& Settings, TArray<struct FTransform>* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventObject", "GetEventTransform");

	Params::DFEventObject_GetEventTransform Parms{};

	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function DarkForestEvents.DFEventObject.GetPlayerRelativeTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FDFEventLocation&          Location                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFEventObject::GetPlayerRelativeTransform(const struct FDFEventLocation& Location, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventObject", "GetPlayerRelativeTransform");

	Params::DFEventObject_GetPlayerRelativeTransform Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function DarkForestEvents.DFEventObject.SpawnActor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDFEventObject::SpawnActor(TSubclassOf<class AActor> ActorClass, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventObject", "SpawnActor");

	Params::DFEventObject_SpawnActor Parms{};

	Parms.ActorClass = ActorClass;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarkForestEvents.DFEventObject.SpawnActorDeferred
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDFEventObject::SpawnActorDeferred(TSubclassOf<class AActor> ActorClass, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventObject", "SpawnActorDeferred");

	Params::DFEventObject_SpawnActorDeferred Parms{};

	Parms.ActorClass = ActorClass;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarkForestEvents.DFEventObject.TriggerEvent
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDFEffectSettings&         Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDFEventObject::TriggerEvent(class UWorld* World, const struct FDFEffectSettings& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventObject", "TriggerEvent");

	Params::DFEventObject_TriggerEvent Parms{};

	Parms.World = World;
	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarkForestEvents.DFEventObject.GetAllTargetPointsWithEventTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      EventTag                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>*              OutTargetPoints                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFEventObject::GetAllTargetPointsWithEventTag(const class FName& EventTag, TArray<struct FTransform>* OutTargetPoints) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventObject", "GetAllTargetPointsWithEventTag");

	Params::DFEventObject_GetAllTargetPointsWithEventTag Parms{};

	Parms.EventTag = EventTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTargetPoints != nullptr)
		*OutTargetPoints = std::move(Parms.OutTargetPoints);

	return Parms.ReturnValue;
}


// Function DarkForestEvents.DFEventsManager.AddEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDFEffectSettings&         Effect                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFEventsManager::AddEffect(const struct FDFEffectSettings& Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventsManager", "AddEffect");

	Params::DFEventsManager_AddEffect Parms{};

	Parms.Effect = std::move(Effect);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarkForestEvents.DFEventsManager.HandleEffectEnded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FActiveGameplayEffect&     Effect                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADFEventsManager::HandleEffectEnded(const struct FActiveGameplayEffect& Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventsManager", "HandleEffectEnded");

	Params::DFEventsManager_HandleEffectEnded Parms{};

	Parms.Effect = std::move(Effect);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarkForestEvents.DFEventsManager.HandleEffectExecuted
// (Final, Native, Protected)
// Parameters:
// const class UDFEffect*                  Effect                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFEventsManager::HandleEffectExecuted(const class UDFEffect* Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventsManager", "HandleEffectExecuted");

	Params::DFEventsManager_HandleEffectExecuted Parms{};

	Parms.Effect = Effect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarkForestEvents.DFEventsManager.RemoveEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDFEffectSettings&         Effect                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADFEventsManager::RemoveEffect(const struct FDFEffectSettings& Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventsManager", "RemoveEffect");

	Params::DFEventsManager_RemoveEffect Parms{};

	Parms.Effect = std::move(Effect);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarkForestEvents.DFEventTriggerZone.OnOverlapBegin
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADFEventTriggerZone::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventTriggerZone", "OnOverlapBegin");

	Params::DFEventTriggerZone_OnOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarkForestEvents.DFEventTriggerZone.OnOverlapEnd
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFEventTriggerZone::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventTriggerZone", "OnOverlapEnd");

	Params::DFEventTriggerZone_OnOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarkForestEvents.DFEventTriggerZone.SetEventBillboardTexture
// (Final, Native, Protected, BlueprintCallable)

void ADFEventTriggerZone::SetEventBillboardTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFEventTriggerZone", "SetEventBillboardTexture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

