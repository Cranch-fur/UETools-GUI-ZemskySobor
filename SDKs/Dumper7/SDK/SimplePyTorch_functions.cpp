#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SimplePyTorch

#include "Basic.hpp"

#include "SimplePyTorch_classes.hpp"
#include "SimplePyTorch_parameters.hpp"


namespace SDK
{

// Function SimplePyTorch.SimpleTorchModule.CreateSimpleTorchModule
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InParent                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USimpleTorchModule*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USimpleTorchModule* USimpleTorchModule::CreateSimpleTorchModule(class UObject* InParent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SimpleTorchModule", "CreateSimpleTorchModule");

	Params::SimpleTorchModule_CreateSimpleTorchModule Parms{};

	Parms.InParent = InParent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SimplePyTorch.SimpleTorchModule.DoForwardCall
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSimpleTorchTensor&        InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSimpleTorchTensor*              OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimpleTorchModule::DoForwardCall(const struct FSimpleTorchTensor& InData, struct FSimpleTorchTensor* OutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleTorchModule", "DoForwardCall");

	Params::SimpleTorchModule_DoForwardCall Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);

	return Parms.ReturnValue;
}


// Function SimplePyTorch.SimpleTorchModule.ExecuteModelMethod
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    MethodName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSimpleTorchTensor&        InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSimpleTorchTensor*              OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimpleTorchModule::ExecuteModelMethod(const class FString& MethodName, const struct FSimpleTorchTensor& InData, struct FSimpleTorchTensor* OutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleTorchModule", "ExecuteModelMethod");

	Params::SimpleTorchModule_ExecuteModelMethod Parms{};

	Parms.MethodName = std::move(MethodName);
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);

	return Parms.ReturnValue;
}


// Function SimplePyTorch.SimpleTorchModule.LoadTorchScriptModel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimpleTorchModule::LoadTorchScriptModel(const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleTorchModule", "LoadTorchScriptModel");

	Params::SimpleTorchModule_LoadTorchScriptModel Parms{};

	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SimplePyTorch.SimpleTorchModule.IsTorchModelLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimpleTorchModule::IsTorchModelLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleTorchModule", "IsTorchModelLoaded");

	Params::SimpleTorchModule_IsTorchModelLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

