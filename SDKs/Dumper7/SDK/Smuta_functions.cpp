#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Smuta

#include "Basic.hpp"

#include "Smuta_classes.hpp"
#include "Smuta_parameters.hpp"


namespace SDK
{

// Function Smuta.ReactionCondition.CheckCondition
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UReactionCondition::CheckCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReactionCondition", "CheckCondition");

	Params::ReactionCondition_CheckCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ReactionCondition.StartCondition
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReactionCondition::StartCondition(class AActor* OwnerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReactionCondition", "StartCondition");

	Params::ReactionCondition_StartCondition Parms{};

	Parms.OwnerActor = OwnerActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.ActorTagCondition.InitCondition
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTagQuery&         InQuery                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorTagCondition::InitCondition(const struct FGameplayTagQuery& InQuery, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorTagCondition", "InitCondition");

	Params::ActorTagCondition_InitCondition Parms{};

	Parms.InQuery = std::move(InQuery);
	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ActorTagCondition.OnActorTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exists                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorTagCondition::OnActorTagChanged(const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorTagCondition", "OnActorTagChanged");

	Params::ActorTagCondition_OnActorTagChanged Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AbilityBase.CancelAllASCAbilities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     WithTags                                               (ConstParm, Parm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     WithoutTags                                            (ConstParm, Parm, NativeAccessSpecifierPublic)

void UAbilityBase::CancelAllASCAbilities(class UAbilitySystemComponent* ASC, const struct FGameplayTagContainer& WithTags, const struct FGameplayTagContainer& WithoutTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "CancelAllASCAbilities");

	Params::AbilityBase_CancelAllASCAbilities Parms{};

	Parms.ASC = ASC;
	Parms.WithTags = std::move(WithTags);
	Parms.WithoutTags = std::move(WithoutTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AbilityBase.CommitAbilityWithAttributeCheck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayAttribute&        Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      CostEffect                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityBase::CommitAbilityWithAttributeCheck(const struct FGameplayAttribute& Attribute, TSubclassOf<class UGameplayEffect> CostEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "CommitAbilityWithAttributeCheck");

	Params::AbilityBase_CommitAbilityWithAttributeCheck Parms{};

	Parms.Attribute = std::move(Attribute);
	Parms.CostEffect = CostEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityBase.GetInputAxisValues
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Forward                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Right                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityBase::GetInputAxisValues(float* Forward, float* Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetInputAxisValues");

	Params::AbilityBase_GetInputAxisValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Forward != nullptr)
		*Forward = Parms.Forward;

	if (Right != nullptr)
		*Right = Parms.Right;
}


// Function Smuta.AbilityBase.SetEffectStackLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LimitMax                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      CostEffect                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityBase::SetEffectStackLimit(int32 LimitMax, TSubclassOf<class UGameplayEffect> CostEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "SetEffectStackLimit");

	Params::AbilityBase_SetEffectStackLimit Parms{};

	Parms.LimitMax = LimitMax;
	Parms.CostEffect = CostEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AbilityBase.GetCostValue
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAbilityBase::GetCostValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetCostValue");

	Params::AbilityBase_GetCostValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityBase.MakeEffectContextForInstigator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectContextHandle UAbilityBase::MakeEffectContextForInstigator(class AActor* Instigator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "MakeEffectContextForInstigator");

	Params::AbilityBase_MakeEffectContextForInstigator Parms{};

	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityBase.OnAbilityInputComplete
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FInputActionValue&         InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UAbilityBase::OnAbilityInputComplete(const struct FInputActionValue& InputActionValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "OnAbilityInputComplete");

	Params::AbilityBase_OnAbilityInputComplete Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.AbilityBase.OnAbilityInputStart
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FInputActionValue&         InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UAbilityBase::OnAbilityInputStart(const struct FInputActionValue& InputActionValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "OnAbilityInputStart");

	Params::AbilityBase_OnAbilityInputStart Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.AbilityCancelerComponent.AddAbilityTagsToCancel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTagContainer&     AbilityTags                                            (Parm, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityCancelerComponent::AddAbilityTagsToCancel(const struct FGameplayTagContainer& AbilityTags, class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityCancelerComponent", "AddAbilityTagsToCancel");

	Params::AbilityCancelerComponent_AddAbilityTagsToCancel Parms{};

	Parms.AbilityTags = std::move(AbilityTags);
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AbilityCancelerComponent.CancelAbilities
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAbilityCancelerComponent::CancelAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityCancelerComponent", "CancelAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AbilityCancelerComponent.GetAbilityTagsToCancel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UAbilityCancelerComponent::GetAbilityTagsToCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityCancelerComponent", "GetAbilityTagsToCancel");

	Params::AbilityCancelerComponent_GetAbilityTagsToCancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityCancelerComponent.Initialize
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityCancelerComponent::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityCancelerComponent", "Initialize");

	Params::AbilityCancelerComponent_Initialize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityCancelerComponent.OnMontageBlendingOut
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityCancelerComponent::OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityCancelerComponent", "OnMontageBlendingOut");

	Params::AbilityCancelerComponent_OnMontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AbilityCancelerComponent.OnMontageEnded
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityCancelerComponent::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityCancelerComponent", "OnMontageEnded");

	Params::AbilityCancelerComponent_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AbilityCancelerComponent.RemoveAbilityTagsToCancel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTagContainer&     AbilityTags                                            (Parm, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityCancelerComponent::RemoveAbilityTagsToCancel(const struct FGameplayTagContainer& AbilityTags, class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityCancelerComponent", "RemoveAbilityTagsToCancel");

	Params::AbilityCancelerComponent_RemoveAbilityTagsToCancel Parms{};

	Parms.AbilityTags = std::move(AbilityTags);
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AbilityCancelerComponent.ShouldCancelAbility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityCancelerComponent::ShouldCancelAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityCancelerComponent", "ShouldCancelAbility");

	Params::AbilityCancelerComponent_ShouldCancelAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AITraitsBase.Initialize
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAITraitsBase*                    AITraits                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAITraitsBase*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAITraitsBase* UAITraitsBase::Initialize(class UAITraitsBase* AITraits, class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AITraitsBase", "Initialize");

	Params::AITraitsBase_Initialize Parms{};

	Parms.AITraits = AITraits;
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AITraitsBase.ApplyPerceptionSettings
// (Final, Native, Public, BlueprintCallable)

void UAITraitsBase::ApplyPerceptionSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "ApplyPerceptionSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AITraitsBase.OnDetectionStateChanged
// (Final, Native, Protected)
// Parameters:
// class UEnemyDetectionComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetectionAIState                       NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAITraitsBase::OnDetectionStateChanged(class UEnemyDetectionComponent* Component, EDetectionAIState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "OnDetectionStateChanged");

	Params::AITraitsBase_OnDetectionStateChanged Parms{};

	Parms.Component = Component;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AITraitsBase.SetIsDay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsDay                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAITraitsBase::SetIsDay(bool bIsDay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "SetIsDay");

	Params::AITraitsBase_SetIsDay Parms{};

	Parms.bIsDay = bIsDay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AITraitsBase.SetPerceptionDebuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAITraitsBase::SetPerceptionDebuff(bool Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "SetPerceptionDebuff");

	Params::AITraitsBase_SetPerceptionDebuff Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AITraitsBase.UpdateGameDifficulty
// (Final, Native, Public)
// Parameters:
// EGameDifficulty                         NewDifficulty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAITraitsBase::UpdateGameDifficulty(EGameDifficulty NewDifficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "UpdateGameDifficulty");

	Params::AITraitsBase_UpdateGameDifficulty Parms{};

	Parms.NewDifficulty = NewDifficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AITraitsBase.GetAttributes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAITraits_Attributes             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAITraits_Attributes UAITraitsBase::GetAttributes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "GetAttributes");

	Params::AITraitsBase_GetAttributes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AITraitsBase.GetBehavior
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAITraits_Behavior               ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FAITraits_Behavior UAITraitsBase::GetBehavior() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "GetBehavior");

	Params::AITraitsBase_GetBehavior Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AITraitsBase.GetGeneralDetectionTraits
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAITraits_DetectionGeneral*      OutTraits                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAITraitsBase::GetGeneralDetectionTraits(struct FAITraits_DetectionGeneral* OutTraits) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "GetGeneralDetectionTraits");

	Params::AITraitsBase_GetGeneralDetectionTraits Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTraits != nullptr)
		*OutTraits = std::move(Parms.OutTraits);

	return Parms.ReturnValue;
}


// Function Smuta.AITraitsBase.GetPerceptionV2
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAITraits_PerceptionV2*          OutPerception                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAITraitsBase::GetPerceptionV2(struct FAITraits_PerceptionV2* OutPerception) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "GetPerceptionV2");

	Params::AITraitsBase_GetPerceptionV2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPerception != nullptr)
		*OutPerception = std::move(Parms.OutPerception);

	return Parms.ReturnValue;
}


// Function Smuta.AITraitsBase.GetSettingsDataByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UAITraitsBase::GetSettingsDataByTag(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "GetSettingsDataByTag");

	Params::AITraitsBase_GetSettingsDataByTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AITraitsBase.IsDay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAITraitsBase::IsDay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "IsDay");

	Params::AITraitsBase_IsDay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AITraitsBase.IsInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAITraitsBase::IsInitialized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "IsInitialized");

	Params::AITraitsBase_IsInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AITraitsBase.IsPerceptionDebuff
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAITraitsBase::IsPerceptionDebuff() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AITraitsBase", "IsPerceptionDebuff");

	Params::AITraitsBase_IsPerceptionDebuff Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AsyncTaskAttributeChanged.ListenForAttributeChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAttribute&        Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskAttributeChanged*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::ListenForAttributeChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskAttributeChanged", "ListenForAttributeChange");

	Params::AsyncTaskAttributeChanged_ListenForAttributeChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AsyncTaskAttributeChanged.ListenForAttributesChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGameplayAttribute>&Attributes                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UAsyncTaskAttributeChanged*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::ListenForAttributesChange(class UAbilitySystemComponent* AbilitySystemComponent, const TArray<struct FGameplayAttribute>& Attributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskAttributeChanged", "ListenForAttributesChange");

	Params::AsyncTaskAttributeChanged_ListenForAttributesChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Attributes = std::move(Attributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AsyncTaskAttributeChanged.EndTask
// (Final, Native, Public, BlueprintCallable)

void UAsyncTaskAttributeChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskAttributeChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SpawnerPointBase.Destroy
// (Native, Public, BlueprintCallable)

void ASpawnerPointBase::Destroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerPointBase", "Destroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SpawnerPointBase.GetCharacter
// (Final, Native, Public, Const)
// Parameters:
// class ADefaultCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADefaultCharacter* ASpawnerPointBase::GetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerPointBase", "GetCharacter");

	Params::SpawnerPointBase_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MatrixSpawnerBase.GetDNCClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMatrixSpawnerBase::GetDNCClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatrixSpawnerBase", "GetDNCClass");

	Params::MatrixSpawnerBase_GetDNCClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MatrixSpawnerBase.Spawn
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMatrixDataAsset*                 MatrixDataAsset                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADefaultCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADefaultCharacter* AMatrixSpawnerBase::Spawn(class UMatrixDataAsset* MatrixDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatrixSpawnerBase", "Spawn");

	Params::MatrixSpawnerBase_Spawn Parms{};

	Parms.MatrixDataAsset = MatrixDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EquipmentFunctionLibrary.CanReloadWeapon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAbilitySystemComponent*          OwnerASC                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URangeWeaponItem*                 Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  NeedToRestoreAmmo                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentFunctionLibrary::CanReloadWeapon(class UAbilitySystemComponent* OwnerASC, class URangeWeaponItem* Weapon, float* NeedToRestoreAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EquipmentFunctionLibrary", "CanReloadWeapon");

	Params::EquipmentFunctionLibrary_CanReloadWeapon Parms{};

	Parms.OwnerASC = OwnerASC;
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NeedToRestoreAmmo != nullptr)
		*NeedToRestoreAmmo = Parms.NeedToRestoreAmmo;

	return Parms.ReturnValue;
}


// Function Smuta.EquipmentFunctionLibrary.IsEnoughWeaponAmmo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAbilitySystemComponent*          OwnerASC                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URangeWeaponItem*                 Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentFunctionLibrary::IsEnoughWeaponAmmo(class UAbilitySystemComponent* OwnerASC, class URangeWeaponItem* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EquipmentFunctionLibrary", "IsEnoughWeaponAmmo");

	Params::EquipmentFunctionLibrary_IsEnoughWeaponAmmo Parms{};

	Parms.OwnerASC = OwnerASC;
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EquipmentFunctionLibrary.ReduceWeaponAmmo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          OwnerASC                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URangeWeaponItem*                 Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AmmoCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentFunctionLibrary::ReduceWeaponAmmo(class UAbilitySystemComponent* OwnerASC, class URangeWeaponItem* Weapon, float AmmoCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EquipmentFunctionLibrary", "ReduceWeaponAmmo");

	Params::EquipmentFunctionLibrary_ReduceWeaponAmmo Parms{};

	Parms.OwnerASC = OwnerASC;
	Parms.Weapon = Weapon;
	Parms.AmmoCount = AmmoCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EquipmentFunctionLibrary.ReloadWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          OwnerASC                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URangeWeaponItem*                 Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentFunctionLibrary::ReloadWeapon(class UAbilitySystemComponent* OwnerASC, class URangeWeaponItem* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EquipmentFunctionLibrary", "ReloadWeapon");

	Params::EquipmentFunctionLibrary_ReloadWeapon Parms{};

	Parms.OwnerASC = OwnerASC;
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AbilityFunctionLibrary.ApplyGameplayEffectByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UAbilitySystemComponent*    AbilitySystemComponent                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      EffectClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle UAbilityFunctionLibrary::ApplyGameplayEffectByClass(const class UAbilitySystemComponent* AbilitySystemComponent, TSubclassOf<class UGameplayEffect> EffectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityFunctionLibrary", "ApplyGameplayEffectByClass");

	Params::AbilityFunctionLibrary_ApplyGameplayEffectByClass Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.EffectClass = EffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityFunctionLibrary.ChangeAttributeValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAttribute&        Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayModOp                          ModifierOp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityFunctionLibrary::ChangeAttributeValue(class UAbilitySystemComponent* Target, const struct FGameplayAttribute& Attribute, float NewValue, EGameplayModOp ModifierOp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityFunctionLibrary", "ChangeAttributeValue");

	Params::AbilityFunctionLibrary_ChangeAttributeValue Parms{};

	Parms.Target = Target;
	Parms.Attribute = std::move(Attribute);
	Parms.NewValue = NewValue;
	Parms.ModifierOp = ModifierOp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AbilityFunctionLibrary.GetAbilityFromSpec
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayAbilitySpecDef&   Spec                                                   (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayAbility>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UGameplayAbility> UAbilityFunctionLibrary::GetAbilityFromSpec(const struct FGameplayAbilitySpecDef& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityFunctionLibrary", "GetAbilityFromSpec");

	Params::AbilityFunctionLibrary_GetAbilityFromSpec Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityFunctionLibrary.GetAttributeMagnitude
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayEffectSpecHandle& SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          Source                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAttribute&        Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAbilityFunctionLibrary::GetAttributeMagnitude(const struct FGameplayEffectSpecHandle& SpecHandle, class UAbilitySystemComponent* Source, class UAbilitySystemComponent* Target, const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityFunctionLibrary", "GetAttributeMagnitude");

	Params::AbilityFunctionLibrary_GetAttributeMagnitude Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.Source = Source;
	Parms.Target = Target;
	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityFunctionLibrary.GetBaseAbilityComponent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActor*                     Target                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBaseAbilitiesComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseAbilitiesComponent* UAbilityFunctionLibrary::GetBaseAbilityComponent(const class AActor* Target, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityFunctionLibrary", "GetBaseAbilityComponent");

	Params::AbilityFunctionLibrary_GetBaseAbilityComponent Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityFunctionLibrary.GetCapturedAttributeMagnitudePure
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UGameplayModMagnitudeCalculation*ModMagnitude                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectSpec&       Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayAttribute&        Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectAttributeCaptureSource   AttributeSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutMagnitude                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityFunctionLibrary::GetCapturedAttributeMagnitudePure(const class UGameplayModMagnitudeCalculation* ModMagnitude, const struct FGameplayEffectSpec& Spec, const struct FGameplayAttribute& Attribute, EGameplayEffectAttributeCaptureSource AttributeSource, float* OutMagnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityFunctionLibrary", "GetCapturedAttributeMagnitudePure");

	Params::AbilityFunctionLibrary_GetCapturedAttributeMagnitudePure Parms{};

	Parms.ModMagnitude = ModMagnitude;
	Parms.Spec = std::move(Spec);
	Parms.Attribute = std::move(Attribute);
	Parms.AttributeSource = AttributeSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMagnitude != nullptr)
		*OutMagnitude = Parms.OutMagnitude;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityFunctionLibrary.GetCharacterMeshLegsPosition
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           CharacterMesh                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LeftLegBoneName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RightLegBoneName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELegsPosition                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELegsPosition UAbilityFunctionLibrary::GetCharacterMeshLegsPosition(class USkeletalMeshComponent* CharacterMesh, class FName LeftLegBoneName, class FName RightLegBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityFunctionLibrary", "GetCharacterMeshLegsPosition");

	Params::AbilityFunctionLibrary_GetCharacterMeshLegsPosition Parms{};

	Parms.CharacterMesh = CharacterMesh;
	Parms.LeftLegBoneName = LeftLegBoneName;
	Parms.RightLegBoneName = RightLegBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityFunctionLibrary.GetEnemyDirection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnemyPosition                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEnemyPosition UAbilityFunctionLibrary::GetEnemyDirection(class AActor* Source, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityFunctionLibrary", "GetEnemyDirection");

	Params::AbilityFunctionLibrary_GetEnemyDirection Parms{};

	Parms.Source = Source;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityFunctionLibrary.GetInstigatorFromSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayEffectSpec&       Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAbilityFunctionLibrary::GetInstigatorFromSpec(const struct FGameplayEffectSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityFunctionLibrary", "GetInstigatorFromSpec");

	Params::AbilityFunctionLibrary_GetInstigatorFromSpec Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityFunctionLibrary.GetSourceActorTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayEffectSpec&       Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UAbilityFunctionLibrary::GetSourceActorTags(const struct FGameplayEffectSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityFunctionLibrary", "GetSourceActorTags");

	Params::AbilityFunctionLibrary_GetSourceActorTags Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityFunctionLibrary.GetTargetActorTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayEffectSpec&       Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UAbilityFunctionLibrary::GetTargetActorTags(const struct FGameplayEffectSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityFunctionLibrary", "GetTargetActorTags");

	Params::AbilityFunctionLibrary_GetTargetActorTags Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ActivatedActorChangeStateCondition.OnActorStateChanged
// (Final, Native, Protected)
// Parameters:
// EActivatedObjectState                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActivatedActorChangeStateCondition::OnActorStateChanged(EActivatedObjectState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivatedActorChangeStateCondition", "OnActorStateChanged");

	Params::ActivatedActorChangeStateCondition_OnActorStateChanged Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AbilityTask_OnTick.AbilityTaskOnTick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_OnTick*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_OnTick* UAbilityTask_OnTick::AbilityTaskOnTick(class UGameplayAbility* OwningAbility, class FName TaskInstanceName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_OnTick", "AbilityTaskOnTick");

	Params::AbilityTask_OnTick_AbilityTaskOnTick Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseActionData.GetMontage
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentType                          EquipmentType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   PairDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimMontage>      ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UAnimMontage> UBaseActionData::GetMontage(EEquipmentType EquipmentType, const struct FGameplayTagContainer& Tags, float PairDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseActionData", "GetMontage");

	Params::BaseActionData_GetMontage Parms{};

	Parms.EquipmentType = EquipmentType;
	Parms.Tags = std::move(Tags);
	Parms.PairDistance = PairDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityTask_WaitInputActionPressed.WaitInputActionPressed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTestAlreadyPressed                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitInputActionPressed*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitInputActionPressed* UAbilityTask_WaitInputActionPressed::WaitInputActionPressed(class UGameplayAbility* OwningAbility, bool bTestAlreadyPressed, class FName ActionName, EInputEvent EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitInputActionPressed", "WaitInputActionPressed");

	Params::AbilityTask_WaitInputActionPressed_WaitInputActionPressed Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.bTestAlreadyPressed = bTestAlreadyPressed;
	Parms.ActionName = ActionName;
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AbilityTask_WaitInputActionPressed.OnPressCallback
// (Final, Native, Public)

void UAbilityTask_WaitInputActionPressed::OnPressCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_WaitInputActionPressed", "OnPressCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CombatTrickAbility.OnTrickFailed
// (Event, Public, BlueprintEvent)

void UCombatTrickAbility::OnTrickFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CombatTrickAbility", "OnTrickFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.CombatTrickAbility.OnTrickSucceed
// (Event, Public, BlueprintEvent)

void UCombatTrickAbility::OnTrickSucceed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CombatTrickAbility", "OnTrickSucceed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.CombatTrickAbility.SetTrickFail
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   FailRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCombatTrickAbility::SetTrickFail(float FailRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CombatTrickAbility", "SetTrickFail");

	Params::CombatTrickAbility_SetTrickFail Parms{};

	Parms.FailRate = FailRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.CombatTrickAbility.SetTrickSuccess
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   SuccessRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AgainstCharacter                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCombatTrickAbility::SetTrickSuccess(float SuccessRate, class AActor* AgainstCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CombatTrickAbility", "SetTrickSuccess");

	Params::CombatTrickAbility_SetTrickSuccess Parms{};

	Parms.SuccessRate = SuccessRate;
	Parms.AgainstCharacter = AgainstCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.CombatTrickAbility.GetAttackerAbilityComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseAbilitiesComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseAbilitiesComponent* UCombatTrickAbility::GetAttackerAbilityComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CombatTrickAbility", "GetAttackerAbilityComponent");

	Params::CombatTrickAbility_GetAttackerAbilityComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CombatTrickAbility.GetAttackerActor
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADefaultCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADefaultCharacter* UCombatTrickAbility::GetAttackerActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CombatTrickAbility", "GetAttackerActor");

	Params::CombatTrickAbility_GetAttackerActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CombatTrickAbility.GetDefenderAbilityComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseAbilitiesComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseAbilitiesComponent* UCombatTrickAbility::GetDefenderAbilityComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CombatTrickAbility", "GetDefenderAbilityComponent");

	Params::CombatTrickAbility_GetDefenderAbilityComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CombatTrickAbility.GetDefenderActor
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADefaultCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADefaultCharacter* UCombatTrickAbility::GetDefenderActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CombatTrickAbility", "GetDefenderActor");

	Params::CombatTrickAbility_GetDefenderActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ActionAnimationEffectComponent.OnActionMontageEnded
// (Final, Native, Private, Const)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionAnimationEffectComponent::OnActionMontageEnded(class UAnimMontage* Montage, bool bInterrupted) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionAnimationEffectComponent", "OnActionMontageEnded");

	Params::ActionAnimationEffectComponent_OnActionMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.WidgetComponentUMG.GetOwningActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UWidgetComponentUMG::GetOwningActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetComponentUMG", "GetOwningActor");

	Params::WidgetComponentUMG_GetOwningActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ComboActionData.GetAnimMetaData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimMetaData>        DataTypeClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimMontage>      Montage                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMetaData*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMetaData* UComboActionData::GetAnimMetaData(TSubclassOf<class UAnimMetaData> DataTypeClass, TSoftObjectPtr<class UAnimMontage> Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ComboActionData", "GetAnimMetaData");

	Params::ComboActionData_GetAnimMetaData Parms{};

	Parms.DataTypeClass = DataTypeClass;
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ComboActionData.GetAnimMetaDataFromMontagePtr
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimMetaData>        DataTypeClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMetaData*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMetaData* UComboActionData::GetAnimMetaDataFromMontagePtr(TSubclassOf<class UAnimMetaData> DataTypeClass, class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ComboActionData", "GetAnimMetaDataFromMontagePtr");

	Params::ComboActionData_GetAnimMetaDataFromMontagePtr Parms{};

	Parms.DataTypeClass = DataTypeClass;
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ActionDataAsset.GetActionData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActionDataAsset*                 DataAsset                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeleton*                        Skeleton                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UBaseActionData>      ActionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ActionTag                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBaseActionData*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseActionData* UActionDataAsset::GetActionData(class UActionDataAsset* DataAsset, class USkeleton* Skeleton, TSubclassOf<class UBaseActionData> ActionClass, const struct FGameplayTag& ActionTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataAsset", "GetActionData");

	Params::ActionDataAsset_GetActionData Parms{};

	Parms.DataAsset = DataAsset;
	Parms.Skeleton = Skeleton;
	Parms.ActionClass = ActionClass;
	Parms.ActionTag = std::move(ActionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ActionDataAsset.CallOnDataChanged
// (Final, Native, Public, BlueprintCallable)

void UActionDataAsset::CallOnDataChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionDataAsset", "CallOnDataChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ActionDataAsset.GetActionDataWithTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeleton*                        Skeleton                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UBaseActionData>      ActionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ActionTag                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBaseActionData*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseActionData* UActionDataAsset::GetActionDataWithTag(class USkeleton* Skeleton, TSubclassOf<class UBaseActionData> ActionClass, const struct FGameplayTag& ActionTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionDataAsset", "GetActionDataWithTag");

	Params::ActionDataAsset_GetActionDataWithTag Parms{};

	Parms.Skeleton = Skeleton;
	Parms.ActionClass = ActionClass;
	Parms.ActionTag = std::move(ActionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AppearanceDataAsset.SetPlayerAppearance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UAppearanceDataAsset*       Appearance                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceDataAsset::SetPlayerAppearance(const class UAppearanceDataAsset* Appearance, const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppearanceDataAsset", "SetPlayerAppearance");

	Params::AppearanceDataAsset_SetPlayerAppearance Parms{};

	Parms.Appearance = Appearance;
	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaEquipmentComponent.TagChangedResponse
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExists                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaEquipmentComponent::TagChangedResponse(const struct FGameplayTag& UpdatedTag, bool bExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaEquipmentComponent", "TagChangedResponse");

	Params::SmutaEquipmentComponent_TagChangedResponse Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.bExists = bExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.HumanPOI.FilterDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHumanRoleType                          FirstCharType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHumanRoleType                          SecondCharType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenderType                             FirstCharGender                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenderType                             SecondCharGender                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UMatrixDialogue*>&   Dialogues                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UMatrixDialogue*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatrixDialogue* AHumanPOI::FilterDialogue(EHumanRoleType FirstCharType, EHumanRoleType SecondCharType, EGenderType FirstCharGender, EGenderType SecondCharGender, const TArray<class UMatrixDialogue*>& Dialogues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPOI", "FilterDialogue");

	Params::HumanPOI_FilterDialogue Parms{};

	Parms.FirstCharType = FirstCharType;
	Parms.SecondCharType = SecondCharType;
	Parms.FirstCharGender = FirstCharGender;
	Parms.SecondCharGender = SecondCharGender;
	Parms.Dialogues = std::move(Dialogues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ActionRollComponent.InitializeTraits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAITraitsBase*                    Traits                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionRollComponent::InitializeTraits(class UAITraitsBase* Traits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionRollComponent", "InitializeTraits");

	Params::ActionRollComponent_InitializeTraits Parms{};

	Parms.Traits = Traits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ActionRollComponent.RollAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// Smuta::ENPCAction                       Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OverrideBaseChance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseChanceOverridedValue                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionRollComponent::RollAction(Smuta::ENPCAction Action, bool OverrideBaseChance, float BaseChanceOverridedValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionRollComponent", "RollAction");

	Params::ActionRollComponent_RollAction Parms{};

	Parms.Action = Action;
	Parms.OverrideBaseChance = OverrideBaseChance;
	Parms.BaseChanceOverridedValue = BaseChanceOverridedValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ActivatedActor.ChangeActivateObjectState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EActivatedObjectState                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActivatedActor::ChangeActivateObjectState(EActivatedObjectState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivatedActor", "ChangeActivateObjectState");

	Params::ActivatedActor_ChangeActivateObjectState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ActivatedActor.GetHitPointReceiverComponent
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* AActivatedActor::GetHitPointReceiverComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivatedActor", "GetHitPointReceiverComponent");

	Params::ActivatedActor_GetHitPointReceiverComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ActivatedActor.OnReceiverComponentHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AActivatedActor::OnReceiverComponentHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivatedActor", "OnReceiverComponentHit");

	Params::ActivatedActor_OnReceiverComponentHit Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ActivatedActor.PreChangeActivateObjectState
// (Native, Protected, BlueprintCallable)
// Parameters:
// EActivatedObjectState                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActivatedActor::PreChangeActivateObjectState(EActivatedObjectState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivatedActor", "PreChangeActivateObjectState");

	Params::ActivatedActor_PreChangeActivateObjectState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SignificanceActorComponent.DisableOptimization
// (Native, Protected, BlueprintCallable)

void USignificanceActorComponent::DisableOptimization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SignificanceActorComponent", "DisableOptimization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SignificanceActorComponent.GetSkipOtimization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USignificanceActorComponent::GetSkipOtimization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SignificanceActorComponent", "GetSkipOtimization");

	Params::SignificanceActorComponent_GetSkipOtimization Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SignificanceActorComponent.SetSkipOptimization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkip                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USignificanceActorComponent::SetSkipOptimization(bool bSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SignificanceActorComponent", "SetSkipOptimization");

	Params::SignificanceActorComponent_SetSkipOptimization Parms{};

	Parms.bSkip = bSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AISense_Smuta_Hearing.ReportSmutaNoiseEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NoiseLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NoiseRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISense_Smuta_Hearing::ReportSmutaNoiseEvent(class UObject* WorldContextObject, const struct FVector& NoiseLocation, float NoiseRadius, class AActor* Instigator, float MaxRange, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AISense_Smuta_Hearing", "ReportSmutaNoiseEvent");

	Params::AISense_Smuta_Hearing_ReportSmutaNoiseEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NoiseLocation = std::move(NoiseLocation);
	Parms.NoiseRadius = NoiseRadius;
	Parms.Instigator = Instigator;
	Parms.MaxRange = MaxRange;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AISense_Smuta_Hearing.ReportSmutaProlongedNoiseEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NoiseLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NoiseDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NoiseRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISense_Smuta_Hearing::ReportSmutaProlongedNoiseEvent(class UObject* WorldContextObject, const struct FVector& NoiseLocation, float NoiseDuration, float NoiseRadius, class AActor* Instigator, float MaxRange, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AISense_Smuta_Hearing", "ReportSmutaProlongedNoiseEvent");

	Params::AISense_Smuta_Hearing_ReportSmutaProlongedNoiseEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NoiseLocation = std::move(NoiseLocation);
	Parms.NoiseDuration = NoiseDuration;
	Parms.NoiseRadius = NoiseRadius;
	Parms.Instigator = Instigator;
	Parms.MaxRange = MaxRange;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BehaviourTreeSettingInterface.GetSettingsDataObjectClass
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag*                    DataTag                                                (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UObject> IBehaviourTreeSettingInterface::GetSettingsDataObjectClass(struct FGameplayTag* DataTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BehaviourTreeSettingInterface", "GetSettingsDataObjectClass");

	Params::BehaviourTreeSettingInterface_GetSettingsDataObjectClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DataTag != nullptr)
		*DataTag = std::move(Parms.DataTag);

	return Parms.ReturnValue;
}


// Function Smuta.AIUtilsStatics.GetActorCurrentEnemy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAIUtilsStatics::GetActorCurrentEnemy(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIUtilsStatics", "GetActorCurrentEnemy");

	Params::AIUtilsStatics_GetActorCurrentEnemy Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AIUtilsStatics.GetCurrentEnemy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAIUtilsStatics::GetCurrentEnemy(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AIUtilsStatics", "GetCurrentEnemy");

	Params::AIUtilsStatics_GetCurrentEnemy Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AmmoStationBase.OnInteracted
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InteractedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAmmoStationBase::OnInteracted(class AActor* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoStationBase", "OnInteracted");

	Params::AmmoStationBase_OnInteracted Parms{};

	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AnimFunctionLibrary.GetAngleBeforeRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       ActorSelf                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimFunctionLibrary::GetAngleBeforeRotation(class ACharacter* ActorSelf, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetAngleBeforeRotation");

	Params::AnimFunctionLibrary_GetAngleBeforeRotation Parms{};

	Parms.ActorSelf = ActorSelf;
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.GetAngleToArrowRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       ActorSelf                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  RotationDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimFunctionLibrary::GetAngleToArrowRotation(class ACharacter* ActorSelf, const struct FRotator& RotationDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetAngleToArrowRotation");

	Params::AnimFunctionLibrary_GetAngleToArrowRotation Parms{};

	Parms.ActorSelf = ActorSelf;
	Parms.RotationDirection = std::move(RotationDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.GetCurrentMontageLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimFunctionLibrary::GetCurrentMontageLength(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetCurrentMontageLength");

	Params::AnimFunctionLibrary_GetCurrentMontageLength Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.GetDirectionFromAngle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERoute                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERoute UAnimFunctionLibrary::GetDirectionFromAngle(float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetDirectionFromAngle");

	Params::AnimFunctionLibrary_GetDirectionFromAngle Parms{};

	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.GetDirectionToTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERoute                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERoute UAnimFunctionLibrary::GetDirectionToTarget(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetDirectionToTarget");

	Params::AnimFunctionLibrary_GetDirectionToTarget Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.GetEyesAndHeadDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorTarget                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  HeadOffset                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         EyesLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimFunctionLibrary::GetEyesAndHeadDirection(const class UAnimInstance* AnimInstance, class AActor* ActorTarget, class FName SocketName, float* HeadOffset, struct FVector* EyesLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetEyesAndHeadDirection");

	Params::AnimFunctionLibrary_GetEyesAndHeadDirection Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.ActorTarget = ActorTarget;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HeadOffset != nullptr)
		*HeadOffset = Parms.HeadOffset;

	if (EyesLocation != nullptr)
		*EyesLocation = std::move(Parms.EyesLocation);
}


// Function Smuta.AnimFunctionLibrary.GetEyesDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorTarget                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         LeftEye                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         RightEye                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimFunctionLibrary::GetEyesDirection(const class UAnimInstance* AnimInstance, class AActor* ActorTarget, class FName SocketName, struct FVector* LeftEye, struct FVector* RightEye)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetEyesDirection");

	Params::AnimFunctionLibrary_GetEyesDirection Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.ActorTarget = ActorTarget;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LeftEye != nullptr)
		*LeftEye = std::move(Parms.LeftEye);

	if (RightEye != nullptr)
		*RightEye = std::move(Parms.RightEye);
}


// Function Smuta.AnimFunctionLibrary.GetGroundNormal
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Right                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Forward                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimFunctionLibrary::GetGroundNormal(const class UAnimInstance* AnimInstance, float* Right, float* Forward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetGroundNormal");

	Params::AnimFunctionLibrary_GetGroundNormal Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Right != nullptr)
		*Right = Parms.Right;

	if (Forward != nullptr)
		*Forward = Parms.Forward;
}


// Function Smuta.AnimFunctionLibrary.GetGroundNormalAtFourPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleHalfHeight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Right                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Forward                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Up                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FBOffset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RLOffset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimFunctionLibrary::GetGroundNormalAtFourPoints(const class UAnimInstance* AnimInstance, float CapsuleHalfHeight, bool Debug, float* Right, float* Forward, float* Up, float FBOffset, float RLOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetGroundNormalAtFourPoints");

	Params::AnimFunctionLibrary_GetGroundNormalAtFourPoints Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.CapsuleHalfHeight = CapsuleHalfHeight;
	Parms.Debug = Debug;
	Parms.FBOffset = FBOffset;
	Parms.RLOffset = RLOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Right != nullptr)
		*Right = Parms.Right;

	if (Forward != nullptr)
		*Forward = Parms.Forward;

	if (Up != nullptr)
		*Up = Parms.Up;
}


// Function Smuta.AnimFunctionLibrary.GetGroundNormalByFeetPos
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              BoneNames                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  RightAngle                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  ForwardAngle                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimFunctionLibrary::GetGroundNormalByFeetPos(const class UAnimInstance* AnimInstance, const TArray<class FName>& BoneNames, bool bDebug, float* RightAngle, float* ForwardAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetGroundNormalByFeetPos");

	Params::AnimFunctionLibrary_GetGroundNormalByFeetPos Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.BoneNames = std::move(BoneNames);
	Parms.bDebug = bDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RightAngle != nullptr)
		*RightAngle = Parms.RightAngle;

	if (ForwardAngle != nullptr)
		*ForwardAngle = Parms.ForwardAngle;
}


// Function Smuta.AnimFunctionLibrary.GetHysteresisHeadAngle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   LookDirectionAngle                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  HeadAngle                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool&                                   LookAlongCamera                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LeftThresholdAngle                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RightThresholdAngle                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ThresholdAngleRange                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimFunctionLibrary::GetHysteresisHeadAngle(float LookDirectionAngle, float* HeadAngle, bool& LookAlongCamera, float LeftThresholdAngle, float RightThresholdAngle, float ThresholdAngleRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetHysteresisHeadAngle");

	Params::AnimFunctionLibrary_GetHysteresisHeadAngle Parms{};

	Parms.LookDirectionAngle = LookDirectionAngle;
	Parms.LookAlongCamera = LookAlongCamera;
	Parms.LeftThresholdAngle = LeftThresholdAngle;
	Parms.RightThresholdAngle = RightThresholdAngle;
	Parms.ThresholdAngleRange = ThresholdAngleRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	LookAlongCamera = Parms.LookAlongCamera;

	if (HeadAngle != nullptr)
		*HeadAngle = Parms.HeadAngle;
}


// Function Smuta.AnimFunctionLibrary.GetInputVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UAnimFunctionLibrary::GetInputVector(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetInputVector");

	Params::AnimFunctionLibrary_GetInputVector Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.GetLocalInputVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UAnimFunctionLibrary::GetLocalInputVector(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetLocalInputVector");

	Params::AnimFunctionLibrary_GetLocalInputVector Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.GetMovementDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D*                       Direction                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimFunctionLibrary::GetMovementDirection(const class UAnimInstance* AnimInstance, struct FVector2D* Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetMovementDirection");

	Params::AnimFunctionLibrary_GetMovementDirection Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Direction != nullptr)
		*Direction = std::move(Parms.Direction);
}


// Function Smuta.AnimFunctionLibrary.GetRotationRate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimFunctionLibrary::GetRotationRate(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetRotationRate");

	Params::AnimFunctionLibrary_GetRotationRate Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.GetSoftToLipsync
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    Path                                                   (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            LipsyncList                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimSequence>     ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UAnimSequence> UAnimFunctionLibrary::GetSoftToLipsync(const class FString& Path, const TArray<class FString>& LipsyncList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetSoftToLipsync");

	Params::AnimFunctionLibrary_GetSoftToLipsync Parms{};

	Parms.Path = std::move(Path);
	Parms.LipsyncList = std::move(LipsyncList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.GetSoftToNewLipsync
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    Path                                                   (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            LipsyncList                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const class FString&                    NewLipsyncPrefix                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimSequence>     ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UAnimSequence> UAnimFunctionLibrary::GetSoftToNewLipsync(const class FString& Path, const TArray<class FString>& LipsyncList, const class FString& NewLipsyncPrefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetSoftToNewLipsync");

	Params::AnimFunctionLibrary_GetSoftToNewLipsync Parms{};

	Parms.Path = std::move(Path);
	Parms.LipsyncList = std::move(LipsyncList);
	Parms.NewLipsyncPrefix = std::move(NewLipsyncPrefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.GetTargetedMovementComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTargetedCharacterMovementComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTargetedCharacterMovementComponent* UAnimFunctionLibrary::GetTargetedMovementComponent(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "GetTargetedMovementComponent");

	Params::AnimFunctionLibrary_GetTargetedMovementComponent Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.HasAnyMatchingGameplayTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     GameplayTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimFunctionLibrary::HasAnyMatchingGameplayTags(const class UAnimInstance* AnimInstance, const struct FGameplayTagContainer& GameplayTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "HasAnyMatchingGameplayTags");

	Params::AnimFunctionLibrary_HasAnyMatchingGameplayTags Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.GameplayTags = std::move(GameplayTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.IsTargetLocked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimFunctionLibrary::IsTargetLocked(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "IsTargetLocked");

	Params::AnimFunctionLibrary_IsTargetLocked Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.RotationRateWeight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimFunctionLibrary::RotationRateWeight(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "RotationRateWeight");

	Params::AnimFunctionLibrary_RotationRateWeight Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AnimFunctionLibrary.UnlinkSelfThreadSafe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimFunctionLibrary::UnlinkSelfThreadSafe(class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimFunctionLibrary", "UnlinkSelfThreadSafe");

	Params::AnimFunctionLibrary_UnlinkSelfThreadSafe Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AttackAbility.ActivateWeaponCollisionDetection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInflictDamage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHand                                   Hands                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttackAbility::ActivateWeaponCollisionDetection(bool bInflictDamage, EHand Hands)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackAbility", "ActivateWeaponCollisionDetection");

	Params::AttackAbility_ActivateWeaponCollisionDetection Parms{};

	Parms.bInflictDamage = bInflictDamage;
	Parms.Hands = Hands;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AttackAbility.DeactivateWeaponCollisionDetection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHand                                   Hands                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttackAbility::DeactivateWeaponCollisionDetection(EHand Hands)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackAbility", "DeactivateWeaponCollisionDetection");

	Params::AttackAbility_DeactivateWeaponCollisionDetection Parms{};

	Parms.Hands = Hands;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AttackAbility.OnAttackHitInflicted
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FAttackHitData&            AttackHitData                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAttackAbility::OnAttackHitInflicted(const struct FAttackHitData& AttackHitData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackAbility", "OnAttackHitInflicted");

	Params::AttackAbility_OnAttackHitInflicted Parms{};

	Parms.AttackHitData = std::move(AttackHitData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.BaseOptionalAbilityObject.GenerateOptionalDataObject
// (Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       AICharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBaseOptionalAbilityObject*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseOptionalAbilityObject* UBaseOptionalAbilityObject::GenerateOptionalDataObject(class ACharacter* AICharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseOptionalAbilityObject", "GenerateOptionalDataObject");

	Params::BaseOptionalAbilityObject_GenerateOptionalDataObject Parms{};

	Parms.AICharacter = AICharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AttackAbilityOptionalObject.GetAttackMontageTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UAttackAbilityOptionalObject::GetAttackMontageTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackAbilityOptionalObject", "GetAttackMontageTag");

	Params::AttackAbilityOptionalObject_GetAttackMontageTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AttributeBarWidget.UpdateAttributeBar
// (Native, Event, Protected, BlueprintEvent)

void UAttributeBarWidget::UpdateAttributeBar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeBarWidget", "UpdateAttributeBar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.AttributeBarWidget.GetAttributeBarPercent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAttributeBarWidget::GetAttributeBarPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeBarWidget", "GetAttributeBarPercent");

	Params::AttributeBarWidget_GetAttributeBarPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.AttributeBarWidget.GetProgressBarTarget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAttributeBarWidget::GetProgressBarTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeBarWidget", "GetProgressBarTarget");

	Params::AttributeBarWidget_GetProgressBarTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAbilitiesComponent.AddCustomGameplayTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     Tags                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::AddCustomGameplayTags(const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "AddCustomGameplayTags");

	Params::BaseAbilitiesComponent_AddCustomGameplayTags Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.BP_AddLooseGameplayTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::BP_AddLooseGameplayTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "BP_AddLooseGameplayTag");

	Params::BaseAbilitiesComponent_BP_AddLooseGameplayTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.BP_AddLooseGameplayTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::BP_AddLooseGameplayTags(const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "BP_AddLooseGameplayTags");

	Params::BaseAbilitiesComponent_BP_AddLooseGameplayTags Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.BP_RemoveLooseGameplayTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::BP_RemoveLooseGameplayTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "BP_RemoveLooseGameplayTag");

	Params::BaseAbilitiesComponent_BP_RemoveLooseGameplayTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.BP_RemoveLooseGameplayTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::BP_RemoveLooseGameplayTags(const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "BP_RemoveLooseGameplayTags");

	Params::BaseAbilitiesComponent_BP_RemoveLooseGameplayTags Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.CallOnAttackFinished
// (Final, Native, Public, BlueprintCallable)

void UBaseAbilitiesComponent::CallOnAttackFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "CallOnAttackFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.CallOnAttackStarted
// (Final, Native, Public, BlueprintCallable)

void UBaseAbilitiesComponent::CallOnAttackStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "CallOnAttackStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.CanActivateAbility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UGameplayAbility>     Ability                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAbilitiesComponent::CanActivateAbility(TSubclassOf<class UGameplayAbility> Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "CanActivateAbility");

	Params::BaseAbilitiesComponent_CanActivateAbility Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAbilitiesComponent.CancelAbilitiesWithTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     WithTags                                               (ConstParm, Parm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     WithoutTags                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 Ignore                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::CancelAbilitiesWithTags(const struct FGameplayTagContainer& WithTags, const struct FGameplayTagContainer& WithoutTags, class UGameplayAbility* Ignore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "CancelAbilitiesWithTags");

	Params::BaseAbilitiesComponent_CancelAbilitiesWithTags Parms{};

	Parms.WithTags = std::move(WithTags);
	Parms.WithoutTags = std::move(WithoutTags);
	Parms.Ignore = Ignore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.ChangeEffectDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FActiveGameplayEffectHandle&Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeDiff                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::ChangeEffectDuration(const struct FActiveGameplayEffectHandle& Handle, float TimeDiff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "ChangeEffectDuration");

	Params::BaseAbilitiesComponent_ChangeEffectDuration Parms{};

	Parms.Handle = std::move(Handle);
	Parms.TimeDiff = TimeDiff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.GetGameplayTagsByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer*           OutContainer                                           (Parm, OutParm, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::GetGameplayTagsByTag(const struct FGameplayTag& Tag, struct FGameplayTagContainer* OutContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "GetGameplayTagsByTag");

	Params::BaseAbilitiesComponent_GetGameplayTagsByTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutContainer != nullptr)
		*OutContainer = std::move(Parms.OutContainer);
}


// Function Smuta.BaseAbilitiesComponent.IsAbilityGranted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UGameplayAbility>     Ability                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAbilitiesComponent::IsAbilityGranted(TSubclassOf<class UGameplayAbility> Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "IsAbilityGranted");

	Params::BaseAbilitiesComponent_IsAbilityGranted Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAbilitiesComponent.OnRep_AttributePoints
// (Final, Native, Private)
// Parameters:
// int32                                   OldAttributePoints                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::OnRep_AttributePoints(int32 OldAttributePoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "OnRep_AttributePoints");

	Params::BaseAbilitiesComponent_OnRep_AttributePoints Parms{};

	Parms.OldAttributePoints = OldAttributePoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.OnRep_Level
// (Final, Native, Private)
// Parameters:
// int32                                   OldLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::OnRep_Level(int32 OldLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "OnRep_Level");

	Params::BaseAbilitiesComponent_OnRep_Level Parms{};

	Parms.OldLevel = OldLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.OnRep_SpellPoints
// (Final, Native, Private)
// Parameters:
// int32                                   OldSpellPoints                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::OnRep_SpellPoints(int32 OldSpellPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "OnRep_SpellPoints");

	Params::BaseAbilitiesComponent_OnRep_SpellPoints Parms{};

	Parms.OldSpellPoints = OldSpellPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.OnRep_XP
// (Final, Native, Private)
// Parameters:
// int32                                   OldXP                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::OnRep_XP(int32 OldXP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "OnRep_XP");

	Params::BaseAbilitiesComponent_OnRep_XP Parms{};

	Parms.OldXP = OldXP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.RemoveCustomGameplayTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     Tags                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::RemoveCustomGameplayTags(const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "RemoveCustomGameplayTags");

	Params::BaseAbilitiesComponent_RemoveCustomGameplayTags Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.RemoveOneActiveGameplayEffectByClass
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      GameplayEffect                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          InstigatorAbilitySystemComponent                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::RemoveOneActiveGameplayEffectByClass(TSubclassOf<class UGameplayEffect> GameplayEffect, class UAbilitySystemComponent* InstigatorAbilitySystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "RemoveOneActiveGameplayEffectByClass");

	Params::BaseAbilitiesComponent_RemoveOneActiveGameplayEffectByClass Parms{};

	Parms.GameplayEffect = GameplayEffect;
	Parms.InstigatorAbilitySystemComponent = InstigatorAbilitySystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.SetDefaultStartingData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAITraits_Attributes&      Attributes                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::SetDefaultStartingData(const struct FAITraits_Attributes& Attributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "SetDefaultStartingData");

	Params::BaseAbilitiesComponent_SetDefaultStartingData Parms{};

	Parms.Attributes = std::move(Attributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.SetLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::SetLevel(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "SetLevel");

	Params::BaseAbilitiesComponent_SetLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.SetSpellPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InPoints                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::SetSpellPoints(int32 InPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "SetSpellPoints");

	Params::BaseAbilitiesComponent_SetSpellPoints Parms{};

	Parms.InPoints = InPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.SetXP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InXP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::SetXP(int32 InXP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "SetXP");

	Params::BaseAbilitiesComponent_SetXP Parms{};

	Parms.InXP = InXP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAbilitiesComponent.GetDeltaRequirementXP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBaseAbilitiesComponent::GetDeltaRequirementXP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "GetDeltaRequirementXP");

	Params::BaseAbilitiesComponent_GetDeltaRequirementXP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAbilitiesComponent.GetGameplayEffectStartTimeAndDuration
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FActiveGameplayEffectHandle&Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  EffectStartTime                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  EffectDuration                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitiesComponent::GetGameplayEffectStartTimeAndDuration(const struct FActiveGameplayEffectHandle& Handle, float* EffectStartTime, float* EffectDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "GetGameplayEffectStartTimeAndDuration");

	Params::BaseAbilitiesComponent_GetGameplayEffectStartTimeAndDuration Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EffectStartTime != nullptr)
		*EffectStartTime = Parms.EffectStartTime;

	if (EffectDuration != nullptr)
		*EffectDuration = Parms.EffectDuration;
}


// Function Smuta.BaseAbilitiesComponent.GetMaxLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBaseAbilitiesComponent::GetMaxLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "GetMaxLevel");

	Params::BaseAbilitiesComponent_GetMaxLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAbilitiesComponent.GetPlayerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBaseAbilitiesComponent::GetPlayerLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "GetPlayerLevel");

	Params::BaseAbilitiesComponent_GetPlayerLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAbilitiesComponent.GetSpellPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBaseAbilitiesComponent::GetSpellPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "GetSpellPoints");

	Params::BaseAbilitiesComponent_GetSpellPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAbilitiesComponent.GetXP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBaseAbilitiesComponent::GetXP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "GetXP");

	Params::BaseAbilitiesComponent_GetXP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAbilitiesComponent.GetXPForThisLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBaseAbilitiesComponent::GetXPForThisLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "GetXPForThisLevel");

	Params::BaseAbilitiesComponent_GetXPForThisLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAbilitiesComponent.IsAtMaxLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAbilitiesComponent::IsAtMaxLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitiesComponent", "IsAtMaxLevel");

	Params::BaseAbilitiesComponent_IsAtMaxLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EquipmentDefinedPairedActionData.GetMontagesData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPairedTaggedMontages*           ResultPairedTaggedMontages                             (Parm, OutParm, NativeAccessSpecifierPublic)
// EEquipmentType                          EquipmentType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PairDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentDefinedPairedActionData::GetMontagesData(struct FPairedTaggedMontages* ResultPairedTaggedMontages, EEquipmentType EquipmentType, float PairDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentDefinedPairedActionData", "GetMontagesData");

	Params::EquipmentDefinedPairedActionData_GetMontagesData Parms{};

	Parms.EquipmentType = EquipmentType;
	Parms.PairDistance = PairDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResultPairedTaggedMontages != nullptr)
		*ResultPairedTaggedMontages = std::move(Parms.ResultPairedTaggedMontages);
}


// Function Smuta.BaseAnimInstance.GetMovementDirection
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UBaseAnimInstance::GetMovementDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAnimInstance", "GetMovementDirection");

	Params::BaseAnimInstance_GetMovementDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAnimInstance.StopDialogAnimation
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UBaseAnimInstance::StopDialogAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAnimInstance", "StopDialogAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.BaseAnimInstance.GetLookDirectionAngle
// (Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UBaseAnimInstance::GetLookDirectionAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAnimInstance", "GetLookDirectionAngle");

	Params::BaseAnimInstance_GetLookDirectionAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAnimInstance.GetMovementAxis
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UBaseAnimInstance::GetMovementAxis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAnimInstance", "GetMovementAxis");

	Params::BaseAnimInstance_GetMovementAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAnimInstance.GetRootMotionMode
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERootMotionMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERootMotionMode UBaseAnimInstance::GetRootMotionMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAnimInstance", "GetRootMotionMode");

	Params::BaseAnimInstance_GetRootMotionMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAnimInstance.IsMoving
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAnimInstance::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAnimInstance", "IsMoving");

	Params::BaseAnimInstance_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAnimInstance.IsMovingForward
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAnimInstance::IsMovingForward() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAnimInstance", "IsMovingForward");

	Params::BaseAnimInstance_IsMovingForward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAnimInstance.IsSprint
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAnimInstance::IsSprint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAnimInstance", "IsSprint");

	Params::BaseAnimInstance_IsSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseAttributes.OnRep_MaxNoiseRange
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxNoiseRange                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBaseAttributes::OnRep_MaxNoiseRange(const struct FGameplayAttributeData& OldMaxNoiseRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttributes", "OnRep_MaxNoiseRange");

	Params::BaseAttributes_OnRep_MaxNoiseRange Parms{};

	Parms.OldMaxNoiseRange = std::move(OldMaxNoiseRange);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAttributes.OnRep_MaxStealthRange
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxStealthRange                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBaseAttributes::OnRep_MaxStealthRange(const struct FGameplayAttributeData& OldMaxStealthRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttributes", "OnRep_MaxStealthRange");

	Params::BaseAttributes_OnRep_MaxStealthRange Parms{};

	Parms.OldMaxStealthRange = std::move(OldMaxStealthRange);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAttributes.OnRep_NoiseRange
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// const struct FGameplayAttributeData&    OldNoiseRange                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBaseAttributes::OnRep_NoiseRange(const struct FGameplayAttributeData& OldNoiseRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttributes", "OnRep_NoiseRange");

	Params::BaseAttributes_OnRep_NoiseRange Parms{};

	Parms.OldNoiseRange = std::move(OldNoiseRange);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseAttributes.OnRep_StealthRange
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// const struct FGameplayAttributeData&    OldStealthRange                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBaseAttributes::OnRep_StealthRange(const struct FGameplayAttributeData& OldStealthRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttributes", "OnRep_StealthRange");

	Params::BaseAttributes_OnRep_StealthRange Parms{};

	Parms.OldStealthRange = std::move(OldStealthRange);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DieInterface.Die
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IDieInterface::Die()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DieInterface", "Die");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DieInterface.IsDead
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDieInterface::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DieInterface", "IsDead");

	Params::DieInterface_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseCheatManager.LogBenchmarkResult
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FStringValuePair>&  Results                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBaseCheatManager::LogBenchmarkResult(const TArray<struct FStringValuePair>& Results)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BaseCheatManager", "LogBenchmarkResult");

	Params::BaseCheatManager_LogBenchmarkResult Parms{};

	Parms.Results = std::move(Results);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseCheatManager.OnLevelSequencePlayerCameraCut
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCameraComponent*                 CameraComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseCheatManager::OnLevelSequencePlayerCameraCut(class UCameraComponent* CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BaseCheatManager", "OnLevelSequencePlayerCameraCut");

	Params::BaseCheatManager_OnLevelSequencePlayerCameraCut Parms{};

	Parms.CameraComponent = CameraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseCheatManager.StartBenchmarkTest
// (Final, Native, Static, Public, BlueprintCallable)

void UBaseCheatManager::StartBenchmarkTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BaseCheatManager", "StartBenchmarkTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseCheatManager.StopBenchmarkTest
// (Final, Native, Static, Public, BlueprintCallable)

void UBaseCheatManager::StopBenchmarkTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BaseCheatManager", "StopBenchmarkTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseCheatManager.SetCodexArticleOpened
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// const class FName&                      ArticleId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseCheatManager::SetCodexArticleOpened(const class FName& ArticleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCheatManager", "SetCodexArticleOpened");

	Params::BaseCheatManager_SetCodexArticleOpened Parms{};

	Parms.ArticleId = ArticleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseCheatManager.SetCodexArticlesOpened
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// const TArray<class FName>&              Articles                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBaseCheatManager::SetCodexArticlesOpened(const TArray<class FName>& Articles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCheatManager", "SetCodexArticlesOpened");

	Params::BaseCheatManager_SetCodexArticlesOpened Parms{};

	Parms.Articles = std::move(Articles);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseCheatManager.StartFPSCounter
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<class FString>&            Args                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBaseCheatManager::StartFPSCounter(const TArray<class FString>& Args)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCheatManager", "StartFPSCounter");

	Params::BaseCheatManager_StartFPSCounter Parms{};

	Parms.Args = std::move(Args);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseModMagnitudeCalculation.GetInstigatorActor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayEffectSpec&       Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UBaseModMagnitudeCalculation::GetInstigatorActor(const struct FGameplayEffectSpec& Spec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModMagnitudeCalculation", "GetInstigatorActor");

	Params::BaseModMagnitudeCalculation_GetInstigatorActor Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseVertexActor.BlueprintSetupVAT
// (Event, Public, BlueprintEvent)

void ABaseVertexActor::BlueprintSetupVAT()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseVertexActor", "BlueprintSetupVAT");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.BaseVertexActor.BlueprintStatusVAT
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseVertexActor::BlueprintStatusVAT(bool Activate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseVertexActor", "BlueprintStatusVAT");

	Params::BaseVertexActor_BlueprintStatusVAT Parms{};

	Parms.Activate = Activate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.BaseVertexActor.DebugInfo
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ShowInfo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseVertexActor::DebugInfo(bool ShowInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseVertexActor", "DebugInfo");

	Params::BaseVertexActor_DebugInfo Parms{};

	Parms.ShowInfo = ShowInfo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.BaseVertexActor.GetActiveVAT
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseVertexActor::GetActiveVAT()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseVertexActor", "GetActiveVAT");

	Params::BaseVertexActor_GetActiveVAT Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseVertexActor.GetHideBillboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseVertexActor::GetHideBillboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseVertexActor", "GetHideBillboard");

	Params::BaseVertexActor_GetHideBillboard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseVertexActor.SetHideBillboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseVertexActor::SetHideBillboard(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseVertexActor", "SetHideBillboard");

	Params::BaseVertexActor_SetHideBillboard Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseVertexActor.SetupVAT
// (Native, Public, BlueprintCallable)

void ABaseVertexActor::SetupVAT()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseVertexActor", "SetupVAT");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseVertexActor.StatusVAT
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseVertexActor::StatusVAT(bool Activate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseVertexActor", "StatusVAT");

	Params::BaseVertexActor_StatusVAT Parms{};

	Parms.Activate = Activate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BaseVertexActor.GetBillboardComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBillboardComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBillboardComponent* ABaseVertexActor::GetBillboardComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseVertexActor", "GetBillboardComponent");

	Params::BaseVertexActor_GetBillboardComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseVertexActor.GetBillboardStateComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBillboardComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBillboardComponent* ABaseVertexActor::GetBillboardStateComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseVertexActor", "GetBillboardStateComponent");

	Params::BaseVertexActor_GetBillboardStateComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BaseVertexActor.GetIsPlay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseVertexActor::GetIsPlay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseVertexActor", "GetIsPlay");

	Params::BaseVertexActor_GetIsPlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BattleAssistanceComponent.BindOnHitActions
// (Final, Native, Protected, BlueprintCallable)

void UBattleAssistanceComponent::BindOnHitActions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAssistanceComponent", "BindOnHitActions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleAssistanceComponent.BindOnTargetActions
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           NewAgroTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleAssistanceComponent::BindOnTargetActions(class AActor* NewAgroTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAssistanceComponent", "BindOnTargetActions");

	Params::BattleAssistanceComponent_BindOnTargetActions Parms{};

	Parms.NewAgroTarget = NewAgroTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleAssistanceComponent.GetTimeAfterLastHit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleAssistanceComponent::GetTimeAfterLastHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAssistanceComponent", "GetTimeAfterLastHit");

	Params::BattleAssistanceComponent_GetTimeAfterLastHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BattleAssistanceComponent.HandleHitTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExists                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleAssistanceComponent::HandleHitTagChanged(const struct FGameplayTag& UpdatedTag, bool bExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAssistanceComponent", "HandleHitTagChanged");

	Params::BattleAssistanceComponent_HandleHitTagChanged Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.bExists = bExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleAssistanceComponent.IsInHit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleAssistanceComponent::IsInHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAssistanceComponent", "IsInHit");

	Params::BattleAssistanceComponent_IsInHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BattleAssistanceComponent.OnActionStageChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleAssistanceComponent::OnActionStageChanged(const struct FGameplayTag& GameplayTag, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAssistanceComponent", "OnActionStageChanged");

	Params::BattleAssistanceComponent_OnActionStageChanged Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleAssistanceComponent.OnTargetTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExists                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleAssistanceComponent::OnTargetTagChanged(const struct FGameplayTag& UpdatedTag, bool bExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAssistanceComponent", "OnTargetTagChanged");

	Params::BattleAssistanceComponent_OnTargetTagChanged Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.bExists = bExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleAssistanceComponent.OnWeaponMeshHitRecieved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UEquipmentComponent*              InstigatorEquipmentComponent                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCombatHitData&            WeaponHitData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const EHand                             WeaponHand                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleAssistanceComponent::OnWeaponMeshHitRecieved(class UEquipmentComponent* InstigatorEquipmentComponent, const struct FCombatHitData& WeaponHitData, const EHand WeaponHand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAssistanceComponent", "OnWeaponMeshHitRecieved");

	Params::BattleAssistanceComponent_OnWeaponMeshHitRecieved Parms{};

	Parms.InstigatorEquipmentComponent = InstigatorEquipmentComponent;
	Parms.WeaponHitData = std::move(WeaponHitData);
	Parms.WeaponHand = WeaponHand;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleAssistanceComponent.ResetStacks
// (Final, Native, Public, BlueprintCallable)

void UBattleAssistanceComponent::ResetStacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAssistanceComponent", "ResetStacks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleAssistanceComponent.GetHitStacks
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattleAssistanceComponent::GetHitStacks() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAssistanceComponent", "GetHitStacks");

	Params::BattleAssistanceComponent_GetHitStacks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BattleAssistanceComponent.GetKickHitStacks
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattleAssistanceComponent::GetKickHitStacks() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAssistanceComponent", "GetKickHitStacks");

	Params::BattleAssistanceComponent_GetKickHitStacks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BattleStats.OnRep_Armor
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleStats::OnRep_Armor(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStats", "OnRep_Armor");

	Params::BattleStats_OnRep_Armor Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleStats.OnRep_ArmoredHitDamageReduction
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleStats::OnRep_ArmoredHitDamageReduction(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStats", "OnRep_ArmoredHitDamageReduction");

	Params::BattleStats_OnRep_ArmoredHitDamageReduction Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleStats.OnRep_ArmorIgnore
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleStats::OnRep_ArmorIgnore(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStats", "OnRep_ArmorIgnore");

	Params::BattleStats_OnRep_ArmorIgnore Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleStats.OnRep_CritChance
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleStats::OnRep_CritChance(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStats", "OnRep_CritChance");

	Params::BattleStats_OnRep_CritChance Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleStats.OnRep_Damage
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleStats::OnRep_Damage(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStats", "OnRep_Damage");

	Params::BattleStats_OnRep_Damage Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleStats.OnRep_HeavyComboLength
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleStats::OnRep_HeavyComboLength(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStats", "OnRep_HeavyComboLength");

	Params::BattleStats_OnRep_HeavyComboLength Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleStats.OnRep_HeavyDamage
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleStats::OnRep_HeavyDamage(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStats", "OnRep_HeavyDamage");

	Params::BattleStats_OnRep_HeavyDamage Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleStats.OnRep_KillExperience
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleStats::OnRep_KillExperience(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStats", "OnRep_KillExperience");

	Params::BattleStats_OnRep_KillExperience Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleStats.OnRep_LightComboLength
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleStats::OnRep_LightComboLength(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStats", "OnRep_LightComboLength");

	Params::BattleStats_OnRep_LightComboLength Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleStats.OnRep_MixedComboLength
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleStats::OnRep_MixedComboLength(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStats", "OnRep_MixedComboLength");

	Params::BattleStats_OnRep_MixedComboLength Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BattleStats.OnRep_StunChance
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleStats::OnRep_StunChance(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleStats", "OnRep_StunChance");

	Params::BattleStats_OnRep_StunChance Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.BlockAbilityOptionalObject.CalculateBlockDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlockAbilityOptionalObject::CalculateBlockDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockAbilityOptionalObject", "CalculateBlockDuration");

	Params::BlockAbilityOptionalObject_CalculateBlockDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BlockAbilityOptionalObject.GetBlockTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlockAbilityOptionalObject::GetBlockTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockAbilityOptionalObject", "GetBlockTime");

	Params::BlockAbilityOptionalObject_GetBlockTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BTDecorator_EnvQuerySetting.GetEQSSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            OwnerPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEnvQuery*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEnvQuery* UBTDecorator_EnvQuerySetting::GetEQSSetting(class APawn* OwnerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTDecorator_EnvQuerySetting", "GetEQSSetting");

	Params::BTDecorator_EnvQuerySetting_GetEQSSetting Parms{};

	Parms.OwnerPawn = OwnerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BTD_CheckHitStacks.GetHitStacks
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBTD_CheckHitStacks::GetHitStacks() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTD_CheckHitStacks", "GetHitStacks");

	Params::BTD_CheckHitStacks_GetHitStacks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.BTD_CheckHitStacks.StopHitAbility
// (Final, Native, Private, BlueprintCallable, Const)

void UBTD_CheckHitStacks::StopHitAbility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTD_CheckHitStacks", "StopHitAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ActivateAbilitySettingsObject.InitializeSettingsObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActivateAbilitySettingsObject::InitializeSettingsObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivateAbilitySettingsObject", "InitializeSettingsObject");

	Params::ActivateAbilitySettingsObject_InitializeSettingsObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CharacterBattleStateController.SetAimingEnemyState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AimingEnemyActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAiming                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterBattleStateController::SetAimingEnemyState(class AActor* AimingEnemyActor, bool bAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBattleStateController", "SetAimingEnemyState");

	Params::CharacterBattleStateController_SetAimingEnemyState Parms{};

	Parms.AimingEnemyActor = AimingEnemyActor;
	Parms.bAiming = bAiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CharacterBattleStateController.GetAllAimingEnemies
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSet<class ADefaultCharacter*>          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<class ADefaultCharacter*> UCharacterBattleStateController::GetAllAimingEnemies() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBattleStateController", "GetAllAimingEnemies");

	Params::CharacterBattleStateController_GetAllAimingEnemies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CharacterOptimizationComponent.OnTagChangedResponse
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExists                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOptimizationComponent::OnTagChangedResponse(const struct FGameplayTag& UpdatedTag, bool bExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOptimizationComponent", "OnTagChangedResponse");

	Params::CharacterOptimizationComponent_OnTagChangedResponse Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.bExists = bExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CityManager.FilterDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHumanRoleType                          FirstCharType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHumanRoleType                          SecondCharType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenderType                             FirstCharGender                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenderType                             SecondCharGender                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UMatrixDialogue*>&   Dialogues                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UMatrixDialogue*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatrixDialogue* ACityManager::FilterDialogue(EHumanRoleType FirstCharType, EHumanRoleType SecondCharType, EGenderType FirstCharGender, EGenderType SecondCharGender, const TArray<class UMatrixDialogue*>& Dialogues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CityManager", "FilterDialogue");

	Params::CityManager_FilterDialogue Parms{};

	Parms.FirstCharType = FirstCharType;
	Parms.SecondCharType = SecondCharType;
	Parms.FirstCharGender = FirstCharGender;
	Parms.SecondCharGender = SecondCharGender;
	Parms.Dialogues = std::move(Dialogues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CityManager.GetDNC
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ACityManager::GetDNC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CityManager", "GetDNC");

	Params::CityManager_GetDNC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CityManager.InitSpawners
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class AHumanMatrixSpawner*>&Spawners                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACityManager::InitSpawners(const TArray<class AHumanMatrixSpawner*>& Spawners)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CityManager", "InitSpawners");

	Params::CityManager_InitSpawners Parms{};

	Parms.Spawners = std::move(Spawners);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CityManager.SearchPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class AHumanPOI*>&         POIs                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AHumanPOI*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHumanPOI* ACityManager::SearchPoint(const TArray<class AHumanPOI*>& POIs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CityManager", "SearchPoint");

	Params::CityManager_SearchPoint Parms{};

	Parms.POIs = std::move(POIs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.ClearGlobalArticleStates
// (Final, Native, Public, BlueprintCallable)

void UCodexSubSystem::ClearGlobalArticleStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "ClearGlobalArticleStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CodexSubSystem.InitCodexCategoriesDataAsset
// (Final, Native, Protected)

void UCodexSubSystem::InitCodexCategoriesDataAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "InitCodexCategoriesDataAsset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CodexSubSystem.InitCodexDataAsset
// (Final, Native, Protected)

void UCodexSubSystem::InitCodexDataAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "InitCodexDataAsset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CodexSubSystem.OnExitSmutaGame
// (Final, Native, Private)

void UCodexSubSystem::OnExitSmutaGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "OnExitSmutaGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CodexSubSystem.OnSubSystemsInited
// (Final, Native, Protected)

void UCodexSubSystem::OnSubSystemsInited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "OnSubSystemsInited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CodexSubSystem.SetArticleNew
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ArticleId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsNew                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCodexSubSystem::SetArticleNew(const class FName& ArticleId, const bool bIsNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "SetArticleNew");

	Params::CodexSubSystem_SetArticleNew Parms{};

	Parms.ArticleId = ArticleId;
	Parms.bIsNew = bIsNew;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CodexSubSystem.SetArticleOpened
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ArticleId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsOpened                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCodexSubSystem::SetArticleOpened(const class FName& ArticleId, const bool bIsOpened)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "SetArticleOpened");

	Params::CodexSubSystem_SetArticleOpened Parms{};

	Parms.ArticleId = ArticleId;
	Parms.bIsOpened = bIsOpened;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CodexSubSystem.GetArticleCategory
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ArticleId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCodexSubSystem::GetArticleCategory(const class FName& ArticleId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "GetArticleCategory");

	Params::CodexSubSystem_GetArticleCategory Parms{};

	Parms.ArticleId = ArticleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.GetArticleIds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCodexSubSystem::GetArticleIds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "GetArticleIds");

	Params::CodexSubSystem_GetArticleIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.GetArticleImage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ArticleId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UCodexSubSystem::GetArticleImage(const class FName& ArticleId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "GetArticleImage");

	Params::CodexSubSystem_GetArticleImage Parms{};

	Parms.ArticleId = ArticleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.GetArticleName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ArticleId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCodexSubSystem::GetArticleName(const class FName& ArticleId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "GetArticleName");

	Params::CodexSubSystem_GetArticleName Parms{};

	Parms.ArticleId = ArticleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.GetArticlesCategoryData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FArticleCategoryData>*    OutData                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCodexSubSystem::GetArticlesCategoryData(TArray<struct FArticleCategoryData>* OutData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "GetArticlesCategoryData");

	Params::CodexSubSystem_GetArticlesCategoryData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.GetArticleText
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ArticleId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCodexSubSystem::GetArticleText(const class FName& ArticleId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "GetArticleText");

	Params::CodexSubSystem_GetArticleText Parms{};

	Parms.ArticleId = ArticleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.GetNewArticleIds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCodexSubSystem::GetNewArticleIds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "GetNewArticleIds");

	Params::CodexSubSystem_GetNewArticleIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.GetOpenedArticleIds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCodexSubSystem::GetOpenedArticleIds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "GetOpenedArticleIds");

	Params::CodexSubSystem_GetOpenedArticleIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.HasOpenedArticles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCodexSubSystem::HasOpenedArticles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "HasOpenedArticles");

	Params::CodexSubSystem_HasOpenedArticles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.IsArticleKnown
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ArticleId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCodexSubSystem::IsArticleKnown(const class FName& ArticleId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "IsArticleKnown");

	Params::CodexSubSystem_IsArticleKnown Parms{};

	Parms.ArticleId = ArticleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.IsNewArticle
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ArticleId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCodexSubSystem::IsNewArticle(const class FName& ArticleId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "IsNewArticle");

	Params::CodexSubSystem_IsNewArticle Parms{};

	Parms.ArticleId = ArticleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexSubSystem.IsOpenedArticle
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ArticleId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCodexSubSystem::IsOpenedArticle(const class FName& ArticleId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexSubSystem", "IsOpenedArticle");

	Params::CodexSubSystem_IsOpenedArticle Parms{};

	Parms.ArticleId = ArticleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CodexTriggerActor.SetTriggerShape
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECodexTriggerShape                      InShape                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACodexTriggerActor::SetTriggerShape(ECodexTriggerShape InShape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexTriggerActor", "SetTriggerShape");

	Params::CodexTriggerActor_SetTriggerShape Parms{};

	Parms.InShape = InShape;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CodexTriggerActor.GetTriggerShape
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECodexTriggerShape                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECodexTriggerShape ACodexTriggerActor::GetTriggerShape() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexTriggerActor", "GetTriggerShape");

	Params::CodexTriggerActor_GetTriggerShape Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MontageTransitionMetaData.AddNewMontage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EComboAttackType                        ComboType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMontageWithDescription&   Montage                                                (Parm, NativeAccessSpecifierPublic)
// int32*                                  Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMontageTransitionMetaData::AddNewMontage(EComboAttackType ComboType, EAttackType AttackType, const struct FMontageWithDescription& Montage, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontageTransitionMetaData", "AddNewMontage");

	Params::MontageTransitionMetaData_AddNewMontage Parms{};

	Parms.ComboType = ComboType;
	Parms.AttackType = AttackType;
	Parms.Montage = std::move(Montage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;

	return Parms.ReturnValue;
}


// Function Smuta.MontageTransitionMetaData.ChangeMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EComboAttackType                        ComboType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMontageWithDescription&   NewMontageDescription                                  (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMontageTransitionMetaData::ChangeMontage(EComboAttackType ComboType, EAttackType AttackType, int32 Index_0, const struct FMontageWithDescription& NewMontageDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontageTransitionMetaData", "ChangeMontage");

	Params::MontageTransitionMetaData_ChangeMontage Parms{};

	Parms.ComboType = ComboType;
	Parms.AttackType = AttackType;
	Parms.Index_0 = Index_0;
	Parms.NewMontageDescription = std::move(NewMontageDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MontageTransitionMetaData.DeleteMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EComboAttackType                        ComboType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMontageTransitionMetaData::DeleteMontage(EComboAttackType ComboType, EAttackType AttackType, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontageTransitionMetaData", "DeleteMontage");

	Params::MontageTransitionMetaData_DeleteMontage Parms{};

	Parms.ComboType = ComboType;
	Parms.AttackType = AttackType;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MontageTransitionMetaData.GetNextMontages
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EComboAttackType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNextMontages*                   NextMontages                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMontageTransitionMetaData::GetNextMontages(EComboAttackType Type, struct FNextMontages* NextMontages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontageTransitionMetaData", "GetNextMontages");

	Params::MontageTransitionMetaData_GetNextMontages Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NextMontages != nullptr)
		*NextMontages = std::move(Parms.NextMontages);

	return Parms.ReturnValue;
}


// Function Smuta.CommonBlueprintLibrary.FindFirstMatchedGameplayTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTagContainer&     TagsToMatch                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     TagsToFind                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UCommonBlueprintLibrary::FindFirstMatchedGameplayTag(const struct FGameplayTagContainer& TagsToMatch, const struct FGameplayTagContainer& TagsToFind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonBlueprintLibrary", "FindFirstMatchedGameplayTag");

	Params::CommonBlueprintLibrary_FindFirstMatchedGameplayTag Parms{};

	Parms.TagsToMatch = std::move(TagsToMatch);
	Parms.TagsToFind = std::move(TagsToFind);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CommonBlueprintLibrary.GetActorDirectionSide
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     SelfActor                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     DirectionActor                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDirectionSide                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDirectionSide UCommonBlueprintLibrary::GetActorDirectionSide(const class AActor* SelfActor, const class AActor* DirectionActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonBlueprintLibrary", "GetActorDirectionSide");

	Params::CommonBlueprintLibrary_GetActorDirectionSide Parms{};

	Parms.SelfActor = SelfActor;
	Parms.DirectionActor = DirectionActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CommonBlueprintLibrary.GetDirectionSideAngle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EDirectionSide                    DirectionSide                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommonBlueprintLibrary::GetDirectionSideAngle(const EDirectionSide DirectionSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonBlueprintLibrary", "GetDirectionSideAngle");

	Params::CommonBlueprintLibrary_GetDirectionSideAngle Parms{};

	Parms.DirectionSide = DirectionSide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CommonBlueprintLibrary.GetInputAxisValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APawn*                      Pawn                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Forward                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Right                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonBlueprintLibrary::GetInputAxisValues(const class APawn* Pawn, float* Forward, float* Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonBlueprintLibrary", "GetInputAxisValues");

	Params::CommonBlueprintLibrary_GetInputAxisValues Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Forward != nullptr)
		*Forward = Parms.Forward;

	if (Right != nullptr)
		*Right = Parms.Right;
}


// Function Smuta.CommonBlueprintLibrary.GetLocalPlayerCharacter
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADefaultCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADefaultCharacter* UCommonBlueprintLibrary::GetLocalPlayerCharacter(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonBlueprintLibrary", "GetLocalPlayerCharacter");

	Params::CommonBlueprintLibrary_GetLocalPlayerCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CommonBlueprintLibrary.GetLocalPlayerComponent
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UCommonBlueprintLibrary::GetLocalPlayerComponent(const class UObject* WorldContextObject, TSubclassOf<class UActorComponent> ComponentClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonBlueprintLibrary", "GetLocalPlayerComponent");

	Params::CommonBlueprintLibrary_GetLocalPlayerComponent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ComponentClass = ComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CommonBlueprintLibrary.GetLocalPlayerController
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UCommonBlueprintLibrary::GetLocalPlayerController(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonBlueprintLibrary", "GetLocalPlayerController");

	Params::CommonBlueprintLibrary_GetLocalPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CommonBlueprintLibrary.GetRotatedDirectionTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              OriginDirectionTag                                     (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EDirectionSide                    DirectionSide                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UCommonBlueprintLibrary::GetRotatedDirectionTag(const struct FGameplayTag& OriginDirectionTag, const EDirectionSide DirectionSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonBlueprintLibrary", "GetRotatedDirectionTag");

	Params::CommonBlueprintLibrary_GetRotatedDirectionTag Parms{};

	Parms.OriginDirectionTag = std::move(OriginDirectionTag);
	Parms.DirectionSide = DirectionSide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CommonBlueprintLibrary.GetTurnInputAxisValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APawn*                      Pawn                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  LookUp                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Turn                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonBlueprintLibrary::GetTurnInputAxisValues(const class APawn* Pawn, float* LookUp, float* Turn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonBlueprintLibrary", "GetTurnInputAxisValues");

	Params::CommonBlueprintLibrary_GetTurnInputAxisValues Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LookUp != nullptr)
		*LookUp = Parms.LookUp;

	if (Turn != nullptr)
		*Turn = Parms.Turn;
}


// Function Smuta.CommonBlueprintLibrary.IsBuildVersionNewer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    NewerVersion                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ComparedVersion                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonBlueprintLibrary::IsBuildVersionNewer(const class FString& NewerVersion, const class FString& ComparedVersion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonBlueprintLibrary", "IsBuildVersionNewer");

	Params::CommonBlueprintLibrary_IsBuildVersionNewer Parms{};

	Parms.NewerVersion = std::move(NewerVersion);
	Parms.ComparedVersion = std::move(ComparedVersion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CompareStrings.SGreaterThan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    StringA                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    StringB                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompareStrings::SGreaterThan(const class FString& StringA, const class FString& StringB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompareStrings", "SGreaterThan");

	Params::CompareStrings_SGreaterThan Parms{};

	Parms.StringA = std::move(StringA);
	Parms.StringB = std::move(StringB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CompareStrings.SLessThan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    StringA                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    StringB                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompareStrings::SLessThan(const class FString& StringA, const class FString& StringB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompareStrings", "SLessThan");

	Params::CompareStrings_SLessThan Parms{};

	Parms.StringA = std::move(StringA);
	Parms.StringB = std::move(StringB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CompassItemsManager.RegisterCompassComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCompassItemComponent*            CompassItemComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompassItemsManager::RegisterCompassComponent(class UCompassItemComponent* CompassItemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassItemsManager", "RegisterCompassComponent");

	Params::CompassItemsManager_RegisterCompassComponent Parms{};

	Parms.CompassItemComponent = CompassItemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CompassItemsManager.RegisterOverlappedArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AreaActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompassItemsManager::RegisterOverlappedArea(class AActor* AreaActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassItemsManager", "RegisterOverlappedArea");

	Params::CompassItemsManager_RegisterOverlappedArea Parms{};

	Parms.AreaActor = AreaActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CompassItemsManager.RegisterScreenZoneWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCompassScreenZoneItemWidget>WidgetClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompassItemsManager::RegisterScreenZoneWidget(class AActor* OwnerActor, TSubclassOf<class UCompassScreenZoneItemWidget> WidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassItemsManager", "RegisterScreenZoneWidget");

	Params::CompassItemsManager_RegisterScreenZoneWidget Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.WidgetClass = WidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CompassItemsManager.UnregisterCompassComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCompassItemComponent*            CompassItemComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompassItemsManager::UnregisterCompassComponent(class UCompassItemComponent* CompassItemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassItemsManager", "UnregisterCompassComponent");

	Params::CompassItemsManager_UnregisterCompassComponent Parms{};

	Parms.CompassItemComponent = CompassItemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CompassItemsManager.UnregisterOverlappedArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AreaActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompassItemsManager::UnregisterOverlappedArea(class AActor* AreaActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassItemsManager", "UnregisterOverlappedArea");

	Params::CompassItemsManager_UnregisterOverlappedArea Parms{};

	Parms.AreaActor = AreaActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CompassItemsManager.UnregisterScreenZoneWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCompassScreenZoneItemWidget>WidgetClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompassItemsManager::UnregisterScreenZoneWidget(class AActor* OwnerActor, TSubclassOf<class UCompassScreenZoneItemWidget> WidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassItemsManager", "UnregisterScreenZoneWidget");

	Params::CompassItemsManager_UnregisterScreenZoneWidget Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.WidgetClass = WidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CompassScreenZoneItemWidget.PositionUpdated
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector2D&                 ScreenPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompassScreenZoneItemWidget::PositionUpdated(const struct FVector2D& ScreenPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassScreenZoneItemWidget", "PositionUpdated");

	Params::CompassScreenZoneItemWidget_PositionUpdated Parms{};

	Parms.ScreenPoint = std::move(ScreenPoint);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.CompassScreenZoneItemWidget.UpdateVisibility
// (Final, Native, Protected)

void UCompassScreenZoneItemWidget::UpdateVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassScreenZoneItemWidget", "UpdateVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CompassWidgetBase.GetDescription
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText*                            Description                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UCompassWidgetBase::GetDescription(class FText* Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassWidgetBase", "GetDescription");

	Params::CompassWidgetBase_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Description != nullptr)
		*Description = std::move(Parms.Description);
}


// Function Smuta.CompassWidgetBase.GetHorizontalAdditive
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCompassWidgetBase::GetHorizontalAdditive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassWidgetBase", "GetHorizontalAdditive");

	Params::CompassWidgetBase_GetHorizontalAdditive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CompassWidgetBase.ShouldBeVisible
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompassWidgetBase::ShouldBeVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassWidgetBase", "ShouldBeVisible");

	Params::CompassWidgetBase_ShouldBeVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CompassWidgetBase.GetDistanceToTarget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCompassWidgetBase::GetDistanceToTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassWidgetBase", "GetDistanceToTarget");

	Params::CompassWidgetBase_GetDistanceToTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CompassWidgetBase.GetTargetLocation
// (Native, Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCompassWidgetBase::GetTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassWidgetBase", "GetTargetLocation");

	Params::CompassWidgetBase_GetTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CompassWidgetBase.IsGroupHidden
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompassWidgetBase::IsGroupHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassWidgetBase", "IsGroupHidden");

	Params::CompassWidgetBase_IsGroupHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CompassWidgetBase.IsVisibleInternal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompassWidgetBase::IsVisibleInternal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassWidgetBase", "IsVisibleInternal");

	Params::CompassWidgetBase_IsVisibleInternal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ComponentEffectOwnerInterface.IsContainEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UClass*                     EffectClass                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IComponentEffectOwnerInterface::IsContainEffect(const class UClass* EffectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ComponentEffectOwnerInterface", "IsContainEffect");

	Params::ComponentEffectOwnerInterface_IsContainEffect Parms{};

	Parms.EffectClass = EffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ConcentrationComponent.DisableConcentration
// (Final, Native, Public, BlueprintCallable)

void UConcentrationComponent::DisableConcentration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConcentrationComponent", "DisableConcentration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ConcentrationComponent.EnableConcentration
// (Final, Native, Public, BlueprintCallable)

void UConcentrationComponent::EnableConcentration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConcentrationComponent", "EnableConcentration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ConcentrationComponent.OnOwnerASCTagUpdated
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExists                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConcentrationComponent::OnOwnerASCTagUpdated(const struct FGameplayTag& UpdatedTag, bool bExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConcentrationComponent", "OnOwnerASCTagUpdated");

	Params::ConcentrationComponent_OnOwnerASCTagUpdated Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.bExists = bExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ConcentrationComponent.StartConcentration
// (Final, Native, Public, BlueprintCallable)

void UConcentrationComponent::StartConcentration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConcentrationComponent", "StartConcentration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ConcentrationComponent.StopConcentration
// (Final, Native, Public, BlueprintCallable)

void UConcentrationComponent::StopConcentration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConcentrationComponent", "StopConcentration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ConcentrationComponent.IsConcentrated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConcentrationComponent::IsConcentrated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConcentrationComponent", "IsConcentrated");

	Params::ConcentrationComponent_IsConcentrated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ConcentrationComponent.IsConcentrationEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConcentrationComponent::IsConcentrationEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConcentrationComponent", "IsConcentrationEnabled");

	Params::ConcentrationComponent_IsConcentrationEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ConcentrationComponent.IsFocused
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConcentrationComponent::IsFocused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConcentrationComponent", "IsFocused");

	Params::ConcentrationComponent_IsFocused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaSignificanceManager.GetSmutaSignificanceManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USmutaSignificanceManager*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USmutaSignificanceManager* USmutaSignificanceManager::GetSmutaSignificanceManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmutaSignificanceManager", "GetSmutaSignificanceManager");

	Params::SmutaSignificanceManager_GetSmutaSignificanceManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CooldownsManagerComponent.GetCooldownValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCooldownsManagerComponent::GetCooldownValue(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CooldownsManagerComponent", "GetCooldownValue");

	Params::CooldownsManagerComponent_GetCooldownValue Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CooldownsManagerComponent.UpdateCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCooldownsManagerComponent::UpdateCooldown(const struct FGameplayTag& Tag, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CooldownsManagerComponent", "UpdateCooldown");

	Params::CooldownsManagerComponent_UpdateCooldown Parms{};

	Parms.Tag = std::move(Tag);
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ParentControlSetting.SetParentControl
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bNewParentControlEnabled                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParentControlSetting::SetParentControl(const bool bNewParentControlEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParentControlSetting", "SetParentControl");

	Params::ParentControlSetting_SetParentControl Parms{};

	Parms.bNewParentControlEnabled = bNewParentControlEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ParentControlSetting.GetParentControlEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParentControlSetting::GetParentControlEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParentControlSetting", "GetParentControlEnabled");

	Params::ParentControlSetting_GetParentControlEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CyberiaQuestMarker.DialogueHappend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    happend                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCyberiaQuestMarker::DialogueHappend(bool happend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CyberiaQuestMarker", "DialogueHappend");

	Params::CyberiaQuestMarker_DialogueHappend Parms{};

	Parms.happend = happend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CyberiaQuestMarker.CheckForIndoor
// (Final, Native, Public, BlueprintCallable)

void UCyberiaQuestMarker::CheckForIndoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CyberiaQuestMarker", "CheckForIndoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CyberiaQuestMarker.HandleCutsceneFinished
// (Final, Native, Protected)
// Parameters:
// class ULevelSequence*                   Cutscene                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCyberiaQuestMarker::HandleCutsceneFinished(class ULevelSequence* Cutscene)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CyberiaQuestMarker", "HandleCutsceneFinished");

	Params::CyberiaQuestMarker_HandleCutsceneFinished Parms{};

	Parms.Cutscene = Cutscene;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CyberiaQuestMarker.HandleCutsceneStarted
// (Final, Native, Protected)
// Parameters:
// class ULevelSequence*                   Cutscene                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequencePlayer*             Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCyberiaQuestMarker::HandleCutsceneStarted(class ULevelSequence* Cutscene, class ULevelSequencePlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CyberiaQuestMarker", "HandleCutsceneStarted");

	Params::CyberiaQuestMarker_HandleCutsceneStarted Parms{};

	Parms.Cutscene = Cutscene;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CyberiaQuestMarker.PlayerPawnChanged
// (Final, Native, Protected)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCyberiaQuestMarker::PlayerPawnChanged(class APawn* OldPawn, class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CyberiaQuestMarker", "PlayerPawnChanged");

	Params::CyberiaQuestMarker_PlayerPawnChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CyberiaQuestMarker.PlayerTagChangedResponse
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              ChangedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExists                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCyberiaQuestMarker::PlayerTagChangedResponse(const struct FGameplayTag& ChangedTag, bool bExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CyberiaQuestMarker", "PlayerTagChangedResponse");

	Params::CyberiaQuestMarker_PlayerTagChangedResponse Parms{};

	Parms.ChangedTag = std::move(ChangedTag);
	Parms.bExists = bExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CyberiaQuestMarker.RefreshVisibility
// (Final, Native, Protected)

void UCyberiaQuestMarker::RefreshVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CyberiaQuestMarker", "RefreshVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaTagsSettings.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class USmutaTagsSettings*         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USmutaTagsSettings* USmutaTagsSettings::Get()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmutaTagsSettings", "Get");

	Params::SmutaTagsSettings_Get Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaOnlineSubsystem.OnAchievementQueryFailed
// (Final, Native, Protected)

void USmutaOnlineSubsystem::OnAchievementQueryFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaOnlineSubsystem", "OnAchievementQueryFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaOnlineSubsystem.OnAchievementQuerySuccess
// (Final, Native, Protected)

void USmutaOnlineSubsystem::OnAchievementQuerySuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaOnlineSubsystem", "OnAchievementQuerySuccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaOnlineSubsystem.OnAchievementUnlockedFailed
// (Final, Native, Protected)
// Parameters:
// class FName                             WrittenAchievementName                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WrittenProgress                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   WrittenUserTag                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaOnlineSubsystem::OnAchievementUnlockedFailed(class FName WrittenAchievementName, float WrittenProgress, int32 WrittenUserTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaOnlineSubsystem", "OnAchievementUnlockedFailed");

	Params::SmutaOnlineSubsystem_OnAchievementUnlockedFailed Parms{};

	Parms.WrittenAchievementName = WrittenAchievementName;
	Parms.WrittenProgress = WrittenProgress;
	Parms.WrittenUserTag = WrittenUserTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaOnlineSubsystem.OnAchievementUnlockedSuccess
// (Final, Native, Protected)
// Parameters:
// class FName                             WrittenAchievementName                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WrittenProgress                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   WrittenUserTag                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaOnlineSubsystem::OnAchievementUnlockedSuccess(class FName WrittenAchievementName, float WrittenProgress, int32 WrittenUserTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaOnlineSubsystem", "OnAchievementUnlockedSuccess");

	Params::SmutaOnlineSubsystem_OnAchievementUnlockedSuccess Parms{};

	Parms.WrittenAchievementName = WrittenAchievementName;
	Parms.WrittenProgress = WrittenProgress;
	Parms.WrittenUserTag = WrittenUserTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaOnlineSubsystem.ResetAchievementInternal
// (Final, Native, Protected)
// Parameters:
// class FName                             AchievementName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaOnlineSubsystem::ResetAchievementInternal(class FName AchievementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaOnlineSubsystem", "ResetAchievementInternal");

	Params::SmutaOnlineSubsystem_ResetAchievementInternal Parms{};

	Parms.AchievementName = AchievementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaOnlineSubsystem.ResetAllAchievementsInternal
// (Final, Native, Protected)

void USmutaOnlineSubsystem::ResetAllAchievementsInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaOnlineSubsystem", "ResetAllAchievementsInternal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaOnlineSubsystem.UnlockAchievement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    AchievementName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaOnlineSubsystem::UnlockAchievement(const class FString& AchievementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaOnlineSubsystem", "UnlockAchievement");

	Params::SmutaOnlineSubsystem_UnlockAchievement Parms{};

	Parms.AchievementName = std::move(AchievementName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaOnlineSubsystem.UnlockAchievementInternal
// (Final, Native, Protected)
// Parameters:
// class FName                             AchievementName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaOnlineSubsystem::UnlockAchievementInternal(class FName AchievementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaOnlineSubsystem", "UnlockAchievementInternal");

	Params::SmutaOnlineSubsystem_UnlockAchievementInternal Parms{};

	Parms.AchievementName = AchievementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaOnlineSubsystem.IsAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmutaOnlineSubsystem::IsAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaOnlineSubsystem", "IsAvailable");

	Params::SmutaOnlineSubsystem_IsAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaOnlineSubsystem.IsPreOrder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmutaOnlineSubsystem::IsPreOrder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaOnlineSubsystem", "IsPreOrder");

	Params::SmutaOnlineSubsystem_IsPreOrder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCBaseAnimInstance.OnTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TagExists                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBaseAnimInstance::OnTagChanged(const struct FGameplayTag& Tag, bool TagExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBaseAnimInstance", "OnTagChanged");

	Params::NPCBaseAnimInstance_OnTagChanged Parms{};

	Parms.Tag = std::move(Tag);
	Parms.TagExists = TagExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCBaseAnimInstance.SubscribeToComponentsDelegates
// (Native, Protected, BlueprintCallable)

void UNPCBaseAnimInstance::SubscribeToComponentsDelegates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBaseAnimInstance", "SubscribeToComponentsDelegates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCBaseAnimInstance.IsNeedToUpdateInstance
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCBaseAnimInstance::IsNeedToUpdateInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBaseAnimInstance", "IsNeedToUpdateInstance");

	Params::NPCBaseAnimInstance_IsNeedToUpdateInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCBaseAnimInstance.IsValidInstance
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCBaseAnimInstance::IsValidInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBaseAnimInstance", "IsValidInstance");

	Params::NPCBaseAnimInstance_IsValidInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCSubAnimInstance.CustomUpdateAnimation
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCSubAnimInstance::CustomUpdateAnimation(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCSubAnimInstance", "CustomUpdateAnimation");

	Params::NPCSubAnimInstance_CustomUpdateAnimation Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DebugFunctionLibrary.IsDebugCategoryEnabled
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32&                            CategoryIndex                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDebugFunctionLibrary::IsDebugCategoryEnabled(const int32& CategoryIndex, const class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugFunctionLibrary", "IsDebugCategoryEnabled");

	Params::DebugFunctionLibrary_IsDebugCategoryEnabled Parms{};

	Parms.CategoryIndex = CategoryIndex;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DebugQuestsCheat.DebugQuests
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   EnableFlag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugQuestsCheat::DebugQuests(int32 EnableFlag, int32 Page)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugQuestsCheat", "DebugQuests");

	Params::DebugQuestsCheat_DebugQuests Parms{};

	Parms.EnableFlag = EnableFlag;
	Parms.Page = Page;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DebugQuestsCheat.UpdateDebugData
// (Final, Native, Protected)

void UDebugQuestsCheat::UpdateDebugData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugQuestsCheat", "UpdateDebugData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.EnableDamageDebugMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::EnableDamageDebugMode(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DefaultCharacter", "EnableDamageDebugMode");

	Params::DefaultCharacter_EnableDamageDebugMode Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.BindAbilityInput
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UInputComponent*                  PlayerInputComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::BindAbilityInput(class UInputComponent* PlayerInputComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "BindAbilityInput");

	Params::DefaultCharacter_BindAbilityInput Parms{};

	Parms.PlayerInputComponent = PlayerInputComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.BindMovementInput
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UInputComponent*                  PlayerInputComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ConsumeInput                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::BindMovementInput(class UInputComponent* PlayerInputComponent, bool ConsumeInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "BindMovementInput");

	Params::DefaultCharacter_BindMovementInput Parms{};

	Parms.PlayerInputComponent = PlayerInputComponent;
	Parms.ConsumeInput = ConsumeInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.ChangePassport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPassportAsset*                   NewPassport                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::ChangePassport(class UPassportAsset* NewPassport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "ChangePassport");

	Params::DefaultCharacter_ChangePassport Parms{};

	Parms.NewPassport = NewPassport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.EnablePossibilityToSkipMontageByMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::EnablePossibilityToSkipMontageByMovement(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "EnablePossibilityToSkipMontageByMovement");

	Params::DefaultCharacter_EnablePossibilityToSkipMontageByMovement Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.GetAITraits
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAITraitsBase*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAITraitsBase* ADefaultCharacter::GetAITraits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "GetAITraits");

	Params::DefaultCharacter_GetAITraits Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DefaultCharacter.HandleDamageEvent
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const float&                            DamageAmount                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::HandleDamageEvent(const float& DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "HandleDamageEvent");

	Params::DefaultCharacter_HandleDamageEvent Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.OnGameDifficultyChanged
// (Final, Native, Public)
// Parameters:
// EGameDifficulty                         NewDifficulty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::OnGameDifficultyChanged(EGameDifficulty NewDifficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "OnGameDifficultyChanged");

	Params::DefaultCharacter_OnGameDifficultyChanged Parms{};

	Parms.NewDifficulty = NewDifficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.OnGroundLanded
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADefaultCharacter::OnGroundLanded(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "OnGroundLanded");

	Params::DefaultCharacter_OnGroundLanded Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.PreDie
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ADefaultCharacter::PreDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "PreDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.RecieveOnGameDifficultyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EGameDifficulty                         NewDifficulty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::RecieveOnGameDifficultyChanged(EGameDifficulty NewDifficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "RecieveOnGameDifficultyChanged");

	Params::DefaultCharacter_RecieveOnGameDifficultyChanged Parms{};

	Parms.NewDifficulty = NewDifficulty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.DefaultCharacter.RegisterInCrowdAsAvoided
// (Final, Native, Public, BlueprintCallable)

void ADefaultCharacter::RegisterInCrowdAsAvoided()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "RegisterInCrowdAsAvoided");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.RevertDeadState
// (Final, Native, Protected, BlueprintCallable)

void ADefaultCharacter::RevertDeadState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "RevertDeadState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.SaveDeadState
// (Final, Native, Public, BlueprintCallable)

void ADefaultCharacter::SaveDeadState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "SaveDeadState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.SendMaxHealthEvent
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const float&                            DamageAmount                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::SendMaxHealthEvent(const float& DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "SendMaxHealthEvent");

	Params::DefaultCharacter_SendMaxHealthEvent Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.SetDodgeBonusActivate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Valeu                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::SetDodgeBonusActivate(bool Valeu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "SetDodgeBonusActivate");

	Params::DefaultCharacter_SetDodgeBonusActivate Parms{};

	Parms.Valeu = Valeu;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.SetForcedWorldYawRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             TargetAzimuth                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             RotationBlendTime                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::SetForcedWorldYawRotation(const float TargetAzimuth, const float RotationBlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "SetForcedWorldYawRotation");

	Params::DefaultCharacter_SetForcedWorldYawRotation Parms{};

	Parms.TargetAzimuth = TargetAzimuth;
	Parms.RotationBlendTime = RotationBlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.SetForcedWorldYawRotationAtPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   TargetPoint                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             RotationBlendTime                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::SetForcedWorldYawRotationAtPoint(const struct FVector& TargetPoint, const float RotationBlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "SetForcedWorldYawRotationAtPoint");

	Params::DefaultCharacter_SetForcedWorldYawRotationAtPoint Parms{};

	Parms.TargetPoint = std::move(TargetPoint);
	Parms.RotationBlendTime = RotationBlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.SetSkipOptimization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkip                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::SetSkipOptimization(bool bSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "SetSkipOptimization");

	Params::DefaultCharacter_SetSkipOptimization Parms{};

	Parms.bSkip = bSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.SetSkipSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkipSave                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::SetSkipSave(bool bSkipSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "SetSkipSave");

	Params::DefaultCharacter_SetSkipSave Parms{};

	Parms.bSkipSave = bSkipSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.SetupController
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AController*                      NewController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::SetupController(class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "SetupController");

	Params::DefaultCharacter_SetupController Parms{};

	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.TagChangedResponse
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTagExists                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::TagChangedResponse(const struct FGameplayTag& UpdatedTag, bool bTagExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "TagChangedResponse");

	Params::DefaultCharacter_TagChangedResponse Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.bTagExists = bTagExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.TakeStepForward
// (Final, Native, Protected, BlueprintCallable)

void ADefaultCharacter::TakeStepForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "TakeStepForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.UnBindAbilityAndMovementInput
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UInputComponent*                  PlayerInputComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::UnBindAbilityAndMovementInput(class UInputComponent* PlayerInputComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "UnBindAbilityAndMovementInput");

	Params::DefaultCharacter_UnBindAbilityAndMovementInput Parms{};

	Parms.PlayerInputComponent = PlayerInputComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.UnRegisterInCrowdAsAvoided
// (Final, Native, Public, BlueprintCallable)

void ADefaultCharacter::UnRegisterInCrowdAsAvoided()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "UnRegisterInCrowdAsAvoided");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.UpdateAppearanceMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    InAppearanceMesh                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultCharacter::UpdateAppearanceMesh(class USkeletalMesh* InAppearanceMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "UpdateAppearanceMesh");

	Params::DefaultCharacter_UpdateAppearanceMesh Parms{};

	Parms.InAppearanceMesh = InAppearanceMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DefaultCharacter.GetCurrentActionDataAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UActionDataAsset*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActionDataAsset* ADefaultCharacter::GetCurrentActionDataAsset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "GetCurrentActionDataAsset");

	Params::DefaultCharacter_GetCurrentActionDataAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DefaultCharacter.GetDodgeBonus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADefaultCharacter::GetDodgeBonus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "GetDodgeBonus");

	Params::DefaultCharacter_GetDodgeBonus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DefaultCharacter.GetHeadOrientation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator*                        OutRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ADefaultCharacter::GetHeadOrientation(struct FVector* OutLocation, struct FRotator* OutRotation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "GetHeadOrientation");

	Params::DefaultCharacter_GetHeadOrientation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);
}


// Function Smuta.DefaultCharacter.IsConscious
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADefaultCharacter::IsConscious() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "IsConscious");

	Params::DefaultCharacter_IsConscious Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DefaultCharacter.IsInputEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADefaultCharacter::IsInputEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefaultCharacter", "IsInputEnabled");

	Params::DefaultCharacter_IsInputEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DefenceAbility.GetDefenceZoneCollisions
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UDefenceZoneCollisionComponent*>*ResultDefenceZoneCollisions                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDefenceAbility::GetDefenceZoneCollisions(TArray<class UDefenceZoneCollisionComponent*>* ResultDefenceZoneCollisions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefenceAbility", "GetDefenceZoneCollisions");

	Params::DefenceAbility_GetDefenceZoneCollisions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResultDefenceZoneCollisions != nullptr)
		*ResultDefenceZoneCollisions = std::move(Parms.ResultDefenceZoneCollisions);
}


// Function Smuta.DefenceAbility.OnAttackHitRecieved
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FAttackHitData&            AttackHitData                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDefenceAbility::OnAttackHitRecieved(const struct FAttackHitData& AttackHitData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefenceAbility", "OnAttackHitRecieved");

	Params::DefenceAbility_OnAttackHitRecieved Parms{};

	Parms.AttackHitData = std::move(AttackHitData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.DefenceAbility.SetDefenceZoneCollisionDetectionActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDefenceAbility::SetDefenceZoneCollisionDetectionActive(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefenceAbility", "SetDefenceZoneCollisionDetectionActive");

	Params::DefenceAbility_SetDefenceZoneCollisionDetectionActive Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DetectionSettings.ChangeAttitudeAtIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   IndexA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IndexB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExtendedAttitude                       NewAttitude                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDetectionSettings::ChangeAttitudeAtIndex(int32 IndexA, int32 IndexB, EExtendedAttitude NewAttitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionSettings", "ChangeAttitudeAtIndex");

	Params::DetectionSettings_ChangeAttitudeAtIndex Parms{};

	Parms.IndexA = IndexA;
	Parms.IndexB = IndexB;
	Parms.NewAttitude = NewAttitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DetectionSettings.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UDetectionSettings*         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDetectionSettings* UDetectionSettings::Get()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionSettings", "Get");

	Params::DetectionSettings_Get Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DetectionSettings.GetAttitudeAtIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   IndexA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IndexB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExtendedAttitude                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EExtendedAttitude UDetectionSettings::GetAttitudeAtIndex(int32 IndexA, int32 IndexB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionSettings", "GetAttitudeAtIndex");

	Params::DetectionSettings_GetAttitudeAtIndex Parms{};

	Parms.IndexA = IndexA;
	Parms.IndexB = IndexB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DetectionSettings.GetHearingStimulusRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHearingSenseType                       HearingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutRange                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutMaxRange                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDetectionSettings::GetHearingStimulusRange(const class UObject* WorldContextObject, EHearingSenseType HearingType, float* OutRange, float* OutMaxRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionSettings", "GetHearingStimulusRange");

	Params::DetectionSettings_GetHearingStimulusRange Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.HearingType = HearingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRange != nullptr)
		*OutRange = Parms.OutRange;

	if (OutMaxRange != nullptr)
		*OutMaxRange = Parms.OutMaxRange;
}


// Function Smuta.DetectionSettings.GetHearingStimulusScale
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      StimulusTag                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDetectionSettings::GetHearingStimulusScale(const class FName& StimulusTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionSettings", "GetHearingStimulusScale");

	Params::DetectionSettings_GetHearingStimulusScale Parms{};

	Parms.StimulusTag = StimulusTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DetectionSettings.GetIndividualPhraseCooldown
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDetectionSettings::GetIndividualPhraseCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionSettings", "GetIndividualPhraseCooldown");

	Params::DetectionSettings_GetIndividualPhraseCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DetectionSettings.GetReactionForStimulus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FStimulusDescription&      StimulusDescription                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetectionAIState                       DetectionState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDetectionReaction*              OutReaction                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDetectionSettings::GetReactionForStimulus(const struct FStimulusDescription& StimulusDescription, EDetectionAIState DetectionState, struct FDetectionReaction* OutReaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionSettings", "GetReactionForStimulus");

	Params::DetectionSettings_GetReactionForStimulus Parms{};

	Parms.StimulusDescription = std::move(StimulusDescription);
	Parms.DetectionState = DetectionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutReaction != nullptr)
		*OutReaction = std::move(Parms.OutReaction);

	return Parms.ReturnValue;
}


// Function Smuta.DetectionSettings.GetStimulusPriority
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FStimulusDescription&      StimulusDescription                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDetectionSettings::GetStimulusPriority(const struct FStimulusDescription& StimulusDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionSettings", "GetStimulusPriority");

	Params::DetectionSettings_GetStimulusPriority Parms{};

	Parms.StimulusDescription = std::move(StimulusDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DetectionSettings.HearingTypeToTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EHearingSenseType                       HearingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDetectionSettings::HearingTypeToTag(EHearingSenseType HearingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionSettings", "HearingTypeToTag");

	Params::DetectionSettings_HearingTypeToTag Parms{};

	Parms.HearingType = HearingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DetectionSettings.TagToHearingType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      HearingTag                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHearingSenseType*                      OutHearingType                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDetectionSettings::TagToHearingType(const class FName& HearingTag, EHearingSenseType* OutHearingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionSettings", "TagToHearingType");

	Params::DetectionSettings_TagToHearingType Parms{};

	Parms.HearingTag = HearingTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHearingType != nullptr)
		*OutHearingType = Parms.OutHearingType;

	return Parms.ReturnValue;
}


// Function Smuta.DetectionSettings.SetTurnOffPlayerNoise
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bTurnOff                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDetectionSettings::SetTurnOffPlayerNoise(bool bTurnOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DetectionSettings", "SetTurnOffPlayerNoise");

	Params::DetectionSettings_SetTurnOffPlayerNoise Parms{};

	Parms.bTurnOff = bTurnOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DetectionSettings.IsPlayerNoiseTurnedOff
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDetectionSettings::IsPlayerNoiseTurnedOff() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DetectionSettings", "IsPlayerNoiseTurnedOff");

	Params::DetectionSettings_IsPlayerNoiseTurnedOff Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DetectionStateWidgetComponent.OnDetectionActivated
// (Final, Native, Protected)
// Parameters:
// class UActorComponent*                  DetectionComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDetectionStateWidgetComponent::OnDetectionActivated(class UActorComponent* DetectionComponent, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DetectionStateWidgetComponent", "OnDetectionActivated");

	Params::DetectionStateWidgetComponent_OnDetectionActivated Parms{};

	Parms.DetectionComponent = DetectionComponent;
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DetectionStateWidgetComponent.OnDetectionDeactivated
// (Final, Native, Protected)
// Parameters:
// class UActorComponent*                  DetectionComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDetectionStateWidgetComponent::OnDetectionDeactivated(class UActorComponent* DetectionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DetectionStateWidgetComponent", "OnDetectionDeactivated");

	Params::DetectionStateWidgetComponent_OnDetectionDeactivated Parms{};

	Parms.DetectionComponent = DetectionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DetectionStateWidgetComponent.OnDetectionScaleChanged
// (Final, Native, Protected)
// Parameters:
// float                                   OldPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDetectionStateWidgetComponent::OnDetectionScaleChanged(float OldPercent, float NewPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DetectionStateWidgetComponent", "OnDetectionScaleChanged");

	Params::DetectionStateWidgetComponent_OnDetectionScaleChanged Parms{};

	Parms.OldPercent = OldPercent;
	Parms.NewPercent = NewPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DetectionStateWidgetComponent.OnOwnerTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exists                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDetectionStateWidgetComponent::OnOwnerTagChanged(const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DetectionStateWidgetComponent", "OnOwnerTagChanged");

	Params::DetectionStateWidgetComponent_OnOwnerTagChanged Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DialogueStatusViewerComponent.OnDialogueStatusChanged
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDialogueActive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueStatusViewerComponent::OnDialogueStatusChanged(class ACharacter* Owner, bool bIsDialogueActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueStatusViewerComponent", "OnDialogueStatusChanged");

	Params::DialogueStatusViewerComponent_OnDialogueStatusChanged Parms{};

	Parms.Owner = Owner;
	Parms.bIsDialogueActive = bIsDialogueActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DialogueStatusViewerComponent.OnOwnerRootBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDialogueStatusViewerComponent::OnOwnerRootBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueStatusViewerComponent", "OnOwnerRootBeginOverlap");

	Params::DialogueStatusViewerComponent_OnOwnerRootBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DialogueStatusViewerComponent.OnOwnerRootEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueStatusViewerComponent::OnOwnerRootEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueStatusViewerComponent", "OnOwnerRootEndOverlap");

	Params::DialogueStatusViewerComponent_OnOwnerRootEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DialogueStatusViewerComponent.OnOwnerTagChanged
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExists                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueStatusViewerComponent::OnOwnerTagChanged(const struct FGameplayTag& UpdatedTag, bool bExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueStatusViewerComponent", "OnOwnerTagChanged");

	Params::DialogueStatusViewerComponent_OnOwnerTagChanged Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.bExists = bExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DialogueStatusInterface.InitializeWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWidgetComponent*                 ParentWidgetComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDialogueStatusInterface::InitializeWidget(class UWidgetComponent* ParentWidgetComponent, class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DialogueStatusInterface", "InitializeWidget");

	Params::DialogueStatusInterface_InitializeWidget Parms{};

	Parms.ParentWidgetComponent = ParentWidgetComponent;
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DialogueStatusWidgetComponent.ChangeDialogueStatus
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsDialogueActive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueStatusWidgetComponent::ChangeDialogueStatus(bool bIsDialogueActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueStatusWidgetComponent", "ChangeDialogueStatus");

	Params::DialogueStatusWidgetComponent_ChangeDialogueStatus Parms{};

	Parms.bIsDialogueActive = bIsDialogueActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DialogueSubtitlesActor.AttachSubtitleToActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADialogueSubtitlesActor::AttachSubtitleToActor(class AActor* Parent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueSubtitlesActor", "AttachSubtitleToActor");

	Params::DialogueSubtitlesActor_AttachSubtitleToActor Parms{};

	Parms.Parent = Parent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.DialogueSubtitlesActor.ChangeVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bNewVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADialogueSubtitlesActor::ChangeVisibility(bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueSubtitlesActor", "ChangeVisibility");

	Params::DialogueSubtitlesActor_ChangeVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.DialogueSubtitlesActor.UpdateSubtitle
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      NewSubtitleText                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADialogueSubtitlesActor::UpdateSubtitle(const class FText& NewSubtitleText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueSubtitlesActor", "UpdateSubtitle");

	Params::DialogueSubtitlesActor_UpdateSubtitle Parms{};

	Parms.NewSubtitleText = std::move(NewSubtitleText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.PerceptionNoiseSpawner.NoiseTick
// (Final, Native, Public)

void APerceptionNoiseSpawner::NoiseTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerceptionNoiseSpawner", "NoiseTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DialogueSystemHelper.AsyncLoadLipsyncAndSound
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<TSoftObjectPtr<class UAnimSequenceBase>>&Anim                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class USoundBase>        Sound                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADialogueSystemHelper::AsyncLoadLipsyncAndSound(const TArray<TSoftObjectPtr<class UAnimSequenceBase>>& Anim, TSoftObjectPtr<class USoundBase> Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueSystemHelper", "AsyncLoadLipsyncAndSound");

	Params::DialogueSystemHelper_AsyncLoadLipsyncAndSound Parms{};

	Parms.Anim = std::move(Anim);
	Parms.Sound = Sound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DialogueSystemHelper.ChangeHideSubtitlesDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADialogueSystemHelper::ChangeHideSubtitlesDistance(float NewDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueSystemHelper", "ChangeHideSubtitlesDistance");

	Params::DialogueSystemHelper_ChangeHideSubtitlesDistance Parms{};

	Parms.NewDistance = NewDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DialogueSystemHelper.HandleLipsyncLoaded
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<class UAnimSequenceBase*>& LipsyncAnim                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADialogueSystemHelper::HandleLipsyncLoaded(const TArray<class UAnimSequenceBase*>& LipsyncAnim, class USoundBase* Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueSystemHelper", "HandleLipsyncLoaded");

	Params::DialogueSystemHelper_HandleLipsyncLoaded Parms{};

	Parms.LipsyncAnim = std::move(LipsyncAnim);
	Parms.Sound = Sound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.DialogueSystemHelper.NativeHandleLipsyncLoaded
// (Final, Native, Protected)
// Parameters:
// const TArray<struct FSoftObjectPath>&   LoadedObjects                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ADialogueSystemHelper::NativeHandleLipsyncLoaded(const TArray<struct FSoftObjectPath>& LoadedObjects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueSystemHelper", "NativeHandleLipsyncLoaded");

	Params::DialogueSystemHelper_NativeHandleLipsyncLoaded Parms{};

	Parms.LoadedObjects = std::move(LoadedObjects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.DialogueSystemHelper.SpawnSubtitlesActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADialogueSubtitlesActor*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADialogueSubtitlesActor* ADialogueSystemHelper::SpawnSubtitlesActor(class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueSystemHelper", "SpawnSubtitlesActor");

	Params::DialogueSystemHelper_SpawnSubtitlesActor Parms{};

	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.DialogueSystemHelper.UpdateSubtitlesActor
// (Final, Native, Public, BlueprintCallable)

void ADialogueSystemHelper::UpdateSubtitlesActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueSystemHelper", "UpdateSubtitlesActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SaveMigrationHandler.ApplyObjectToSaveData
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>&                          SaveData                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTemporaryObject                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveMigrationHandler::ApplyObjectToSaveData(class UObject* Object, TArray<uint8>& SaveData, bool bTemporaryObject) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveMigrationHandler", "ApplyObjectToSaveData");

	Params::SaveMigrationHandler_ApplyObjectToSaveData Parms{};

	Parms.Object = Object;
	Parms.SaveData = std::move(SaveData);
	Parms.bTemporaryObject = bTemporaryObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	SaveData = std::move(Parms.SaveData);
}


// Function Smuta.SaveMigrationHandler.BP_OnObjectPostLoaded
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          LoadedObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveMigrationHandler::BP_OnObjectPostLoaded(class UObject* WorldContextObject, class UObject* LoadedObject) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveMigrationHandler", "BP_OnObjectPostLoaded");

	Params::SaveMigrationHandler_BP_OnObjectPostLoaded Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LoadedObject = LoadedObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.SaveMigrationHandler.BP_OnObjectPreLoaded
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>&                          SaveData                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                          PreLoadedObject                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveMigrationHandler::BP_OnObjectPreLoaded(class UObject* WorldContextObject, TArray<uint8>& SaveData, class UObject* PreLoadedObject) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveMigrationHandler", "BP_OnObjectPreLoaded");

	Params::SaveMigrationHandler_BP_OnObjectPreLoaded Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SaveData = std::move(SaveData);
	Parms.PreLoadedObject = PreLoadedObject;

	UObject::ProcessEvent(Func, &Parms);

	SaveData = std::move(Parms.SaveData);
}


// Function Smuta.SaveMigrationHandler.CreateTemporaryObject
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              TemporaryObjectClass                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<uint8>&                    SaveData                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* USaveMigrationHandler::CreateTemporaryObject(class UObject* WorldContextObject, TSubclassOf<class UObject> TemporaryObjectClass, const TArray<uint8>& SaveData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveMigrationHandler", "CreateTemporaryObject");

	Params::SaveMigrationHandler_CreateTemporaryObject Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TemporaryObjectClass = TemporaryObjectClass;
	Parms.SaveData = std::move(SaveData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SaveMigrationHandler.FailLoadProcess
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      FailReason                                             (ConstParm, Parm, NativeAccessSpecifierPublic)

void USaveMigrationHandler::FailLoadProcess(class UObject* WorldContextObject, const class FText& FailReason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveMigrationHandler", "FailLoadProcess");

	Params::SaveMigrationHandler_FailLoadProcess Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FailReason = std::move(FailReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EffectAnimInstance.InitializeAnimation
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayEffectSpec&       ForSpec                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FActiveGameplayEffectHandle&ForHandle                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEffectAnimInstance::InitializeAnimation(const struct FGameplayEffectSpec& ForSpec, const struct FActiveGameplayEffectHandle& ForHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAnimInstance", "InitializeAnimation");

	Params::EffectAnimInstance_InitializeAnimation Parms{};

	Parms.ForSpec = std::move(ForSpec);
	Parms.ForHandle = std::move(ForHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EffectAnimInstance.GetEffectCauserGameplayTags
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer*           TagContainer                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEffectAnimInstance::GetEffectCauserGameplayTags(struct FGameplayTagContainer* TagContainer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAnimInstance", "GetEffectCauserGameplayTags");

	Params::EffectAnimInstance_GetEffectCauserGameplayTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TagContainer != nullptr)
		*TagContainer = std::move(Parms.TagContainer);

	return Parms.ReturnValue;
}


// Function Smuta.EMSExtendedObject.OnExitSmutaGame
// (Final, Native, Protected)

void UEMSExtendedObject::OnExitSmutaGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EMSExtendedObject", "OnExitSmutaGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EMSExtendedObject.OnStartNewSmutaGame
// (Final, Native, Protected)

void UEMSExtendedObject::OnStartNewSmutaGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EMSExtendedObject", "OnStartNewSmutaGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.AgroToTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyAggroController::AgroToTarget(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "AgroToTarget");

	Params::EnemyAggroController_AgroToTarget Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.CalmDown
// (Final, Native, Public, BlueprintCallable)

void UEnemyAggroController::CalmDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "CalmDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.ChangeCanAgro
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyAggroController::ChangeCanAgro(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "ChangeCanAgro");

	Params::EnemyAggroController_ChangeCanAgro Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.GetCurrentAgroTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UEnemyAggroController::GetCurrentAgroTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "GetCurrentAgroTarget");

	Params::EnemyAggroController_GetCurrentAgroTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyAggroController.GetCurrentScaryOfTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class AActor* UEnemyAggroController::GetCurrentScaryOfTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "GetCurrentScaryOfTarget");

	Params::EnemyAggroController_GetCurrentScaryOfTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyAggroController.GetCustomAttitude
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamAttitude UEnemyAggroController::GetCustomAttitude(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "GetCustomAttitude");

	Params::EnemyAggroController_GetCustomAttitude Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyAggroController.GetLastAgroTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UEnemyAggroController::GetLastAgroTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "GetLastAgroTargetLocation");

	Params::EnemyAggroController_GetLastAgroTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyAggroController.NotifyActorForBattle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEnemyAggroController*            InstigatorAgroController                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyAggroController::NotifyActorForBattle(class ACharacter* Instigator, class UEnemyAggroController* InstigatorAgroController, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "NotifyActorForBattle");

	Params::EnemyAggroController_NotifyActorForBattle Parms{};

	Parms.Instigator = Instigator;
	Parms.InstigatorAgroController = InstigatorAgroController;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.OnAggroMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyAggroController::OnAggroMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "OnAggroMontageEnded");

	Params::EnemyAggroController_OnAggroMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.OnCalmDownTimerEnded
// (Final, Native, Private)

void UEnemyAggroController::OnCalmDownTimerEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "OnCalmDownTimerEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.OnCleanupLevel
// (Final, Native, Protected)

void UEnemyAggroController::OnCleanupLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "OnCleanupLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.OnEffectApplied
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectSpec&       GameplayEffectSpec                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FActiveGameplayEffectHandle&ActiveGameplayEffectHandle                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyAggroController::OnEffectApplied(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayEffectSpec& GameplayEffectSpec, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "OnEffectApplied");

	Params::EnemyAggroController_OnEffectApplied Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.GameplayEffectSpec = std::move(GameplayEffectSpec);
	Parms.ActiveGameplayEffectHandle = std::move(ActiveGameplayEffectHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.OnOwnerDestroyed
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyAggroController::OnOwnerDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "OnOwnerDestroyed");

	Params::EnemyAggroController_OnOwnerDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.OnTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExists                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyAggroController::OnTagChanged(const struct FGameplayTag& UpdatedTag, bool bExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "OnTagChanged");

	Params::EnemyAggroController_OnTagChanged Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.bExists = bExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.PlayAgroMontage
// (Final, Native, Protected)
// Parameters:
// class UBaseEquipmentSet*                Slot                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyAggroController::PlayAgroMontage(class UBaseEquipmentSet* Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "PlayAgroMontage");

	Params::EnemyAggroController_PlayAgroMontage Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.ScaryOf
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class ADefaultCharacter*          Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyAggroController::ScaryOf(const class ADefaultCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "ScaryOf");

	Params::EnemyAggroController_ScaryOf Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyAggroController.TryAgroToTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyAggroController::TryAgroToTarget(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAggroController", "TryAgroToTarget");

	Params::EnemyAggroController_TryAgroToTarget Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyDetectionComponent.AddPlayerAsHostile
// (Final, Native, Protected)

void UEnemyDetectionComponent::AddPlayerAsHostile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "AddPlayerAsHostile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionComponent.CallForHelp
// (Final, Native, Public, BlueprintCallable)

void UEnemyDetectionComponent::CallForHelp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "CallForHelp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionComponent.ChangeState
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDetectionAIState                       NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyDetectionComponent::ChangeState(EDetectionAIState NewState, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "ChangeState");

	Params::EnemyDetectionComponent_ChangeState Parms{};

	Parms.NewState = NewState;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionComponent.CheckPhraseCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyDetectionComponent::CheckPhraseCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "CheckPhraseCooldown");

	Params::EnemyDetectionComponent_CheckPhraseCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyDetectionComponent.GetCurrentDetectionTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADefaultCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADefaultCharacter* UEnemyDetectionComponent::GetCurrentDetectionTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "GetCurrentDetectionTarget");

	Params::EnemyDetectionComponent_GetCurrentDetectionTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyDetectionComponent.GetDetectionScalePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEnemyDetectionComponent::GetDetectionScalePercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "GetDetectionScalePercent");

	Params::EnemyDetectionComponent_GetDetectionScalePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyDetectionComponent.GetHelpRequesterComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnemyDetectionComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEnemyDetectionComponent* UEnemyDetectionComponent::GetHelpRequesterComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "GetHelpRequesterComponent");

	Params::EnemyDetectionComponent_GetHelpRequesterComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyDetectionComponent.GetHelpRequesterStimulusType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EStimulusType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStimulusType UEnemyDetectionComponent::GetHelpRequesterStimulusType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "GetHelpRequesterStimulusType");

	Params::EnemyDetectionComponent_GetHelpRequesterStimulusType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyDetectionComponent.IsStimulusExactEqualLast
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FStimulusDescription&      StimulusToCheck                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyDetectionComponent::IsStimulusExactEqualLast(const struct FStimulusDescription& StimulusToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "IsStimulusExactEqualLast");

	Params::EnemyDetectionComponent_IsStimulusExactEqualLast Parms{};

	Parms.StimulusToCheck = std::move(StimulusToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyDetectionComponent.OnDetectionScaleChanged
// (Final, Native, Protected)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyDetectionComponent::OnDetectionScaleChanged(float OldValue, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "OnDetectionScaleChanged");

	Params::EnemyDetectionComponent_OnDetectionScaleChanged Parms{};

	Parms.OldValue = OldValue;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionComponent.OnOwnerReceiveHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UEnemyDetectionComponent::OnOwnerReceiveHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "OnOwnerReceiveHit");

	Params::EnemyDetectionComponent_OnOwnerReceiveHit Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionComponent.OnOwnerTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exists                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyDetectionComponent::OnOwnerTagChanged(const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "OnOwnerTagChanged");

	Params::EnemyDetectionComponent_OnOwnerTagChanged Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionComponent.OnPerceptionForgottenHandle
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyDetectionComponent::OnPerceptionForgottenHandle(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "OnPerceptionForgottenHandle");

	Params::EnemyDetectionComponent_OnPerceptionForgottenHandle Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionComponent.OnPerceptionUpdatedHandle
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAIStimulus&               Stimulus                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UEnemyDetectionComponent::OnPerceptionUpdatedHandle(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "OnPerceptionUpdatedHandle");

	Params::EnemyDetectionComponent_OnPerceptionUpdatedHandle Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionComponent.OnSixSenseDetectionScaleChanged
// (Final, Native, Protected)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyDetectionComponent::OnSixSenseDetectionScaleChanged(float OldValue, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "OnSixSenseDetectionScaleChanged");

	Params::EnemyDetectionComponent_OnSixSenseDetectionScaleChanged Parms{};

	Parms.OldValue = OldValue;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionComponent.SetPhraseCooldown
// (Final, Native, Public, BlueprintCallable)

void UEnemyDetectionComponent::SetPhraseCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "SetPhraseCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionComponent.StartFullRestoreScale
// (Final, Native, Protected, BlueprintCallable)

void UEnemyDetectionComponent::StartFullRestoreScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "StartFullRestoreScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionComponent.GetCurrentState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDetectionAIState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDetectionAIState UEnemyDetectionComponent::GetCurrentState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionComponent", "GetCurrentState");

	Params::EnemyDetectionComponent_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyDetectionSubsystem.CanCharacterRequestCallForHelp
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADefaultCharacter*                HelpRequestCharacter                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyDetectionSubsystem::CanCharacterRequestCallForHelp(class ADefaultCharacter* HelpRequestCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionSubsystem", "CanCharacterRequestCallForHelp");

	Params::EnemyDetectionSubsystem_CanCharacterRequestCallForHelp Parms{};

	Parms.HelpRequestCharacter = HelpRequestCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyDetectionSubsystem.CouldSpawnDetectionSound
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemyDetectionSubsystem::CouldSpawnDetectionSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionSubsystem", "CouldSpawnDetectionSound");

	Params::EnemyDetectionSubsystem_CouldSpawnDetectionSound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EnemyDetectionSubsystem.GetAffectedNPCByStoneAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   StoneLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADefaultCharacter*>*       OutCharacters                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEnemyDetectionSubsystem::GetAffectedNPCByStoneAtLocation(const struct FVector& StoneLocation, TArray<class ADefaultCharacter*>* OutCharacters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionSubsystem", "GetAffectedNPCByStoneAtLocation");

	Params::EnemyDetectionSubsystem_GetAffectedNPCByStoneAtLocation Parms{};

	Parms.StoneLocation = std::move(StoneLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCharacters != nullptr)
		*OutCharacters = std::move(Parms.OutCharacters);
}


// Function Smuta.EnemyDetectionSubsystem.HandleComponentStateChanged
// (Final, Native, Protected)
// Parameters:
// class UEnemyDetectionComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetectionAIState                       NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyDetectionSubsystem::HandleComponentStateChanged(class UEnemyDetectionComponent* Component, EDetectionAIState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionSubsystem", "HandleComponentStateChanged");

	Params::EnemyDetectionSubsystem_HandleComponentStateChanged Parms{};

	Parms.Component = Component;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionSubsystem.ManageCallForHelp
// (Final, Native, Protected)

void UEnemyDetectionSubsystem::ManageCallForHelp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionSubsystem", "ManageCallForHelp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionSubsystem.ManageStonesPerception
// (Final, Native, Protected)

void UEnemyDetectionSubsystem::ManageStonesPerception()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionSubsystem", "ManageStonesPerception");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EnemyDetectionSubsystem.OnDetectionSoundSpawned
// (Final, Native, Protected, BlueprintCallable)

void UEnemyDetectionSubsystem::OnDetectionSoundSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyDetectionSubsystem", "OnDetectionSoundSpawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EquipmentData.GetAdditionalEquipmentData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UAdditionalEquipmentData>DataTypeClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAdditionalEquipmentData*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAdditionalEquipmentData* UEquipmentData::GetAdditionalEquipmentData(TSubclassOf<class UAdditionalEquipmentData> DataTypeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentData", "GetAdditionalEquipmentData");

	Params::EquipmentData_GetAdditionalEquipmentData Parms{};

	Parms.DataTypeClass = DataTypeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EquipmentSmartObjectBehavior.GrantEquipment
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentSmartObjectBehavior::GrantEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSmartObjectBehavior", "GrantEquipment");

	Params::EquipmentSmartObjectBehavior_GrantEquipment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EquipmentSmartObjectBehavior.RemoveEquipment
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentSmartObjectBehavior::RemoveEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSmartObjectBehavior", "RemoveEquipment");

	Params::EquipmentSmartObjectBehavior_RemoveEquipment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.EquipmentSmartObjectBehavior.SetBehaviorProps
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSubclassOf<class UNPCEquipmentSetInfo>EquipmentClass                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentSmartObjectBehavior::SetBehaviorProps(const struct FGameplayTag& Tag, const TSubclassOf<class UNPCEquipmentSetInfo> EquipmentClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSmartObjectBehavior", "SetBehaviorProps");

	Params::EquipmentSmartObjectBehavior_SetBehaviorProps Parms{};

	Parms.Tag = std::move(Tag);
	Parms.EquipmentClass = EquipmentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EvidenceBase.ActivateEvidence
// (Native, Public, BlueprintCallable)

void AEvidenceBase::ActivateEvidence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceBase", "ActivateEvidence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EvidenceBase.CallbackWarpAction
// (Native, Protected)
// Parameters:
// class FName                             WarpTargetName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEvidenceBase::CallbackWarpAction(class FName WarpTargetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceBase", "CallbackWarpAction");

	Params::EvidenceBase_CallbackWarpAction Parms{};

	Parms.WarpTargetName = WarpTargetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EvidenceBase.ChangeEvidenceState
// (Native, Protected)
// Parameters:
// EEvidenceState                          NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEvidenceBase::ChangeEvidenceState(EEvidenceState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceBase", "ChangeEvidenceState");

	Params::EvidenceBase_ChangeEvidenceState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EvidenceBase.DeactivateEvidence
// (Native, Public, BlueprintCallable)

void AEvidenceBase::DeactivateEvidence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceBase", "DeactivateEvidence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EvidenceBase.OnActivationMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEvidenceBase::OnActivationMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceBase", "OnActivationMontageEnded");

	Params::EvidenceBase_OnActivationMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EvidenceBase.StartEvidence
// (Native, Public, BlueprintCallable)

void AEvidenceBase::StartEvidence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceBase", "StartEvidence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.EvidenceBase.WarpAction
// (Native, Public, BlueprintCallable)
// Parameters:
// EEvidenceAnimationMode                  Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WarpTargetName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeToRemoveTarget                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEvidenceBase::WarpAction(EEvidenceAnimationMode Mode, class FName WarpTargetName, float TimeToRemoveTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceBase", "WarpAction");

	Params::EvidenceBase_WarpAction Parms{};

	Parms.Mode = Mode;
	Parms.WarpTargetName = WarpTargetName;
	Parms.TimeToRemoveTarget = TimeToRemoveTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SaveLoadSubsystem.FailLoadProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      FailReason                                             (ConstParm, Parm, NativeAccessSpecifierPublic)

void USaveLoadSubsystem::FailLoadProcess(const class FText& FailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "FailLoadProcess");

	Params::SaveLoadSubsystem_FailLoadProcess Parms{};

	Parms.FailReason = std::move(FailReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SaveLoadSubsystem.GetFailReasonDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USaveLoadSubsystem::GetFailReasonDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "GetFailReasonDescription");

	Params::SaveLoadSubsystem_GetFailReasonDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SaveLoadSubsystem.ImportSaveThumbnail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    SaveGameName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* USaveLoadSubsystem::ImportSaveThumbnail(const class FString& SaveGameName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "ImportSaveThumbnail");

	Params::SaveLoadSubsystem_ImportSaveThumbnail Parms{};

	Parms.SaveGameName = std::move(SaveGameName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SaveLoadSubsystem.LoadGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveLoadSubsystem::LoadGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "LoadGame");

	Params::SaveLoadSubsystem_LoadGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SaveLoadSubsystem.LoadLastSaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveLoadSubsystem::LoadLastSaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "LoadLastSaveGame");

	Params::SaveLoadSubsystem_LoadLastSaveGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SaveLoadSubsystem.MakeAutoSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    OptionalOverrideName                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveLoadSubsystem::MakeAutoSave(const class FString& OptionalOverrideName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "MakeAutoSave");

	Params::SaveLoadSubsystem_MakeAutoSave Parms{};

	Parms.OptionalOverrideName = std::move(OptionalOverrideName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SaveLoadSubsystem.OnLoadFailed
// (Final, Native, Protected)

void USaveLoadSubsystem::OnLoadFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "OnLoadFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SaveLoadSubsystem.OnLoadSuccess
// (Final, Native, Protected)

void USaveLoadSubsystem::OnLoadSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "OnLoadSuccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SaveLoadSubsystem.OnObjectPostLoaded
// (Final, Native, Protected)
// Parameters:
// class UObject*                          PostLoadedObject                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveLoadSubsystem::OnObjectPostLoaded(class UObject* PostLoadedObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "OnObjectPostLoaded");

	Params::SaveLoadSubsystem_OnObjectPostLoaded Parms{};

	Parms.PostLoadedObject = PostLoadedObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SaveLoadSubsystem.OnObjectPreLoaded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<uint8>*                          SaveData                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UObject*                          PreLoadedObject                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveLoadSubsystem::OnObjectPreLoaded(TArray<uint8>* SaveData, class UObject* PreLoadedObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "OnObjectPreLoaded");

	Params::SaveLoadSubsystem_OnObjectPreLoaded Parms{};

	Parms.PreLoadedObject = PreLoadedObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SaveData != nullptr)
		*SaveData = std::move(Parms.SaveData);
}


// Function Smuta.SaveLoadSubsystem.OnSaveCompleted
// (Final, Native, Protected)

void USaveLoadSubsystem::OnSaveCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "OnSaveCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SaveLoadSubsystem.OnSaveGameNameCreated
// (Final, Native, Protected)
// Parameters:
// const class FString&                    SaveGameName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsAutosave                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveLoadSubsystem::OnSaveGameNameCreated(const class FString& SaveGameName, const bool bIsAutosave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "OnSaveGameNameCreated");

	Params::SaveLoadSubsystem_OnSaveGameNameCreated Parms{};

	Parms.SaveGameName = std::move(SaveGameName);
	Parms.bIsAutosave = bIsAutosave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SaveLoadSubsystem.OnSubSystemsInited
// (Final, Native, Protected)

void USaveLoadSubsystem::OnSubSystemsInited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "OnSubSystemsInited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SaveLoadSubsystem.SaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    OptionalOverrideName                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveLoadSubsystem::SaveGame(const class FString& OptionalOverrideName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "SaveGame");

	Params::SaveLoadSubsystem_SaveGame Parms{};

	Parms.OptionalOverrideName = std::move(OptionalOverrideName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SaveLoadSubsystem.SetActorSkipSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bSkipSave                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveLoadSubsystem::SetActorSkipSave(class AActor* InActor, const bool bSkipSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "SetActorSkipSave");

	Params::SaveLoadSubsystem_SetActorSkipSave Parms{};

	Parms.InActor = InActor;
	Parms.bSkipSave = bSkipSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SaveLoadSubsystem.CanSaveGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveLoadSubsystem::CanSaveGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "CanSaveGame");

	Params::SaveLoadSubsystem_CanSaveGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SaveLoadSubsystem.GetCurrentGameSaveName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USaveLoadSubsystem::GetCurrentGameSaveName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "GetCurrentGameSaveName");

	Params::SaveLoadSubsystem_GetCurrentGameSaveName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SaveLoadSubsystem.IsSaveLoadInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveLoadSubsystem::IsSaveLoadInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadSubsystem", "IsSaveLoadInProgress");

	Params::SaveLoadSubsystem_IsSaveLoadInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaBattleDirector.HasEnemyWithRangeWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmutaBattleDirector::HasEnemyWithRangeWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBattleDirector", "HasEnemyWithRangeWeapon");

	Params::SmutaBattleDirector_HasEnemyWithRangeWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaBattleDirector.OnAttackFinished
// (Final, Native, Protected)
// Parameters:
// const class UBaseAbilitiesComponent*    ASC                                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaBattleDirector::OnAttackFinished(const class UBaseAbilitiesComponent* ASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBattleDirector", "OnAttackFinished");

	Params::SmutaBattleDirector_OnAttackFinished Parms{};

	Parms.ASC = ASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaBattleDirector.OnAttackStarted
// (Final, Native, Protected)
// Parameters:
// const class UBaseAbilitiesComponent*    ASC                                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaBattleDirector::OnAttackStarted(const class UBaseAbilitiesComponent* ASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBattleDirector", "OnAttackStarted");

	Params::SmutaBattleDirector_OnAttackStarted Parms{};

	Parms.ASC = ASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaBattleDirector.OnNewDominantSelected
// (Final, Native, Protected)
// Parameters:
// const class UZoneFightAiComponent*      NewDominant                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaBattleDirector::OnNewDominantSelected(const class UZoneFightAiComponent* NewDominant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBattleDirector", "OnNewDominantSelected");

	Params::SmutaBattleDirector_OnNewDominantSelected Parms{};

	Parms.NewDominant = NewDominant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaBattleDirector.GetEnemyWithMeleeWeaponCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaBattleDirector::GetEnemyWithMeleeWeaponCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBattleDirector", "GetEnemyWithMeleeWeaponCount");

	Params::SmutaBattleDirector_GetEnemyWithMeleeWeaponCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaBattleDirector.GetEnemyWithRangeWeaponCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaBattleDirector::GetEnemyWithRangeWeaponCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBattleDirector", "GetEnemyWithRangeWeaponCount");

	Params::SmutaBattleDirector_GetEnemyWithRangeWeaponCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaBattleDirector.HasAnyAvailableTicket
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmutaBattleDirector::HasAnyAvailableTicket() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBattleDirector", "HasAnyAvailableTicket");

	Params::SmutaBattleDirector_HasAnyAvailableTicket Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaBattleDirector.HasAvailableTicket
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bForRange                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmutaBattleDirector::HasAvailableTicket(bool bForRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBattleDirector", "HasAvailableTicket");

	Params::SmutaBattleDirector_HasAvailableTicket Parms{};

	Parms.bForRange = bForRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FirstPersonAnimInstance.GetCameraDeltaYaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFirstPersonAnimInstance::GetCameraDeltaYaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FirstPersonAnimInstance", "GetCameraDeltaYaw");

	Params::FirstPersonAnimInstance_GetCameraDeltaYaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FirstPersonAnimInstance.GetDesiredMovementYaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFirstPersonAnimInstance::GetDesiredMovementYaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FirstPersonAnimInstance", "GetDesiredMovementYaw");

	Params::FirstPersonAnimInstance_GetDesiredMovementYaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FirstPersonAnimInstance.GetDesiredMovementYawLocal
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFirstPersonAnimInstance::GetDesiredMovementYawLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FirstPersonAnimInstance", "GetDesiredMovementYawLocal");

	Params::FirstPersonAnimInstance_GetDesiredMovementYawLocal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FirstPersonAnimInstance.GetInputAxisFixedValues
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Forward                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Right                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFirstPersonAnimInstance::GetInputAxisFixedValues(float* Forward, float* Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FirstPersonAnimInstance", "GetInputAxisFixedValues");

	Params::FirstPersonAnimInstance_GetInputAxisFixedValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Forward != nullptr)
		*Forward = Parms.Forward;

	if (Right != nullptr)
		*Right = Parms.Right;
}


// Function Smuta.FirstPersonAnimInstance.GetInputAxisValues
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Forward                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Right                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFirstPersonAnimInstance::GetInputAxisValues(float* Forward, float* Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FirstPersonAnimInstance", "GetInputAxisValues");

	Params::FirstPersonAnimInstance_GetInputAxisValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Forward != nullptr)
		*Forward = Parms.Forward;

	if (Right != nullptr)
		*Right = Parms.Right;
}


// Function Smuta.FirstPersonAnimInstance.GetSlopeAngles
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  Forward                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  Right                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFirstPersonAnimInstance::GetSlopeAngles(float* Forward, float* Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FirstPersonAnimInstance", "GetSlopeAngles");

	Params::FirstPersonAnimInstance_GetSlopeAngles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Forward != nullptr)
		*Forward = Parms.Forward;

	if (Right != nullptr)
		*Right = Parms.Right;
}


// Function Smuta.FirstPersonAnimInstance.GetCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADefaultCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADefaultCharacter* UFirstPersonAnimInstance::GetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FirstPersonAnimInstance", "GetCharacter");

	Params::FirstPersonAnimInstance_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FirstPersonAnimInstance.GetMovementInput
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UFirstPersonAnimInstance::GetMovementInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FirstPersonAnimInstance", "GetMovementInput");

	Params::FirstPersonAnimInstance_GetMovementInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FootprintsBase.StartIndependentFootstep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFootprintsBase::StartIndependentFootstep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootprintsBase", "StartIndependentFootstep");

	Params::FootprintsBase_StartIndependentFootstep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SAIPerceptionComponent.SetHearingRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USAIPerceptionComponent::SetHearingRadius(float NewRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "SetHearingRadius");

	Params::SAIPerceptionComponent_SetHearingRadius Parms{};

	Parms.NewRadius = NewRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SAIPerceptionComponent.SetPeripheralVisionAngleDegrees
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USAIPerceptionComponent::SetPeripheralVisionAngleDegrees(float NewAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "SetPeripheralVisionAngleDegrees");

	Params::SAIPerceptionComponent_SetPeripheralVisionAngleDegrees Parms{};

	Parms.NewAngle = NewAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SAIPerceptionComponent.CheckAvailabilityActorByAnySense
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USAIPerceptionComponent::CheckAvailabilityActorByAnySense(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "CheckAvailabilityActorByAnySense");

	Params::SAIPerceptionComponent_CheckAvailabilityActorByAnySense Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SAIPerceptionComponent.GetHearingRadius
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float*                                  Radius                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USAIPerceptionComponent::GetHearingRadius(float* Radius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "GetHearingRadius");

	Params::SAIPerceptionComponent_GetHearingRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Radius != nullptr)
		*Radius = Parms.Radius;

	return Parms.ReturnValue;
}


// Function Smuta.SAIPerceptionComponent.GetImmediateDetectionRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USAIPerceptionComponent::GetImmediateDetectionRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "GetImmediateDetectionRadius");

	Params::SAIPerceptionComponent_GetImmediateDetectionRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SAIPerceptionComponent.GetLoseSightRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USAIPerceptionComponent::GetLoseSightRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "GetLoseSightRadius");

	Params::SAIPerceptionComponent_GetLoseSightRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SAIPerceptionComponent.GetPeripheralVisionAngleDegrees
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USAIPerceptionComponent::GetPeripheralVisionAngleDegrees() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "GetPeripheralVisionAngleDegrees");

	Params::SAIPerceptionComponent_GetPeripheralVisionAngleDegrees Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SAIPerceptionComponent.GetSightRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USAIPerceptionComponent::GetSightRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "GetSightRadius");

	Params::SAIPerceptionComponent_GetSightRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SAIPerceptionComponent.GetSixSenseRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USAIPerceptionComponent::GetSixSenseRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "GetSixSenseRadius");

	Params::SAIPerceptionComponent_GetSixSenseRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SAIPerceptionComponent.HasActiveStimulusWithSense
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<TSubclassOf<class UAISense>>&SenseClasses                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USAIPerceptionComponent::HasActiveStimulusWithSense(const class AActor* Source, const TArray<TSubclassOf<class UAISense>>& SenseClasses) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "HasActiveStimulusWithSense");

	Params::SAIPerceptionComponent_HasActiveStimulusWithSense Parms{};

	Parms.Source = Source;
	Parms.SenseClasses = std::move(SenseClasses);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SAIPerceptionComponent.HasActiveStimulusWithSenseAndTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAISense>             SenseClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USAIPerceptionComponent::HasActiveStimulusWithSenseAndTag(const class AActor* Source, TSubclassOf<class UAISense> SenseClass, class FName Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "HasActiveStimulusWithSenseAndTag");

	Params::SAIPerceptionComponent_HasActiveStimulusWithSenseAndTag Parms{};

	Parms.Source = Source;
	Parms.SenseClass = SenseClass;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SAIPerceptionComponent.HasActiveStimulusWithTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USAIPerceptionComponent::HasActiveStimulusWithTag(const class AActor* Source, class FName Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SAIPerceptionComponent", "HasActiveStimulusWithTag");

	Params::SAIPerceptionComponent_HasActiveStimulusWithTag Parms{};

	Parms.Source = Source;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaAbilitySystemBlueprintFunctionLibrary.GetEffectAssetGameplayTagsFromEffectSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayEffectSpec&       EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer USmutaAbilitySystemBlueprintFunctionLibrary::GetEffectAssetGameplayTagsFromEffectSpec(const struct FGameplayEffectSpec& EffectSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmutaAbilitySystemBlueprintFunctionLibrary", "GetEffectAssetGameplayTagsFromEffectSpec");

	Params::SmutaAbilitySystemBlueprintFunctionLibrary_GetEffectAssetGameplayTagsFromEffectSpec Parms{};

	Parms.EffectSpec = std::move(EffectSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaAbilitySystemBlueprintFunctionLibrary.GetModifierParamsFromEvaluatedData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayModifierEvaluatedData&EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttribute*              OutAttribute                                           (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutMagnitude                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayModOp*                         OutMod                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutValid                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaAbilitySystemBlueprintFunctionLibrary::GetModifierParamsFromEvaluatedData(const struct FGameplayModifierEvaluatedData& EffectSpec, struct FGameplayAttribute* OutAttribute, float* OutMagnitude, EGameplayModOp* OutMod, bool* OutValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmutaAbilitySystemBlueprintFunctionLibrary", "GetModifierParamsFromEvaluatedData");

	Params::SmutaAbilitySystemBlueprintFunctionLibrary_GetModifierParamsFromEvaluatedData Parms{};

	Parms.EffectSpec = std::move(EffectSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAttribute != nullptr)
		*OutAttribute = std::move(Parms.OutAttribute);

	if (OutMagnitude != nullptr)
		*OutMagnitude = Parms.OutMagnitude;

	if (OutMod != nullptr)
		*OutMod = Parms.OutMod;

	if (OutValid != nullptr)
		*OutValid = Parms.OutValid;
}


// Function Smuta.FractionInterface.GetFractionComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UFractionComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFractionComponent* IFractionInterface::GetFractionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FractionInterface", "GetFractionComponent");

	Params::FractionInterface_GetFractionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionComponent.GetActorsAttitude
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor1                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     Actor2                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamAttitude UFractionComponent::GetActorsAttitude(const class AActor* Actor1, const class AActor* Actor2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FractionComponent", "GetActorsAttitude");

	Params::FractionComponent_GetActorsAttitude Parms{};

	Parms.Actor1 = Actor1;
	Parms.Actor2 = Actor2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionComponent.GetActorsExtendedAttitude
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor1                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     Actor2                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExtendedAttitude                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EExtendedAttitude UFractionComponent::GetActorsExtendedAttitude(const class AActor* Actor1, const class AActor* Actor2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FractionComponent", "GetActorsExtendedAttitude");

	Params::FractionComponent_GetActorsExtendedAttitude Parms{};

	Parms.Actor1 = Actor1;
	Parms.Actor2 = Actor2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionComponent.GetAttitudeEffectsChange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor1                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     Actor2                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExtendedAttitude*                      InOutAttitude                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFractionComponent::GetAttitudeEffectsChange(const class AActor* Actor1, const class AActor* Actor2, EExtendedAttitude* InOutAttitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FractionComponent", "GetAttitudeEffectsChange");

	Params::FractionComponent_GetAttitudeEffectsChange Parms{};

	Parms.Actor1 = Actor1;
	Parms.Actor2 = Actor2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InOutAttitude != nullptr)
		*InOutAttitude = Parms.InOutAttitude;
}


// Function Smuta.FractionComponent.GetFractionsNum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFractionComponent::GetFractionsNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FractionComponent", "GetFractionsNum");

	Params::FractionComponent_GetFractionsNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionComponent.IsActorScaryOf
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     ScaryOfActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFractionComponent::IsActorScaryOf(const class AActor* Actor, const class AActor* ScaryOfActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FractionComponent", "IsActorScaryOf");

	Params::FractionComponent_IsActorScaryOf Parms{};

	Parms.Actor = Actor;
	Parms.ScaryOfActor = ScaryOfActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaInputSettings.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class USmutaInputSettings*        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USmutaInputSettings* USmutaInputSettings::Get()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmutaInputSettings", "Get");

	Params::SmutaInputSettings_Get Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaCombatSettings.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class USmutaCombatSettings*       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USmutaCombatSettings* USmutaCombatSettings::Get()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmutaCombatSettings", "Get");

	Params::SmutaCombatSettings_Get Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.AddFractionInfluence
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFractionsSubsystem::AddFractionInfluence(const ESmutaDLCFraction& Fraction, float DeltaValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "AddFractionInfluence");

	Params::FractionsSubsystem_AddFractionInfluence Parms{};

	Parms.Fraction = Fraction;
	Parms.DeltaValue = DeltaValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.FractionsSubsystem.AddMultipleFractionsInfluence
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TMap<ESmutaDLCFraction, float>&   FractionsInfluenceToAdd                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFractionsSubsystem::AddMultipleFractionsInfluence(const TMap<ESmutaDLCFraction, float>& FractionsInfluenceToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "AddMultipleFractionsInfluence");

	Params::FractionsSubsystem_AddMultipleFractionsInfluence Parms{};

	Parms.FractionsInfluenceToAdd = std::move(FractionsInfluenceToAdd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.FractionsSubsystem.ClearLastUnseenFractionsInfluenceChanges
// (Final, Native, Protected, BlueprintCallable)

void UFractionsSubsystem::ClearLastUnseenFractionsInfluenceChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "ClearLastUnseenFractionsInfluenceChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.FractionsSubsystem.ClearUnseenFractions
// (Final, Native, Public, BlueprintCallable)

void UFractionsSubsystem::ClearUnseenFractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "ClearUnseenFractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.FractionsSubsystem.OnSubSystemsInited
// (Final, Native, Protected)

void UFractionsSubsystem::OnSubSystemsInited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "OnSubSystemsInited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.FractionsSubsystem.SetFractionHidden
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsHidden                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFractionsSubsystem::SetFractionHidden(const ESmutaDLCFraction& Fraction, bool bIsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "SetFractionHidden");

	Params::FractionsSubsystem_SetFractionHidden Parms{};

	Parms.Fraction = Fraction;
	Parms.bIsHidden = bIsHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.FractionsSubsystem.SetFractionInfluence
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFractionsSubsystem::SetFractionInfluence(const ESmutaDLCFraction& Fraction, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "SetFractionInfluence");

	Params::FractionsSubsystem_SetFractionInfluence Parms{};

	Parms.Fraction = Fraction;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.FractionsSubsystem.SetFractionMemberOpened
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      FractionMemberId                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsOpened                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFractionsSubsystem::SetFractionMemberOpened(const ESmutaDLCFraction& Fraction, const class FName& FractionMemberId, bool bIsOpened)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "SetFractionMemberOpened");

	Params::FractionsSubsystem_SetFractionMemberOpened Parms{};

	Parms.Fraction = Fraction;
	Parms.FractionMemberId = FractionMemberId;
	Parms.bIsOpened = bIsOpened;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.FractionsSubsystem.SetFractionState
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EFractionState&                   State                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFractionsSubsystem::SetFractionState(const ESmutaDLCFraction& Fraction, const EFractionState& State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "SetFractionState");

	Params::FractionsSubsystem_SetFractionState Parms{};

	Parms.Fraction = Fraction;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.FractionsSubsystem.GetAllRegisteredFractions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<ESmutaDLCFraction>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ESmutaDLCFraction> UFractionsSubsystem::GetAllRegisteredFractions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetAllRegisteredFractions");

	Params::FractionsSubsystem_GetAllRegisteredFractions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetFractionData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFractionData                    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FFractionData UFractionsSubsystem::GetFractionData(const ESmutaDLCFraction& Fraction, bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetFractionData");

	Params::FractionsSubsystem_GetFractionData Parms{};

	Parms.Fraction = Fraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetFractionInfluence
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFractionsSubsystem::GetFractionInfluence(const ESmutaDLCFraction& Fraction, bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetFractionInfluence");

	Params::FractionsSubsystem_GetFractionInfluence Parms{};

	Parms.Fraction = Fraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetFractionMemberData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      FractionMemberId                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFractionMemberData              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FFractionMemberData UFractionsSubsystem::GetFractionMemberData(const ESmutaDLCFraction& Fraction, const class FName& FractionMemberId, bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetFractionMemberData");

	Params::FractionsSubsystem_GetFractionMemberData Parms{};

	Parms.Fraction = Fraction;
	Parms.FractionMemberId = FractionMemberId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetFractionMemberIds
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UFractionsSubsystem::GetFractionMemberIds(const ESmutaDLCFraction& Fraction, bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetFractionMemberIds");

	Params::FractionsSubsystem_GetFractionMemberIds Parms{};

	Parms.Fraction = Fraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetFractionMemberProgressionInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      FractionMemberId                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFractionMemberProgressionInfo   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FFractionMemberProgressionInfo UFractionsSubsystem::GetFractionMemberProgressionInfo(const ESmutaDLCFraction& Fraction, const class FName& FractionMemberId, bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetFractionMemberProgressionInfo");

	Params::FractionsSubsystem_GetFractionMemberProgressionInfo Parms{};

	Parms.Fraction = Fraction;
	Parms.FractionMemberId = FractionMemberId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetFractionProgressionInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFractionProgressionInfo         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FFractionProgressionInfo UFractionsSubsystem::GetFractionProgressionInfo(const ESmutaDLCFraction& Fraction, bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetFractionProgressionInfo");

	Params::FractionsSubsystem_GetFractionProgressionInfo Parms{};

	Parms.Fraction = Fraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetHiddenFractions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<ESmutaDLCFraction>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ESmutaDLCFraction> UFractionsSubsystem::GetHiddenFractions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetHiddenFractions");

	Params::FractionsSubsystem_GetHiddenFractions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetLastUnseenFractionsInfluenceChanges
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<ESmutaDLCFraction, float>          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<ESmutaDLCFraction, float> UFractionsSubsystem::GetLastUnseenFractionsInfluenceChanges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetLastUnseenFractionsInfluenceChanges");

	Params::FractionsSubsystem_GetLastUnseenFractionsInfluenceChanges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetMaxInfluence
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFractionsSubsystem::GetMaxInfluence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetMaxInfluence");

	Params::FractionsSubsystem_GetMaxInfluence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetMinInfluence
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFractionsSubsystem::GetMinInfluence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetMinInfluence");

	Params::FractionsSubsystem_GetMinInfluence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetNotHiddenFractions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<ESmutaDLCFraction>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ESmutaDLCFraction> UFractionsSubsystem::GetNotHiddenFractions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetNotHiddenFractions");

	Params::FractionsSubsystem_GetNotHiddenFractions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetOpenedFractionMemberIds
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UFractionsSubsystem::GetOpenedFractionMemberIds(const ESmutaDLCFraction& Fraction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetOpenedFractionMemberIds");

	Params::FractionsSubsystem_GetOpenedFractionMemberIds Parms{};

	Parms.Fraction = Fraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.GetUnseenFractionInfluence
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFractionsSubsystem::GetUnseenFractionInfluence(const ESmutaDLCFraction& Fraction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "GetUnseenFractionInfluence");

	Params::FractionsSubsystem_GetUnseenFractionInfluence Parms{};

	Parms.Fraction = Fraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.HasLastUnseenFractionsInfluenceChanges
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFractionsSubsystem::HasLastUnseenFractionsInfluenceChanges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "HasLastUnseenFractionsInfluenceChanges");

	Params::FractionsSubsystem_HasLastUnseenFractionsInfluenceChanges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.IsFractionHidden
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFractionsSubsystem::IsFractionHidden(const ESmutaDLCFraction& Fraction, bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "IsFractionHidden");

	Params::FractionsSubsystem_IsFractionHidden Parms{};

	Parms.Fraction = Fraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.FractionsSubsystem.IsFractionMemberOpened
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESmutaDLCFraction&                Fraction                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      FractionMemberId                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFractionsSubsystem::IsFractionMemberOpened(const ESmutaDLCFraction& Fraction, const class FName& FractionMemberId, bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FractionsSubsystem", "IsFractionMemberOpened");

	Params::FractionsSubsystem_IsFractionMemberOpened Parms{};

	Parms.Fraction = Fraction;
	Parms.FractionMemberId = FractionMemberId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.SpawnerPointZastava.Spawn
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMatrixDataAsset*                 MatrixDataAsset                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADefaultCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADefaultCharacter* ASpawnerPointZastava::Spawn(class UMatrixDataAsset* MatrixDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerPointZastava", "Spawn");

	Params::SpawnerPointZastava_Spawn Parms{};

	Parms.MatrixDataAsset = MatrixDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SimpleInnerVoiceActor.BeginOverlapped
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASimpleInnerVoiceActor::BeginOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleInnerVoiceActor", "BeginOverlapped");

	Params::SimpleInnerVoiceActor_BeginOverlapped Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SimpleInnerVoiceActor.DeactivateActor
// (Final, Native, Protected, BlueprintCallable)

void ASimpleInnerVoiceActor::DeactivateActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleInnerVoiceActor", "DeactivateActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameInstance.LoadGameData
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmutaGameInstance::LoadGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameInstance", "LoadGameData");

	Params::SmutaGameInstance_LoadGameData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameInstance.OnExitSmutaGame
// (Final, Native, Public, BlueprintCallable)

void USmutaGameInstance::OnExitSmutaGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameInstance", "OnExitSmutaGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameInstance.OnGamePostLoad
// (Final, Native, Protected)
// Parameters:
// const bool                              InLoadResult                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameInstance::OnGamePostLoad(const bool InLoadResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameInstance", "OnGamePostLoad");

	Params::SmutaGameInstance_OnGamePostLoad Parms{};

	Parms.InLoadResult = InLoadResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameInstance.OnGamePostLoadFailedEvent
// (Event, Protected, BlueprintEvent)

void USmutaGameInstance::OnGamePostLoadFailedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameInstance", "OnGamePostLoadFailedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.SmutaGameInstance.OnGamePreLoad
// (Final, Native, Protected)

void USmutaGameInstance::OnGamePreLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameInstance", "OnGamePreLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameInstance.OnGamePreLoadEvent
// (Event, Protected, BlueprintEvent)

void USmutaGameInstance::OnGamePreLoadEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameInstance", "OnGamePreLoadEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.SmutaGameInstance.OnGamePreSave
// (Final, Native, Protected)

void USmutaGameInstance::OnGamePreSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameInstance", "OnGamePreSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameInstance.OnGamePreSaveEvent
// (Event, Protected, BlueprintEvent)

void USmutaGameInstance::OnGamePreSaveEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameInstance", "OnGamePreSaveEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.SmutaGameInstance.OnStartNewSmutaGame
// (Final, Native, Public, BlueprintCallable)

void USmutaGameInstance::OnStartNewSmutaGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameInstance", "OnStartNewSmutaGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameInstance.SaveGameData
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmutaGameInstance::SaveGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameInstance", "SaveGameData");

	Params::SmutaGameInstance_SaveGameData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Smuta.SmutaSplineMovementComponent.SetSplineMovementInstanceVars
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    inStart                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class ASplineActor>      InSpline                                               (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              InTags                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USmutaSplineMovementComponent::SetSplineMovementInstanceVars(bool inStart, TSoftObjectPtr<class ASplineActor> InSpline, const TArray<class FName>& InTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaSplineMovementComponent", "SetSplineMovementInstanceVars");

	Params::SmutaSplineMovementComponent_SetSplineMovementInstanceVars Parms{};

	Parms.inStart = inStart;
	Parms.InSpline = InSpline;
	Parms.InTags = std::move(InTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetedCharacterMovementComponent.OnAimTagChanged
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetedCharacterMovementComponent::OnAimTagChanged(const struct FGameplayTag& Tag, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetedCharacterMovementComponent", "OnAimTagChanged");

	Params::TargetedCharacterMovementComponent_OnAimTagChanged Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetedCharacterMovementComponent.OnHardLockChanged
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetedCharacterMovementComponent::OnHardLockChanged(const struct FGameplayTag& Tag, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetedCharacterMovementComponent", "OnHardLockChanged");

	Params::TargetedCharacterMovementComponent_OnHardLockChanged Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetedCharacterMovementComponent.OnSoftLockChanged
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetedCharacterMovementComponent::OnSoftLockChanged(const struct FGameplayTag& Tag, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetedCharacterMovementComponent", "OnSoftLockChanged");

	Params::TargetedCharacterMovementComponent_OnSoftLockChanged Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetedCharacterMovementComponent.SetLockOnTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewLockOnTarget                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetedCharacterMovementComponent::SetLockOnTarget(class AActor* NewLockOnTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetedCharacterMovementComponent", "SetLockOnTarget");

	Params::TargetedCharacterMovementComponent_SetLockOnTarget Parms{};

	Parms.NewLockOnTarget = NewLockOnTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetedCharacterMovementComponent.GetLockOnTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class AActor* UTargetedCharacterMovementComponent::GetLockOnTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetedCharacterMovementComponent", "GetLockOnTarget");

	Params::TargetedCharacterMovementComponent_GetLockOnTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaDialogueGameplayBehavior.FinishPreparation
// (Final, Native, Protected, BlueprintCallable)

void USmutaDialogueGameplayBehavior::FinishPreparation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaDialogueGameplayBehavior", "FinishPreparation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaDialogueGameplayBehavior.OnDialogueFinished
// (Final, Native, Protected)
// Parameters:
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaDialogueGameplayBehavior::OnDialogueFinished(bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaDialogueGameplayBehavior", "OnDialogueFinished");

	Params::SmutaDialogueGameplayBehavior_OnDialogueFinished Parms{};

	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaDialogueGameplayBehavior.OnDialogueStarted
// (Final, Native, Protected)
// Parameters:
// class ADefaultCharacter*                Companion1                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADefaultCharacter*                Companion2                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaDialogueGameplayBehavior::OnDialogueStarted(class ADefaultCharacter* Companion1, class ADefaultCharacter* Companion2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaDialogueGameplayBehavior", "OnDialogueStarted");

	Params::SmutaDialogueGameplayBehavior_OnDialogueStarted Parms{};

	Parms.Companion1 = Companion1;
	Parms.Companion2 = Companion2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaDialogueGameplayBehavior.OnPreparationFinished
// (Final, Native, Protected)
// Parameters:
// class ADefaultCharacter*                Participant                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaDialogueGameplayBehavior::OnPreparationFinished(class ADefaultCharacter* Participant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaDialogueGameplayBehavior", "OnPreparationFinished");

	Params::SmutaDialogueGameplayBehavior_OnPreparationFinished Parms{};

	Parms.Participant = Participant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaDialogueGameplayBehavior.StartDialogueLogic
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADefaultCharacter*                Companion1                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADefaultCharacter*                Companion2                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaDialogueGameplayBehavior::StartDialogueLogic(class ADefaultCharacter* Companion1, class ADefaultCharacter* Companion2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaDialogueGameplayBehavior", "StartDialogueLogic");

	Params::SmutaDialogueGameplayBehavior_StartDialogueLogic Parms{};

	Parms.Companion1 = Companion1;
	Parms.Companion2 = Companion2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaDialogueGameplayBehavior.StartPostDialogueLogic
// (Native, Event, Protected, BlueprintEvent)

void USmutaDialogueGameplayBehavior::StartPostDialogueLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaDialogueGameplayBehavior", "StartPostDialogueLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaDialogueGameplayBehavior.StartPrepareLogic
// (Native, Event, Protected, BlueprintEvent)

void USmutaDialogueGameplayBehavior::StartPrepareLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaDialogueGameplayBehavior", "StartPrepareLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaDialogueGameplayBehavior.StartWaitDialogLogic
// (Native, Event, Protected, BlueprintEvent)

void USmutaDialogueGameplayBehavior::StartWaitDialogLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaDialogueGameplayBehavior", "StartWaitDialogLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.HumanMatrixSpawner.FilterDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHumanRoleType                          FirstCharType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHumanRoleType                          SecondCharType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenderType                             FirstCharGender                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenderType                             SecondCharGender                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UMatrixDialogue*>&   Dialogues                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UMatrixDialogue*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatrixDialogue* AHumanMatrixSpawner::FilterDialogue(EHumanRoleType FirstCharType, EHumanRoleType SecondCharType, EGenderType FirstCharGender, EGenderType SecondCharGender, const TArray<class UMatrixDialogue*>& Dialogues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMatrixSpawner", "FilterDialogue");

	Params::HumanMatrixSpawner_FilterDialogue Parms{};

	Parms.FirstCharType = FirstCharType;
	Parms.SecondCharType = SecondCharType;
	Parms.FirstCharGender = FirstCharGender;
	Parms.SecondCharGender = SecondCharGender;
	Parms.Dialogues = std::move(Dialogues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.HumanMatrixSpawner.GetCorrectReaction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlaceResidence                         PlaceResidence                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenderType                             GenderNPC                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UMatrixReactions*>&  Reactions                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EFraction                               PlayerFraction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FReactionsToPlayer               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FReactionsToPlayer AHumanMatrixSpawner::GetCorrectReaction(EPlaceResidence PlaceResidence, EGenderType GenderNPC, const TArray<class UMatrixReactions*>& Reactions, EFraction PlayerFraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMatrixSpawner", "GetCorrectReaction");

	Params::HumanMatrixSpawner_GetCorrectReaction Parms{};

	Parms.PlaceResidence = PlaceResidence;
	Parms.GenderNPC = GenderNPC;
	Parms.Reactions = std::move(Reactions);
	Parms.PlayerFraction = PlayerFraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.Indoor.HandleLevelChanging
// (Final, Native, Protected)

void AIndoor::HandleLevelChanging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Indoor", "HandleLevelChanging");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.Indoor.OnPlayerEnters
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndoor::OnPlayerEnters(class APawn* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Indoor", "OnPlayerEnters");

	Params::Indoor_OnPlayerEnters Parms{};

	Parms.PlayerPawn = PlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.Indoor.OnPlayerLeaves
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndoor::OnPlayerLeaves(class APawn* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Indoor", "OnPlayerLeaves");

	Params::Indoor_OnPlayerLeaves Parms{};

	Parms.PlayerPawn = PlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InGameHintTrackerData.BP_OnInitialize
// (Event, Protected, BlueprintEvent)

void UInGameHintTrackerData::BP_OnInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameHintTrackerData", "BP_OnInitialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.InGameHintTrackerData.BP_IsValidData
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInGameHintTrackerData::BP_IsValidData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameHintTrackerData", "BP_IsValidData");

	Params::InGameHintTrackerData_BP_IsValidData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Smuta.InGameHintTrackerWidget.AddToQueue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInGameHintTrackerData*           Data                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameHintTrackerWidget::AddToQueue(class UInGameHintTrackerData* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameHintTrackerWidget", "AddToQueue");

	Params::InGameHintTrackerWidget_AddToQueue Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InGameHintTrackerWidget.BP_IsQueueAvailable
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInGameHintTrackerWidget::BP_IsQueueAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameHintTrackerWidget", "BP_IsQueueAvailable");

	Params::InGameHintTrackerWidget_BP_IsQueueAvailable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Smuta.InGameHintTrackerWidget.BP_OnHintFinished
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInGameHintTrackerData*           Data                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameHintTrackerWidget::BP_OnHintFinished(class UInGameHintTrackerData* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameHintTrackerWidget", "BP_OnHintFinished");

	Params::InGameHintTrackerWidget_BP_OnHintFinished Parms{};

	Parms.Data = Data;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.InGameHintTrackerWidget.BP_RunHint
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInGameHintTrackerData*           Data                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameHintTrackerWidget::BP_RunHint(class UInGameHintTrackerData* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameHintTrackerWidget", "BP_RunHint");

	Params::InGameHintTrackerWidget_BP_RunHint Parms{};

	Parms.Data = Data;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.InGameHintTrackerWidget.BP_StopCurrentHint
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UInGameHintTrackerWidget::BP_StopCurrentHint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameHintTrackerWidget", "BP_StopCurrentHint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.InGameHintTrackerWidget.CommitHint
// (Final, Native, Public, BlueprintCallable)

void UInGameHintTrackerWidget::CommitHint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameHintTrackerWidget", "CommitHint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InGameHintTrackerWidget.ProcessQueue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInGameHintTrackerWidget::ProcessQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameHintTrackerWidget", "ProcessQueue");

	Params::InGameHintTrackerWidget_ProcessQueue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.InGameHintTrackerWidget.StopProcessingQueue
// (Final, Native, Public, BlueprintCallable)

void UInGameHintTrackerWidget::StopProcessingQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameHintTrackerWidget", "StopProcessingQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InGameHintTrackerWidget.IsBusy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInGameHintTrackerWidget::IsBusy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameHintTrackerWidget", "IsBusy");

	Params::InGameHintTrackerWidget_IsBusy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.IngameHUD.CloseHint
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      HintName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIngameHUD::CloseHint(const class FName& HintName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IngameHUD", "CloseHint");

	Params::IngameHUD_CloseHint Parms{};

	Parms.HintName = HintName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.IngameHUD.ShowComboHint
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      HintName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTutorialComboHintContent*  HintContent                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIngameHUD::ShowComboHint(const class FName& HintName, const class UTutorialComboHintContent* HintContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IngameHUD", "ShowComboHint");

	Params::IngameHUD_ShowComboHint Parms{};

	Parms.HintName = HintName;
	Parms.HintContent = HintContent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.IngameHUD.ShowNonBlockingHint
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      HintName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTutorialNonBlockingHintContent*HintContent                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIngameHUD::ShowNonBlockingHint(const class FName& HintName, const class UTutorialNonBlockingHintContent* HintContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IngameHUD", "ShowNonBlockingHint");

	Params::IngameHUD_ShowNonBlockingHint Parms{};

	Parms.HintName = HintName;
	Parms.HintContent = HintContent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.IngameHUD.ShowPopupHint
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      HintName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTutorialBasePopupHintContent*HintContent                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIngameHUD::ShowPopupHint(const class FName& HintName, const class UTutorialBasePopupHintContent* HintContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IngameHUD", "ShowPopupHint");

	Params::IngameHUD_ShowPopupHint Parms{};

	Parms.HintName = HintName;
	Parms.HintContent = HintContent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.IngameHUD.ShowTagEventComboHint
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      HintName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTutorialTagEventComboContent*HintContent                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIngameHUD::ShowTagEventComboHint(const class FName& HintName, const class UTutorialTagEventComboContent* HintContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IngameHUD", "ShowTagEventComboHint");

	Params::IngameHUD_ShowTagEventComboHint Parms{};

	Parms.HintName = HintName;
	Parms.HintContent = HintContent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.InvestigationArea.ActivateInvestigation
// (Final, Native, Public, BlueprintCallable)

void AInvestigationArea::ActivateInvestigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationArea", "ActivateInvestigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InvestigationArea.AddInvestigationEffect
// (Final, Native, Protected, BlueprintCallable)

void AInvestigationArea::AddInvestigationEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationArea", "AddInvestigationEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InvestigationArea.BeginOverlapped
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AInvestigationArea::BeginOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationArea", "BeginOverlapped");

	Params::InvestigationArea_BeginOverlapped Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InvestigationArea.ChangeInvestigationState
// (Final, Native, Private)
// Parameters:
// EEvidenceState                          NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInvestigationArea::ChangeInvestigationState(EEvidenceState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationArea", "ChangeInvestigationState");

	Params::InvestigationArea_ChangeInvestigationState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InvestigationArea.DeactivateInvestigation
// (Final, Native, Public, BlueprintCallable)

void AInvestigationArea::DeactivateInvestigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationArea", "DeactivateInvestigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InvestigationArea.ForceActivateInvestigation
// (Event, Public, BlueprintEvent)

void AInvestigationArea::ForceActivateInvestigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationArea", "ForceActivateInvestigation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.InvestigationArea.OnAdditionalEvidenceChanged
// (Final, Native, Protected)
// Parameters:
// class AEvidenceBase*                    InstigatorActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEvidenceState                          NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInvestigationArea::OnAdditionalEvidenceChanged(class AEvidenceBase* InstigatorActor, EEvidenceState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationArea", "OnAdditionalEvidenceChanged");

	Params::InvestigationArea_OnAdditionalEvidenceChanged Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InvestigationArea.OnEvidenceChanged
// (Final, Native, Protected)
// Parameters:
// class AEvidenceBase*                    InstigatorActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEvidenceState                          NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInvestigationArea::OnEvidenceChanged(class AEvidenceBase* InstigatorActor, EEvidenceState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationArea", "OnEvidenceChanged");

	Params::InvestigationArea_OnEvidenceChanged Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InvestigationArea.RemoveInvestigationEffect
// (Final, Native, Protected, BlueprintCallable)

void AInvestigationArea::RemoveInvestigationEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationArea", "RemoveInvestigationEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InvestigationArea.StartInvestigation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ForceActiveArea                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInvestigationArea::StartInvestigation(bool ForceActiveArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationArea", "StartInvestigation");

	Params::InvestigationArea_StartInvestigation Parms{};

	Parms.ForceActiveArea = ForceActiveArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InvestigationArea.StartupOnMap
// (Final, Native, Public, BlueprintCallable)

void AInvestigationArea::StartupOnMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationArea", "StartupOnMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.InvestigationAreaMarker.HandleStateChanged
// (Final, Native, Protected)
// Parameters:
// EEvidenceState                          State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvestigationAreaMarker::HandleStateChanged(EEvidenceState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationAreaMarker", "HandleStateChanged");

	Params::InvestigationAreaMarker_HandleStateChanged Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CarouselItemData.BP_OnInitialize
// (Event, Protected, BlueprintEvent)

void UCarouselItemData::BP_OnInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemData", "BP_OnInitialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.CarouselItemDataCycleArrayContainer.ClearContainer
// (Final, Native, Public, BlueprintCallable)

void UCarouselItemDataCycleArrayContainer::ClearContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "ClearContainer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.InitializeContainer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class UCarouselItemData*>& Elements                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InMinElementsToClose                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCarouselItemDataCycleArrayContainer::InitializeContainer(const TArray<class UCarouselItemData*>& Elements, int32 InMinElementsToClose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "InitializeContainer");

	Params::CarouselItemDataCycleArrayContainer_InitializeContainer Parms{};

	Parms.Elements = std::move(Elements);
	Parms.InMinElementsToClose = InMinElementsToClose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.PushToContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCarouselItemData*                Element                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCarouselItemDataCycleArrayContainer::PushToContainer(class UCarouselItemData* Element)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "PushToContainer");

	Params::CarouselItemDataCycleArrayContainer_PushToContainer Parms{};

	Parms.Element = Element;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.RemoveCurrentFromContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCarouselItemDataCycleArrayContainer::RemoveCurrentFromContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "RemoveCurrentFromContainer");

	Params::CarouselItemDataCycleArrayContainer_RemoveCurrentFromContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.ToItemAtDirection
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   DirectionTimes                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCarouselItemData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCarouselItemData* UCarouselItemDataCycleArrayContainer::ToItemAtDirection(int32 DirectionTimes, bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "ToItemAtDirection");

	Params::CarouselItemDataCycleArrayContainer_ToItemAtDirection Parms{};

	Parms.DirectionTimes = DirectionTimes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.ToNextItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCarouselItemData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCarouselItemData* UCarouselItemDataCycleArrayContainer::ToNextItem(bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "ToNextItem");

	Params::CarouselItemDataCycleArrayContainer_ToNextItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.ToPreviousItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCarouselItemData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCarouselItemData* UCarouselItemDataCycleArrayContainer::ToPreviousItem(bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "ToPreviousItem");

	Params::CarouselItemDataCycleArrayContainer_ToPreviousItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.CountElementsInContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCarouselItemDataCycleArrayContainer::CountElementsInContainer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "CountElementsInContainer");

	Params::CarouselItemDataCycleArrayContainer_CountElementsInContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.GetCurrentItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCarouselItemData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCarouselItemData* UCarouselItemDataCycleArrayContainer::GetCurrentItem(bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "GetCurrentItem");

	Params::CarouselItemDataCycleArrayContainer_GetCurrentItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.GetItemAtDirection
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   DirectionTimes                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCarouselItemData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCarouselItemData* UCarouselItemDataCycleArrayContainer::GetItemAtDirection(int32 DirectionTimes, bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "GetItemAtDirection");

	Params::CarouselItemDataCycleArrayContainer_GetItemAtDirection Parms{};

	Parms.DirectionTimes = DirectionTimes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.GetMinElementsToClose
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCarouselItemDataCycleArrayContainer::GetMinElementsToClose() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "GetMinElementsToClose");

	Params::CarouselItemDataCycleArrayContainer_GetMinElementsToClose Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.GetNextItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCarouselItemData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCarouselItemData* UCarouselItemDataCycleArrayContainer::GetNextItem(bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "GetNextItem");

	Params::CarouselItemDataCycleArrayContainer_GetNextItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.GetPreviousItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCarouselItemData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCarouselItemData* UCarouselItemDataCycleArrayContainer::GetPreviousItem(bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "GetPreviousItem");

	Params::CarouselItemDataCycleArrayContainer_GetPreviousItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.HasItemAtDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   DirectionTimes                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCarouselItemDataCycleArrayContainer::HasItemAtDirection(int32 DirectionTimes) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "HasItemAtDirection");

	Params::CarouselItemDataCycleArrayContainer_HasItemAtDirection Parms{};

	Parms.DirectionTimes = DirectionTimes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.HasNextItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCarouselItemDataCycleArrayContainer::HasNextItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "HasNextItem");

	Params::CarouselItemDataCycleArrayContainer_HasNextItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.HasPreviousItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCarouselItemDataCycleArrayContainer::HasPreviousItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "HasPreviousItem");

	Params::CarouselItemDataCycleArrayContainer_HasPreviousItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.IsAtHead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCarouselItemDataCycleArrayContainer::IsAtHead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "IsAtHead");

	Params::CarouselItemDataCycleArrayContainer_IsAtHead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.IsAtTail
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCarouselItemDataCycleArrayContainer::IsAtTail() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "IsAtTail");

	Params::CarouselItemDataCycleArrayContainer_IsAtTail Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.IsClosedContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCarouselItemDataCycleArrayContainer::IsClosedContainer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "IsClosedContainer");

	Params::CarouselItemDataCycleArrayContainer_IsClosedContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.CarouselItemDataCycleArrayContainer.IsEmptyContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCarouselItemDataCycleArrayContainer::IsEmptyContainer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarouselItemDataCycleArrayContainer", "IsEmptyContainer");

	Params::CarouselItemDataCycleArrayContainer_IsEmptyContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ItemsCarouselWidget.BP_OnRotation
// (Native, Event, Public, BlueprintEvent)

void UItemsCarouselWidget::BP_OnRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "BP_OnRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ItemsCarouselWidget.CommitRotation
// (Final, Native, Protected, BlueprintCallable)

void UItemsCarouselWidget::CommitRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "CommitRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ItemsCarouselWidget.InitializeCarouselData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class UCarouselItemData*>& CarouselItemDataArray                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   MinElements                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsCarouselWidget::InitializeCarouselData(const TArray<class UCarouselItemData*>& CarouselItemDataArray, int32 MinElements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "InitializeCarouselData");

	Params::ItemsCarouselWidget_InitializeCarouselData Parms{};

	Parms.CarouselItemDataArray = std::move(CarouselItemDataArray);
	Parms.MinElements = MinElements;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ItemsCarouselWidget.Rotate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DirectionTimes                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsCarouselWidget::Rotate(int32 DirectionTimes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "Rotate");

	Params::ItemsCarouselWidget_Rotate Parms{};

	Parms.DirectionTimes = DirectionTimes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ItemsCarouselWidget.GetCurrentItemData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCarouselItemData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCarouselItemData* UItemsCarouselWidget::GetCurrentItemData(bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "GetCurrentItemData");

	Params::ItemsCarouselWidget_GetCurrentItemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.ItemsCarouselWidget.GetItemDataAtDirection
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   DirectionTimes                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCarouselItemData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCarouselItemData* UItemsCarouselWidget::GetItemDataAtDirection(int32 DirectionTimes, bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "GetItemDataAtDirection");

	Params::ItemsCarouselWidget_GetItemDataAtDirection Parms{};

	Parms.DirectionTimes = DirectionTimes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.ItemsCarouselWidget.GetNextItemData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCarouselItemData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCarouselItemData* UItemsCarouselWidget::GetNextItemData(bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "GetNextItemData");

	Params::ItemsCarouselWidget_GetNextItemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.ItemsCarouselWidget.GetPendingRotationDirectionTimes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemsCarouselWidget::GetPendingRotationDirectionTimes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "GetPendingRotationDirectionTimes");

	Params::ItemsCarouselWidget_GetPendingRotationDirectionTimes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ItemsCarouselWidget.GetPreviousItemData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCarouselItemData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCarouselItemData* UItemsCarouselWidget::GetPreviousItemData(bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "GetPreviousItemData");

	Params::ItemsCarouselWidget_GetPreviousItemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.ItemsCarouselWidget.HasItemAtDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   DirectionTimes                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemsCarouselWidget::HasItemAtDirection(int32 DirectionTimes) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "HasItemAtDirection");

	Params::ItemsCarouselWidget_HasItemAtDirection Parms{};

	Parms.DirectionTimes = DirectionTimes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ItemsCarouselWidget.HasNextItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemsCarouselWidget::HasNextItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "HasNextItem");

	Params::ItemsCarouselWidget_HasNextItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ItemsCarouselWidget.HasPreviousItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemsCarouselWidget::HasPreviousItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "HasPreviousItem");

	Params::ItemsCarouselWidget_HasPreviousItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ItemsCarouselWidget.IsRotating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemsCarouselWidget::IsRotating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCarouselWidget", "IsRotating");

	Params::ItemsCarouselWidget_IsRotating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TargetPrioritizationComponent.OnPerceptionSightHostileLost
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetPrioritizationComponent::OnPerceptionSightHostileLost(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "OnPerceptionSightHostileLost");

	Params::TargetPrioritizationComponent_OnPerceptionSightHostileLost Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetPrioritizationComponent.OnPerceptionSightHostileSensed
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetPrioritizationComponent::OnPerceptionSightHostileSensed(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "OnPerceptionSightHostileSensed");

	Params::TargetPrioritizationComponent_OnPerceptionSightHostileSensed Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetPrioritizationComponent.OnPerceptionSightLost
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetPrioritizationComponent::OnPerceptionSightLost(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "OnPerceptionSightLost");

	Params::TargetPrioritizationComponent_OnPerceptionSightLost Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetPrioritizationComponent.OnPerceptionSightNonHostileLost
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetPrioritizationComponent::OnPerceptionSightNonHostileLost(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "OnPerceptionSightNonHostileLost");

	Params::TargetPrioritizationComponent_OnPerceptionSightNonHostileLost Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetPrioritizationComponent.OnPerceptionSightNonHostileSensed
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetPrioritizationComponent::OnPerceptionSightNonHostileSensed(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "OnPerceptionSightNonHostileSensed");

	Params::TargetPrioritizationComponent_OnPerceptionSightNonHostileSensed Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetPrioritizationComponent.OnPerceptionSightScaryOfLost
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetPrioritizationComponent::OnPerceptionSightScaryOfLost(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "OnPerceptionSightScaryOfLost");

	Params::TargetPrioritizationComponent_OnPerceptionSightScaryOfLost Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetPrioritizationComponent.OnPerceptionSightScaryOfSensed
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetPrioritizationComponent::OnPerceptionSightScaryOfSensed(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "OnPerceptionSightScaryOfSensed");

	Params::TargetPrioritizationComponent_OnPerceptionSightScaryOfSensed Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetPrioritizationComponent.OnPerceptionSightSensed
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAIStimulus&               InStimulus                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UTargetPrioritizationComponent::OnPerceptionSightSensed(class AActor* Actor, const struct FAIStimulus& InStimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "OnPerceptionSightSensed");

	Params::TargetPrioritizationComponent_OnPerceptionSightSensed Parms{};

	Parms.Actor = Actor;
	Parms.InStimulus = std::move(InStimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetPrioritizationComponent.OnScaryOfActorTagChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exists                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetPrioritizationComponent::OnScaryOfActorTagChanged(class UAbilitySystemComponent* ASC, const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "OnScaryOfActorTagChanged");

	Params::TargetPrioritizationComponent_OnScaryOfActorTagChanged Parms{};

	Parms.ASC = ASC;
	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetPrioritizationComponent.OnSensedHostileDead
// (Final, Native, Private)
// Parameters:
// class ADefaultCharacter*                InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetPrioritizationComponent::OnSensedHostileDead(class ADefaultCharacter* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "OnSensedHostileDead");

	Params::TargetPrioritizationComponent_OnSensedHostileDead Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TargetPrioritizationComponent.K2_GetPerceivedPrioritizedHostileActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTargetPrioritizationComponent::K2_GetPerceivedPrioritizedHostileActors(TArray<class AActor*>* OutActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "K2_GetPerceivedPrioritizedHostileActors");

	Params::TargetPrioritizationComponent_K2_GetPerceivedPrioritizedHostileActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function Smuta.TargetPrioritizationComponent.RetrieveHostileActors
// (Final, Native, Private, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UTargetPrioritizationComponent::RetrieveHostileActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPrioritizationComponent", "RetrieveHostileActors");

	Params::TargetPrioritizationComponent_RetrieveHostileActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MainCameraManager.CameraBlendUpdate
// (Native, Protected)

void AMainCameraManager::CameraBlendUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainCameraManager", "CameraBlendUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainCameraManager.ChangeCurrentCameraModeForModeQuery
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              MatchingTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCameraModeData*            CameraModeData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainCameraManager::ChangeCurrentCameraModeForModeQuery(const struct FGameplayTag& MatchingTag, const class UCameraModeData* CameraModeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainCameraManager", "ChangeCurrentCameraModeForModeQuery");

	Params::MainCameraManager_ChangeCurrentCameraModeForModeQuery Parms{};

	Parms.MatchingTag = std::move(MatchingTag);
	Parms.CameraModeData = CameraModeData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainCameraManager.PawnTagUpdated
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exists                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainCameraManager::PawnTagUpdated(const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainCameraManager", "PawnTagUpdated");

	Params::MainCameraManager_PawnTagUpdated Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainCameraManager.SetCameraFOVModifier
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   NewFOVModifier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainCameraManager::SetCameraFOVModifier(float NewFOVModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainCameraManager", "SetCameraFOVModifier");

	Params::MainCameraManager_SetCameraFOVModifier Parms{};

	Parms.NewFOVModifier = NewFOVModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainCameraManager.SetCameraMode
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class UCameraModeData*            CameraModeData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainCameraManager::SetCameraMode(const class UCameraModeData* CameraModeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainCameraManager", "SetCameraMode");

	Params::MainCameraManager_SetCameraMode Parms{};

	Parms.CameraModeData = CameraModeData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainCameraManager.UpdateCameraZoomCorrection
// (Final, Native, Protected)

void AMainCameraManager::UpdateCameraZoomCorrection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainCameraManager", "UpdateCameraZoomCorrection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainCameraManager.GetIsLowSettings
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMainCameraManager::GetIsLowSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainCameraManager", "GetIsLowSettings");

	Params::MainCameraManager_GetIsLowSettings Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Smuta.MainGameMode.LevelTravelToStart
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UWorld>&     LevelToOpen                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class AActor>&     PlayerStart                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainGameMode::LevelTravelToStart(const class UObject* WorldContext, const TSoftObjectPtr<class UWorld>& LevelToOpen, const TSoftObjectPtr<class AActor>& PlayerStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MainGameMode", "LevelTravelToStart");

	Params::MainGameMode_LevelTravelToStart Parms{};

	Parms.WorldContext = WorldContext;
	Parms.LevelToOpen = LevelToOpen;
	Parms.PlayerStart = PlayerStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainGameMode.SetInputMappings
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class UInputMappingContext*>&      InputMappings                                          (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AMainGameMode::SetInputMappings(const class UObject* WorldContext, TSet<class UInputMappingContext*>& InputMappings) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainGameMode", "SetInputMappings");

	Params::MainGameMode_SetInputMappings Parms{};

	Parms.WorldContext = WorldContext;
	Parms.InputMappings = std::move(InputMappings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InputMappings = std::move(Parms.InputMappings);
}


// Function Smuta.TutorialBaseWidget.CloseHint
// (Native, Event, Protected, BlueprintEvent)

void UTutorialBaseWidget::CloseHint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialBaseWidget", "CloseHint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialBaseWidget.DeactivateHint
// (Final, Native, Public, BlueprintCallable)

void UTutorialBaseWidget::DeactivateHint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialBaseWidget", "DeactivateHint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialBaseWidget.FillOut
// (Native, Event, Protected, BlueprintEvent)

void UTutorialBaseWidget::FillOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialBaseWidget", "FillOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialBaseWidget.GetHintTextContainer
// (Event, Protected, BlueprintEvent)
// Parameters:
// class URichTextBlock*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URichTextBlock* UTutorialBaseWidget::GetHintTextContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialBaseWidget", "GetHintTextContainer");

	Params::TutorialBaseWidget_GetHintTextContainer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Smuta.TutorialBaseWidget.OnHintClosed
// (Native, Protected, BlueprintCallable)

void UTutorialBaseWidget::OnHintClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialBaseWidget", "OnHintClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialBaseWidget.GetHintName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UTutorialBaseWidget::GetHintName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialBaseWidget", "GetHintName");

	Params::TutorialBaseWidget_GetHintName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TagEventComboWidget.GetInputKey
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UInputAction*                     InputAction                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UTagEventComboWidget::GetInputKey(class UInputAction* InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagEventComboWidget", "GetInputKey");

	Params::TagEventComboWidget_GetInputKey Parms{};

	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TagEventComboWidget.OnCleanup
// (Event, Protected, BlueprintEvent)

void UTagEventComboWidget::OnCleanup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagEventComboWidget", "OnCleanup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.TagEventComboWidget.OnComboFailed
// (Event, Protected, BlueprintEvent)

void UTagEventComboWidget::OnComboFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagEventComboWidget", "OnComboFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.TagEventComboWidget.OnComboFinished
// (Event, Protected, BlueprintEvent)

void UTagEventComboWidget::OnComboFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagEventComboWidget", "OnComboFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.TagEventComboWidget.OnComboRestarted
// (Event, Protected, BlueprintEvent)

void UTagEventComboWidget::OnComboRestarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagEventComboWidget", "OnComboRestarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.TagEventComboWidget.OnComboSuccess
// (Event, Protected, BlueprintEvent)

void UTagEventComboWidget::OnComboSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagEventComboWidget", "OnComboSuccess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.TagEventComboWidget.OnProgressCombo
// (Event, Protected, BlueprintEvent)

void UTagEventComboWidget::OnProgressCombo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagEventComboWidget", "OnProgressCombo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.TagEventComboWidget.RefreshWidget
// (Event, Protected, BlueprintEvent)

void UTagEventComboWidget::RefreshWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagEventComboWidget", "RefreshWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.TagEventComboWidget.SetComboRestarted
// (Final, Native, Protected, BlueprintCallable)

void UTagEventComboWidget::SetComboRestarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagEventComboWidget", "SetComboRestarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TagEventComboWidget.SetContent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InHintName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTutorialTagEventComboContent*InContent                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTagEventComboWidget::SetContent(const class FName& InHintName, const class UTutorialTagEventComboContent* InContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagEventComboWidget", "SetContent");

	Params::TagEventComboWidget_SetContent Parms{};

	Parms.InHintName = InHintName;
	Parms.InContent = InContent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainPlayerController.BP_FlushInput
// (Final, Native, Public, BlueprintCallable)

void AMainPlayerController::BP_FlushInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainPlayerController", "BP_FlushInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainSupportBase.PushEvidance
// (Event, Public, BlueprintEvent)

void AMainSupportBase::PushEvidance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainSupportBase", "PushEvidance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.MainSupportBase.UnlockSupport
// (Final, Native, Public, BlueprintCallable)

void AMainSupportBase::UnlockSupport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainSupportBase", "UnlockSupport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialBaseContent.IsMainCloseInputActionValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTutorialBaseContent::IsMainCloseInputActionValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialBaseContent", "IsMainCloseInputActionValid");

	Params::TutorialBaseContent_IsMainCloseInputActionValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TutorialNonBlockingWidget.SetContent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InHintName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTutorialNonBlockingHintContent*InContent                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialNonBlockingWidget::SetContent(const class FName& InHintName, const class UTutorialNonBlockingHintContent* InContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialNonBlockingWidget", "SetContent");

	Params::TutorialNonBlockingWidget_SetContent Parms{};

	Parms.InHintName = InHintName;
	Parms.InContent = InContent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MatrixDataAsset.ApplyMatrixDataAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADefaultCharacter*                Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMatrixDataAsset*                 DataAsset                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatrixDataAsset::ApplyMatrixDataAsset(class ADefaultCharacter* Character, class UMatrixDataAsset* DataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatrixDataAsset", "ApplyMatrixDataAsset");

	Params::MatrixDataAsset_ApplyMatrixDataAsset Parms{};

	Parms.Character = Character;
	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialComboItemObject.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETutorialComboItemState                 InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialComboItemObject::SetState(ETutorialComboItemState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialComboItemObject", "SetState");

	Params::TutorialComboItemObject_SetState Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MiscFunctions.DrawFoliageCollision
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   CenterPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMiscFunctions::DrawFoliageCollision(class UObject* WorldContextObject, const struct FVector& CenterPosition, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscFunctions", "DrawFoliageCollision");

	Params::MiscFunctions_DrawFoliageCollision Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CenterPosition = std::move(CenterPosition);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MiscFunctions.EnumToString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Enum                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EnumValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FString UMiscFunctions::EnumToString(const class FString& Enum, int32 EnumValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscFunctions", "EnumToString");

	Params::MiscFunctions_EnumToString Parms{};

	Parms.Enum = std::move(Enum);
	Parms.EnumValue = EnumValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MiscFunctions.EquallySoftObjectReferenceByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TSoftObjectPtr<class UObject>&    A                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UObject>&    B                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMiscFunctions::EquallySoftObjectReferenceByName(const TSoftObjectPtr<class UObject>& A, const TSoftObjectPtr<class UObject>& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscFunctions", "EquallySoftObjectReferenceByName");

	Params::MiscFunctions_EquallySoftObjectReferenceByName Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MiscFunctions.GetSurfaceSound
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       SurfaceSoundsTable                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      SoundTypeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        Surface                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase**                      OutSound                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMiscFunctions::GetSurfaceSound(class UDataTable* SurfaceSoundsTable, const class FName& SoundTypeName, EPhysicalSurface Surface, class USoundBase** OutSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscFunctions", "GetSurfaceSound");

	Params::MiscFunctions_GetSurfaceSound Parms{};

	Parms.SurfaceSoundsTable = SurfaceSoundsTable;
	Parms.SoundTypeName = SoundTypeName;
	Parms.Surface = Surface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSound != nullptr)
		*OutSound = Parms.OutSound;

	return Parms.ReturnValue;
}


// Function Smuta.MiscFunctions.GetSystemInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPCSystemInfo*                   SystemInfo                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UMiscFunctions::GetSystemInfo(struct FPCSystemInfo* SystemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscFunctions", "GetSystemInfo");

	Params::MiscFunctions_GetSystemInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SystemInfo != nullptr)
		*SystemInfo = std::move(Parms.SystemInfo);
}


// Function Smuta.MiscFunctions.LogError
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ErrorMessage                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMiscFunctions::LogError(const class FString& ErrorMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscFunctions", "LogError");

	Params::MiscFunctions_LogError Parms{};

	Parms.ErrorMessage = std::move(ErrorMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MiscFunctions.MyGetStreamingLevels
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UMiscFunctions::MyGetStreamingLevels(class UObject* WorldContextObject, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscFunctions", "MyGetStreamingLevels");

	Params::MiscFunctions_MyGetStreamingLevels Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function Smuta.MiscFunctions.ResolveComponentReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FSoftComponentReference&   ComponentReference                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UMiscFunctions::ResolveComponentReference(const struct FSoftComponentReference& ComponentReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscFunctions", "ResolveComponentReference");

	Params::MiscFunctions_ResolveComponentReference Parms{};

	Parms.ComponentReference = std::move(ComponentReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MiscFunctions.StringToEnum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Enum                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    EnumString                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UMiscFunctions::StringToEnum(const class FString& Enum, const class FString& EnumString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscFunctions", "StringToEnum");

	Params::MiscFunctions_StringToEnum Parms{};

	Parms.Enum = std::move(Enum);
	Parms.EnumString = std::move(EnumString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MiscFunctions.WorldPositionToScreenHorizontal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          Controller                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldPosition                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMiscFunctions::WorldPositionToScreenHorizontal(const class APlayerController* Controller, const struct FVector& WorldPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscFunctions", "WorldPositionToScreenHorizontal");

	Params::MiscFunctions_WorldPositionToScreenHorizontal Parms{};

	Parms.Controller = Controller;
	Parms.WorldPosition = std::move(WorldPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MiscThreadSafeFunctions.GetAngularVelocityInDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPrimitiveComponent*        Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMiscThreadSafeFunctions::GetAngularVelocityInDegrees(const class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscThreadSafeFunctions", "GetAngularVelocityInDegrees");

	Params::MiscThreadSafeFunctions_GetAngularVelocityInDegrees Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MiscThreadSafeFunctions.GetFloorNormalFromFindFloor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FFindFloorResult&          FloorResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector UMiscThreadSafeFunctions::GetFloorNormalFromFindFloor(const struct FFindFloorResult& FloorResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MiscThreadSafeFunctions", "GetFloorNormalFromFindFloor");

	Params::MiscThreadSafeFunctions_GetFloorNormalFromFindFloor Parms{};

	Parms.FloorResult = std::move(FloorResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.MovableActorBase.OnInteract
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InteractedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMovableActorBase::OnInteract(class AActor* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovableActorBase", "OnInteract");

	Params::MovableActorBase_OnInteract Parms{};

	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MovementStats.OnRep_MoveSpeed
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMovementStats::OnRep_MoveSpeed(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementStats", "OnRep_MoveSpeed");

	Params::MovementStats_OnRep_MoveSpeed Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MovementStats.OnRep_RunSpeed
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMovementStats::OnRep_RunSpeed(const struct FGameplayAttributeData& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementStats", "OnRep_RunSpeed");

	Params::MovementStats_OnRep_RunSpeed Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NarrativePhraseArea.OverlapResponse
// (Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANarrativePhraseArea::OverlapResponse(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NarrativePhraseArea", "OverlapResponse");

	Params::NarrativePhraseArea_OverlapResponse Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NoiseModifiersDataAsset.ApplyModifiersForNoise
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InNoise                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        Surface                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoiseModifiersDataAsset::ApplyModifiersForNoise(float InNoise, EPhysicalSurface Surface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoiseModifiersDataAsset", "ApplyModifiersForNoise");

	Params::NoiseModifiersDataAsset_ApplyModifiersForNoise Parms{};

	Parms.InNoise = InNoise;
	Parms.Surface = Surface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCAppearanceItem.GetDefaultBattleSubAnimClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> UNPCAppearanceItem::GetDefaultBattleSubAnimClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAppearanceItem", "GetDefaultBattleSubAnimClass");

	Params::NPCAppearanceItem_GetDefaultBattleSubAnimClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCAppearanceItem.GetDefaultCalmSubAnimClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> UNPCAppearanceItem::GetDefaultCalmSubAnimClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAppearanceItem", "GetDefaultCalmSubAnimClass");

	Params::NPCAppearanceItem_GetDefaultCalmSubAnimClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCAppearanceItem.GetDefaultFleeSubAnimClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> UNPCAppearanceItem::GetDefaultFleeSubAnimClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAppearanceItem", "GetDefaultFleeSubAnimClass");

	Params::NPCAppearanceItem_GetDefaultFleeSubAnimClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCAppearanceItem.GetDefaultSearchSubAnimClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> UNPCAppearanceItem::GetDefaultSearchSubAnimClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAppearanceItem", "GetDefaultSearchSubAnimClass");

	Params::NPCAppearanceItem_GetDefaultSearchSubAnimClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCAppearanceItem.GetSlotBattleSubAnimClass
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EEquipmentSlotType&               Slot                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> UNPCAppearanceItem::GetSlotBattleSubAnimClass(const EEquipmentSlotType& Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAppearanceItem", "GetSlotBattleSubAnimClass");

	Params::NPCAppearanceItem_GetSlotBattleSubAnimClass Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCAppearanceItem.GetSlotCalmSubAnimClass
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EEquipmentSlotType&               Slot                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> UNPCAppearanceItem::GetSlotCalmSubAnimClass(const EEquipmentSlotType& Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAppearanceItem", "GetSlotCalmSubAnimClass");

	Params::NPCAppearanceItem_GetSlotCalmSubAnimClass Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCAppearanceItem.GetSlotFleeSubAnimClass
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EEquipmentSlotType&               Slot                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> UNPCAppearanceItem::GetSlotFleeSubAnimClass(const EEquipmentSlotType& Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAppearanceItem", "GetSlotFleeSubAnimClass");

	Params::NPCAppearanceItem_GetSlotFleeSubAnimClass Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCAppearanceItem.GetSlotMovementSpeedPreset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EEquipmentSlotType&               Slot                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDataTableRowHandle              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDataTableRowHandle UNPCAppearanceItem::GetSlotMovementSpeedPreset(const EEquipmentSlotType& Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAppearanceItem", "GetSlotMovementSpeedPreset");

	Params::NPCAppearanceItem_GetSlotMovementSpeedPreset Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCAppearanceItem.GetSlotSearchSubAnimClass
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EEquipmentSlotType&               Slot                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> UNPCAppearanceItem::GetSlotSearchSubAnimClass(const EEquipmentSlotType& Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAppearanceItem", "GetSlotSearchSubAnimClass");

	Params::NPCAppearanceItem_GetSlotSearchSubAnimClass Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorPair.GetPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVertexActorPair::GetPlayRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorPair", "GetPlayRate");

	Params::VertexActorPair_GetPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorPair.GetTimeOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVertexActorPair::GetTimeOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorPair", "GetTimeOffset");

	Params::VertexActorPair_GetTimeOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorPair.GetVertexPairInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVertexPairInfo>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVertexPairInfo> AVertexActorPair::GetVertexPairInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorPair", "GetVertexPairInfo");

	Params::VertexActorPair_GetVertexPairInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorPair.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewPlayRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActorPair::SetPlayRate(float NewPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorPair", "SetPlayRate");

	Params::VertexActorPair_SetPlayRate Parms{};

	Parms.NewPlayRate = NewPlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActorPair.SetTimeOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTimeOffset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActorPair::SetTimeOffset(float NewTimeOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorPair", "SetTimeOffset");

	Params::VertexActorPair_SetTimeOffset Parms{};

	Parms.NewTimeOffset = NewTimeOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActorPair.SetVertexPairInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FVertexPairInfo>&   PairInfos                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void AVertexActorPair::SetVertexPairInfo(const TArray<struct FVertexPairInfo>& PairInfos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorPair", "SetVertexPairInfo");

	Params::VertexActorPair_SetVertexPairInfo Parms{};

	Parms.PairInfos = std::move(PairInfos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCComboActionData.GetAnimMetaData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimMetaData>        DataTypeClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimMontage>      Montage                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMetaData*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMetaData* UNPCComboActionData::GetAnimMetaData(TSubclassOf<class UAnimMetaData> DataTypeClass, TSoftObjectPtr<class UAnimMontage> Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NPCComboActionData", "GetAnimMetaData");

	Params::NPCComboActionData_GetAnimMetaData Parms{};

	Parms.DataTypeClass = DataTypeClass;
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCComboActionData.GetAnimMetaDataFromMontagePtr
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimMetaData>        DataTypeClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMetaData*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMetaData* UNPCComboActionData::GetAnimMetaDataFromMontagePtr(TSubclassOf<class UAnimMetaData> DataTypeClass, class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NPCComboActionData", "GetAnimMetaDataFromMontagePtr");

	Params::NPCComboActionData_GetAnimMetaDataFromMontagePtr Parms{};

	Parms.DataTypeClass = DataTypeClass;
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCComboActionData.GetAnyCombo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceRestriction                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UComboDescription*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UComboDescription* UNPCComboActionData::GetAnyCombo(EEquipmentType Type, float DistanceRestriction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCComboActionData", "GetAnyCombo");

	Params::NPCComboActionData_GetAnyCombo Parms{};

	Parms.Type = Type;
	Parms.DistanceRestriction = DistanceRestriction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCComboActionData.GetCounterCombo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceRestriction                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UComboDescription*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UComboDescription* UNPCComboActionData::GetCounterCombo(EEquipmentType Type, float DistanceRestriction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCComboActionData", "GetCounterCombo");

	Params::NPCComboActionData_GetCounterCombo Parms{};

	Parms.Type = Type;
	Parms.DistanceRestriction = DistanceRestriction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCComboActionData.GetDefaultCombo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceRestriction                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UComboDescription*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UComboDescription* UNPCComboActionData::GetDefaultCombo(EEquipmentType Type, float DistanceRestriction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCComboActionData", "GetDefaultCombo");

	Params::NPCComboActionData_GetDefaultCombo Parms{};

	Parms.Type = Type;
	Parms.DistanceRestriction = DistanceRestriction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCComboActionData.GetMixedCombo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceRestriction                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UComboDescription*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UComboDescription* UNPCComboActionData::GetMixedCombo(EEquipmentType Type, float DistanceRestriction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCComboActionData", "GetMixedCombo");

	Params::NPCComboActionData_GetMixedCombo Parms{};

	Parms.Type = Type;
	Parms.DistanceRestriction = DistanceRestriction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCComboActionData.GetUblockableCombo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceRestriction                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UComboDescription*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UComboDescription* UNPCComboActionData::GetUblockableCombo(EEquipmentType Type, float DistanceRestriction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCComboActionData", "GetUblockableCombo");

	Params::NPCComboActionData_GetUblockableCombo Parms{};

	Parms.Type = Type;
	Parms.DistanceRestriction = DistanceRestriction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCComboActionData.GetUnparryCombo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceRestriction                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UComboDescription*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UComboDescription* UNPCComboActionData::GetUnparryCombo(EEquipmentType Type, float DistanceRestriction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCComboActionData", "GetUnparryCombo");

	Params::NPCComboActionData_GetUnparryCombo Parms{};

	Parms.Type = Type;
	Parms.DistanceRestriction = DistanceRestriction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCComboActionData.HasCombo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceRestriction                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCComboActionData::HasCombo(EEquipmentType Type, float DistanceRestriction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCComboActionData", "HasCombo");

	Params::NPCComboActionData_HasCombo Parms{};

	Parms.Type = Type;
	Parms.DistanceRestriction = DistanceRestriction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCDialogueComponent.DoesDialogueContainParticipants
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class AActor*>&            PossibleDialogueParticipants                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UDlgDialogue*                     Dialogue                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCDialogueComponent::DoesDialogueContainParticipants(const TArray<class AActor*>& PossibleDialogueParticipants, class UDlgDialogue* Dialogue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NPCDialogueComponent", "DoesDialogueContainParticipants");

	Params::NPCDialogueComponent_DoesDialogueContainParticipants Parms{};

	Parms.PossibleDialogueParticipants = std::move(PossibleDialogueParticipants);
	Parms.Dialogue = Dialogue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCDialogueComponent.CanEnterDialogue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCDialogueComponent::CanEnterDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "CanEnterDialogue");

	Params::NPCDialogueComponent_CanEnterDialogue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCDialogueComponent.ChangeDialogueAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UDlgDialogue>      NewDialogue                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCDialogueComponent::ChangeDialogueAsset(TSoftObjectPtr<class UDlgDialogue> NewDialogue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "ChangeDialogueAsset");

	Params::NPCDialogueComponent_ChangeDialogueAsset Parms{};

	Parms.NewDialogue = NewDialogue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCDialogueComponent.CouldBeDialogueTargetFor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADefaultCharacter*                PossibleDialogueTarget                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDlgDialogue*                     Dialogue                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCDialogueComponent::CouldBeDialogueTargetFor(class ADefaultCharacter* PossibleDialogueTarget, class UDlgDialogue* Dialogue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "CouldBeDialogueTargetFor");

	Params::NPCDialogueComponent_CouldBeDialogueTargetFor Parms{};

	Parms.PossibleDialogueTarget = PossibleDialogueTarget;
	Parms.Dialogue = Dialogue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCDialogueComponent.GetDialogueTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADefaultCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADefaultCharacter* UNPCDialogueComponent::GetDialogueTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "GetDialogueTarget");

	Params::NPCDialogueComponent_GetDialogueTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCDialogueComponent.GetDialogueToSpeak
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDlgDialogue*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDlgDialogue* UNPCDialogueComponent::GetDialogueToSpeak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "GetDialogueToSpeak");

	Params::NPCDialogueComponent_GetDialogueToSpeak Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCDialogueComponent.GetParticipantNameByVoiceTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString*                          OutName                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCDialogueComponent::GetParticipantNameByVoiceTag(class FString* OutName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "GetParticipantNameByVoiceTag");

	Params::NPCDialogueComponent_GetParticipantNameByVoiceTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutName != nullptr)
		*OutName = std::move(Parms.OutName);
}


// Function Smuta.NPCDialogueComponent.HandleOverlapDialogueArea
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNPCDialogueComponent::HandleOverlapDialogueArea(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "HandleOverlapDialogueArea");

	Params::NPCDialogueComponent_HandleOverlapDialogueArea Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCDialogueComponent.HasDialogueToSpeak
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCDialogueComponent::HasDialogueToSpeak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "HasDialogueToSpeak");

	Params::NPCDialogueComponent_HasDialogueToSpeak Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCDialogueComponent.InitiateDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADefaultCharacter*                OtherCharacter                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDlgDialogue*                     Dialogue                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSearchPoint                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCDialogueComponent::InitiateDialogue(class ADefaultCharacter* OtherCharacter, class UDlgDialogue* Dialogue, bool bSearchPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "InitiateDialogue");

	Params::NPCDialogueComponent_InitiateDialogue Parms{};

	Parms.OtherCharacter = OtherCharacter;
	Parms.Dialogue = Dialogue;
	Parms.bSearchPoint = bSearchPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCDialogueComponent.InitiateMonologue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDlgDialogue*                     Monologue                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCDialogueComponent::InitiateMonologue(class UDlgDialogue* Monologue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "InitiateMonologue");

	Params::NPCDialogueComponent_InitiateMonologue Parms{};

	Parms.Monologue = Monologue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCDialogueComponent.SetDialogueTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADefaultCharacter*                NewDialogueTarget                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCDialogueComponent::SetDialogueTarget(class ADefaultCharacter* NewDialogueTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "SetDialogueTarget");

	Params::NPCDialogueComponent_SetDialogueTarget Parms{};

	Parms.NewDialogueTarget = NewDialogueTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCDialogueComponent.SetReadyForDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewReady                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCDialogueComponent::SetReadyForDialogue(bool NewReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueComponent", "SetReadyForDialogue");

	Params::NPCDialogueComponent_SetReadyForDialogue Parms{};

	Parms.NewReady = NewReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCDialogueSystemHelper.FindDialoguePointByEQS
// (Event, Public, BlueprintEvent)

void ANPCDialogueSystemHelper::FindDialoguePointByEQS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueSystemHelper", "FindDialoguePointByEQS");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.NPCDialogueSystemHelper.FinishDialogue
// (Event, Protected, BlueprintEvent)

void ANPCDialogueSystemHelper::FinishDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueSystemHelper", "FinishDialogue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.NPCDialogueSystemHelper.HandleParticipantReady
// (Final, Native, Protected)
// Parameters:
// class UNPCDialogueComponent*            Participant                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewReady                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCDialogueSystemHelper::HandleParticipantReady(class UNPCDialogueComponent* Participant, bool NewReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueSystemHelper", "HandleParticipantReady");

	Params::NPCDialogueSystemHelper_HandleParticipantReady Parms{};

	Parms.Participant = Participant;
	Parms.NewReady = NewReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCDialogueSystemHelper.NativeFinishDialogue
// (Final, Native, Public, BlueprintCallable)

void ANPCDialogueSystemHelper::NativeFinishDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueSystemHelper", "NativeFinishDialogue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCDialogueSystemHelper.OnParticipantTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exists                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCDialogueSystemHelper::OnParticipantTagChanged(const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueSystemHelper", "OnParticipantTagChanged");

	Params::NPCDialogueSystemHelper_OnParticipantTagChanged Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCDialogueSystemHelper.SetupDialogueLocation
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCDialogueSystemHelper::SetupDialogueLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueSystemHelper", "SetupDialogueLocation");

	Params::NPCDialogueSystemHelper_SetupDialogueLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCDialogueSystemHelper.StartDialogue
// (Event, Protected, BlueprintEvent)

void ANPCDialogueSystemHelper::StartDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCDialogueSystemHelper", "StartDialogue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.VertexActor.GetAnimationLenght
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVertexActor::GetAnimationLenght()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetAnimationLenght");

	Params::VertexActor_GetAnimationLenght Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetCurrentFrame
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AVertexActor::GetCurrentFrame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetCurrentFrame");

	Params::VertexActor_GetCurrentFrame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetCurrentTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVertexActor::GetCurrentTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetCurrentTime");

	Params::VertexActor_GetCurrentTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetFrameOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVertexActor::GetFrameOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetFrameOffset");

	Params::VertexActor_GetFrameOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.IsPlayerCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ActorCheck                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVertexActor::IsPlayerCheck(class AActor* ActorCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "IsPlayerCheck");

	Params::VertexActor_IsPlayerCheck Parms{};

	Parms.ActorCheck = ActorCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.IsPlayerOverlap
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVertexActor::IsPlayerOverlap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "IsPlayerOverlap");

	Params::VertexActor_IsPlayerOverlap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.OnBeginOverlapPlayer
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              ThisComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AVertexActor::OnBeginOverlapPlayer(class UPrimitiveComponent* ThisComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "OnBeginOverlapPlayer");

	Params::VertexActor_OnBeginOverlapPlayer Parms{};

	Parms.ThisComp = ThisComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.OnEndOverlapPlayer
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              ThisComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::OnEndOverlapPlayer(class UPrimitiveComponent* ThisComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "OnEndOverlapPlayer");

	Params::VertexActor_OnEndOverlapPlayer Parms{};

	Parms.ThisComp = ThisComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.SetAnimationIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetAnimationIndex(int32 NewIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetAnimationIndex");

	Params::VertexActor_SetAnimationIndex Parms{};

	Parms.NewIndex = NewIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.SetHideItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    HideItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetHideItem(bool HideItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetHideItem");

	Params::VertexActor_SetHideItem Parms{};

	Parms.HideItem = HideItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.SetOverrideSFX
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundWave*                       NewOverride                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetOverrideSFX(class USoundWave* NewOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetOverrideSFX");

	Params::VertexActor_SetOverrideSFX Parms{};

	Parms.NewOverride = NewOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.SetOverrideVoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundWave*                       NewOverride                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetOverrideVoice(class USoundWave* NewOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetOverrideVoice");

	Params::VertexActor_SetOverrideVoice Parms{};

	Parms.NewOverride = NewOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewPlayRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetPlayRate(float NewPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetPlayRate");

	Params::VertexActor_SetPlayRate Parms{};

	Parms.NewPlayRate = NewPlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.SetPlaySound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    PlaySound                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetPlaySound(bool PlaySound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetPlaySound");

	Params::VertexActor_SetPlaySound Parms{};

	Parms.PlaySound = PlaySound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.SetPlayVoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    PlayVoice                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetPlayVoice(bool PlayVoice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetPlayVoice");

	Params::VertexActor_SetPlayVoice Parms{};

	Parms.PlayVoice = PlayVoice;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.SetTimeOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTimeOffset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetTimeOffset(float NewTimeOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetTimeOffset");

	Params::VertexActor_SetTimeOffset Parms{};

	Parms.NewTimeOffset = NewTimeOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.SetVertexData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVertexAsset*                     NewVertexData                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetVertexData(class UVertexAsset* NewVertexData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetVertexData");

	Params::VertexActor_SetVertexData Parms{};

	Parms.NewVertexData = NewVertexData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.ToggleSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::ToggleSound(bool Activate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "ToggleSound");

	Params::VertexActor_ToggleSound Parms{};

	Parms.Activate = Activate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.GetAnimationIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AVertexActor::GetAnimationIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetAnimationIndex");

	Params::VertexActor_GetAnimationIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetAudioComponentSFX
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* AVertexActor::GetAudioComponentSFX() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetAudioComponentSFX");

	Params::VertexActor_GetAudioComponentSFX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetAudioComponentVoice
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* AVertexActor::GetAudioComponentVoice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetAudioComponentVoice");

	Params::VertexActor_GetAudioComponentVoice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetAudioTriggerComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USphereComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USphereComponent* AVertexActor::GetAudioTriggerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetAudioTriggerComponent");

	Params::VertexActor_GetAudioTriggerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetCollisionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCapsuleComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCapsuleComponent* AVertexActor::GetCollisionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetCollisionComponent");

	Params::VertexActor_GetCollisionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetHideItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVertexActor::GetHideItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetHideItem");

	Params::VertexActor_GetHideItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetOverrideSFX
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoundWave*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundWave* AVertexActor::GetOverrideSFX() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetOverrideSFX");

	Params::VertexActor_GetOverrideSFX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetOverrideVoice
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoundWave*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundWave* AVertexActor::GetOverrideVoice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetOverrideVoice");

	Params::VertexActor_GetOverrideVoice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVertexActor::GetPlayRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetPlayRate");

	Params::VertexActor_GetPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetPlaySound
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVertexActor::GetPlaySound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetPlaySound");

	Params::VertexActor_GetPlaySound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetPlayVoice
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVertexActor::GetPlayVoice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetPlayVoice");

	Params::VertexActor_GetPlayVoice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetStaticMeshBodyComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* AVertexActor::GetStaticMeshBodyComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetStaticMeshBodyComponent");

	Params::VertexActor_GetStaticMeshBodyComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetStaticMeshItemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* AVertexActor::GetStaticMeshItemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetStaticMeshItemComponent");

	Params::VertexActor_GetStaticMeshItemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetTimeOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVertexActor::GetTimeOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetTimeOffset");

	Params::VertexActor_GetTimeOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.GetVertexData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVertexAsset*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVertexAsset* AVertexActor::GetVertexData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "GetVertexData");

	Params::VertexActor_GetVertexData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActor.SetAllComponentMobility
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// EComponentMobility                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetAllComponentMobility(EComponentMobility Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetAllComponentMobility");

	Params::VertexActor_SetAllComponentMobility Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.SetCustomDataBody
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// int32                                   NewFrameOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewStartFrame                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewEndFrame                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewPlayRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewFrameRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetCustomDataBody(int32 NewFrameOffset, int32 NewStartFrame, int32 NewEndFrame, float NewPlayRate, int32 NewFrameRate) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetCustomDataBody");

	Params::VertexActor_SetCustomDataBody Parms{};

	Parms.NewFrameOffset = NewFrameOffset;
	Parms.NewStartFrame = NewStartFrame;
	Parms.NewEndFrame = NewEndFrame;
	Parms.NewPlayRate = NewPlayRate;
	Parms.NewFrameRate = NewFrameRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActor.SetCustomDataItem
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// int32                                   NewFrameOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewStartFrame                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewEndFrame                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewPlayRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewFrameRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActor::SetCustomDataItem(int32 NewFrameOffset, int32 NewStartFrame, int32 NewEndFrame, float NewPlayRate, int32 NewFrameRate) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActor", "SetCustomDataItem");

	Params::VertexActor_SetCustomDataItem Parms{};

	Parms.NewFrameOffset = NewFrameOffset;
	Parms.NewStartFrame = NewStartFrame;
	Parms.NewEndFrame = NewEndFrame;
	Parms.NewPlayRate = NewPlayRate;
	Parms.NewFrameRate = NewFrameRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCEquipmentItemAdditionalAnimSettings_Simple.GetNPCEquipmentItemAnimData
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNPCEquipmentItemAnimData        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNPCEquipmentItemAnimData UNPCEquipmentItemAdditionalAnimSettings_Simple::GetNPCEquipmentItemAnimData(class AActor* OwningActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCEquipmentItemAdditionalAnimSettings_Simple", "GetNPCEquipmentItemAnimData");

	Params::NPCEquipmentItemAdditionalAnimSettings_Simple_GetNPCEquipmentItemAnimData Parms{};

	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCMasterAnimInstance.FinishUnlinkLayer
// (Final, Native, Protected)

void UNPCMasterAnimInstance::FinishUnlinkLayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCMasterAnimInstance", "FinishUnlinkLayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCMasterAnimInstance.OnActiveSlotChanged
// (Final, Native, Protected)
// Parameters:
// class UBaseEquipmentSet*                Slot                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCMasterAnimInstance::OnActiveSlotChanged(class UBaseEquipmentSet* Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCMasterAnimInstance", "OnActiveSlotChanged");

	Params::NPCMasterAnimInstance_OnActiveSlotChanged Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCMasterAnimInstance.OnBehaviorStateChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const ENPCBehaviorState&                PreviousBehaviorState                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENPCBehaviorState&                CurrentBehaviorState                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCMasterAnimInstance::OnBehaviorStateChanged(const ENPCBehaviorState& PreviousBehaviorState, const ENPCBehaviorState& CurrentBehaviorState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCMasterAnimInstance", "OnBehaviorStateChanged");

	Params::NPCMasterAnimInstance_OnBehaviorStateChanged Parms{};

	Parms.PreviousBehaviorState = PreviousBehaviorState;
	Parms.CurrentBehaviorState = CurrentBehaviorState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCMasterAnimInstance.OnGroundMovementModeChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const EGroundMovementMode&              PreviousGroundMovementMode                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EGroundMovementMode&              CurrentGroundMovementMode                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCMasterAnimInstance::OnGroundMovementModeChanged(const EGroundMovementMode& PreviousGroundMovementMode, const EGroundMovementMode& CurrentGroundMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCMasterAnimInstance", "OnGroundMovementModeChanged");

	Params::NPCMasterAnimInstance_OnGroundMovementModeChanged Parms{};

	Parms.PreviousGroundMovementMode = PreviousGroundMovementMode;
	Parms.CurrentGroundMovementMode = CurrentGroundMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCMasterAnimInstance.OnMovementStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    InMove                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCMasterAnimInstance::OnMovementStateChanged(bool InMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCMasterAnimInstance", "OnMovementStateChanged");

	Params::NPCMasterAnimInstance_OnMovementStateChanged Parms{};

	Parms.InMove = InMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCMasterAnimInstance.GetRootMotionMode
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERootMotionMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERootMotionMode UNPCMasterAnimInstance::GetRootMotionMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCMasterAnimInstance", "GetRootMotionMode");

	Params::NPCMasterAnimInstance_GetRootMotionMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.WaitTutorialHintCondition.OnHintClosed
// (Final, Native, Private, HasOutParams)
// Parameters:
// const class FName&                      InHintName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaitTutorialHintCondition::OnHintClosed(const class FName& InHintName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaitTutorialHintCondition", "OnHintClosed");

	Params::WaitTutorialHintCondition_OnHintClosed Parms{};

	Parms.InHintName = InHintName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCReactionComponent.ApplyAttitudeChangingEffect
// (Final, Native, Protected)

void UNPCReactionComponent::ApplyAttitudeChangingEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCReactionComponent", "ApplyAttitudeChangingEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCReactionComponent.HandleSmartObjectInteractFinished
// (Final, Native, Protected)
// Parameters:
// bool                                    bResult                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCReactionComponent::HandleSmartObjectInteractFinished(bool bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCReactionComponent", "HandleSmartObjectInteractFinished");

	Params::NPCReactionComponent_HandleSmartObjectInteractFinished Parms{};

	Parms.bResult = bResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCReactionComponent.OnMonologueActiveChangedCallback
// (Final, Native, Private)
// Parameters:
// class UNPCDialogueComponent*            DialogueComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewStatus                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCReactionComponent::OnMonologueActiveChangedCallback(class UNPCDialogueComponent* DialogueComponent, bool NewStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCReactionComponent", "OnMonologueActiveChangedCallback");

	Params::NPCReactionComponent_OnMonologueActiveChangedCallback Parms{};

	Parms.DialogueComponent = DialogueComponent;
	Parms.NewStatus = NewStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCReactionComponent.OnMontageEndedCallback
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCReactionComponent::OnMontageEndedCallback(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCReactionComponent", "OnMontageEndedCallback");

	Params::NPCReactionComponent_OnMontageEndedCallback Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCReactionComponent.OnOwnerTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exists                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCReactionComponent::OnOwnerTagChanged(const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCReactionComponent", "OnOwnerTagChanged");

	Params::NPCReactionComponent_OnOwnerTagChanged Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCReactionComponent.StartCurrentReaction
// (Final, Native, Protected)

void UNPCReactionComponent::StartCurrentReaction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCReactionComponent", "StartCurrentReaction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ZastavaBase.ActivateSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASpawnerPointZastava*             Point                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEnemyData&                EnemyData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AZastavaBase::ActivateSpawn(class ASpawnerPointZastava* Point, const struct FEnemyData& EnemyData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZastavaBase", "ActivateSpawn");

	Params::ZastavaBase_ActivateSpawn Parms{};

	Parms.Point = Point;
	Parms.EnemyData = std::move(EnemyData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ZastavaBase.DeactivateSpawn
// (Final, Native, Public, BlueprintCallable)

void AZastavaBase::DeactivateSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZastavaBase", "DeactivateSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ZastavaBase.RotationOffset
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     RVector                                                (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AZastavaBase::RotationOffset(const struct FVector& Location, const struct FQuat& RVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZastavaBase", "RotationOffset");

	Params::ZastavaBase_RotationOffset Parms{};

	Parms.Location = std::move(Location);
	Parms.RVector = std::move(RVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ZastavaBase.SetAlarm
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZastavaBase::SetAlarm(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZastavaBase", "SetAlarm");

	Params::ZastavaBase_SetAlarm Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ZastavaMain.ChangeFractionAfterCapture
// (Final, Native, Protected, BlueprintCallable)

void AZastavaMain::ChangeFractionAfterCapture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZastavaMain", "ChangeFractionAfterCapture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ZastavaMain.GetDNCClass
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AZastavaMain::GetDNCClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZastavaMain", "GetDNCClass");

	Params::ZastavaMain_GetDNCClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.ZastavaMain.ResetPatrolsSpawn
// (Final, Native, Protected, BlueprintCallable)

void AZastavaMain::ResetPatrolsSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZastavaMain", "ResetPatrolsSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ZastavaMain.ResetPoints
// (Final, Native, Protected, BlueprintCallable)

void AZastavaMain::ResetPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZastavaMain", "ResetPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ZastavaMain.SubZastavsCaptured
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AZastavaMain::SubZastavsCaptured()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZastavaMain", "SubZastavsCaptured");

	Params::ZastavaMain_SubZastavsCaptured Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCStateComponent.BindOnFightStart
// (Final, Native, Protected)

void UNPCStateComponent::BindOnFightStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCStateComponent", "BindOnFightStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCStateComponent.BindOnFleeStart
// (Final, Native, Protected)

void UNPCStateComponent::BindOnFleeStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCStateComponent", "BindOnFleeStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCStateComponent.OnAgroTargetUpdated
// (Final, Native, Protected)
// Parameters:
// class AActor*                           NewAgroTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCStateComponent::OnAgroTargetUpdated(class AActor* NewAgroTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCStateComponent", "OnAgroTargetUpdated");

	Params::NPCStateComponent_OnAgroTargetUpdated Parms{};

	Parms.NewAgroTarget = NewAgroTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCStateComponent.OnDetectionStateChanged
// (Final, Native, Protected)
// Parameters:
// class UEnemyDetectionComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetectionAIState                       NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCStateComponent::OnDetectionStateChanged(class UEnemyDetectionComponent* Component, EDetectionAIState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCStateComponent", "OnDetectionStateChanged");

	Params::NPCStateComponent_OnDetectionStateChanged Parms{};

	Parms.Component = Component;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCStateComponent.SetState
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENPCBehaviorState&                NewState                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCStateComponent::SetState(const ENPCBehaviorState& NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCStateComponent", "SetState");

	Params::NPCStateComponent_SetState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.NPCStateComponent.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENPCBehaviorState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENPCBehaviorState UNPCStateComponent::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCStateComponent", "GetState");

	Params::NPCStateComponent_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCStatesWorldSubsystem.OnNPCTagChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exists                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCStatesWorldSubsystem::OnNPCTagChanged(class UAbilitySystemComponent* ASC, const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCStatesWorldSubsystem", "OnNPCTagChanged");

	Params::NPCStatesWorldSubsystem_OnNPCTagChanged Parms{};

	Parms.ASC = ASC;
	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.WorldMapBorderActor.GetDiagonalPoints
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector*                         Point1                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         Point2                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWorldMapBorderActor::GetDiagonalPoints(struct FVector* Point1, struct FVector* Point2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldMapBorderActor", "GetDiagonalPoints");

	Params::WorldMapBorderActor_GetDiagonalPoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Point1 != nullptr)
		*Point1 = std::move(Parms.Point1);

	if (Point2 != nullptr)
		*Point2 = std::move(Parms.Point2);
}


// Function Smuta.WorldMapBorderActor.GetMapSize
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AWorldMapBorderActor::GetMapSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldMapBorderActor", "GetMapSize");

	Params::WorldMapBorderActor_GetMapSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Smuta.WorldMapBorderActor.IsLocationInside
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWorldMapBorderActor::IsLocationInside(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldMapBorderActor", "IsLocationInside");

	Params::WorldMapBorderActor_IsLocationInside Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.NPCSubAnimInstance_BattleBase.GetEquipmentDefenceStyle
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentDefenceStyle                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEquipmentDefenceStyle UNPCSubAnimInstance_BattleBase::GetEquipmentDefenceStyle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCSubAnimInstance_BattleBase", "GetEquipmentDefenceStyle");

	Params::NPCSubAnimInstance_BattleBase_GetEquipmentDefenceStyle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.PlayerBattleStateController.AddActiveBattleStateTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerBattleStateController::AddActiveBattleStateTrigger(const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBattleStateController", "AddActiveBattleStateTrigger");

	Params::PlayerBattleStateController_AddActiveBattleStateTrigger Parms{};

	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.PlayerBattleStateController.EnterBattle
// (Final, Native, Public, BlueprintCallable)

void UPlayerBattleStateController::EnterBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBattleStateController", "EnterBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.PlayerBattleStateController.ForceLeaveBattle
// (Final, Native, Public, BlueprintCallable)

void UPlayerBattleStateController::ForceLeaveBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBattleStateController", "ForceLeaveBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.PlayerBattleStateController.LeaveBattle
// (Final, Native, Public)

void UPlayerBattleStateController::LeaveBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBattleStateController", "LeaveBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.PlayerBattleStateController.OnOwnerASCTagUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              UpdatedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exists                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerBattleStateController::OnOwnerASCTagUpdated(const struct FGameplayTag& UpdatedTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBattleStateController", "OnOwnerASCTagUpdated");

	Params::PlayerBattleStateController_OnOwnerASCTagUpdated Parms{};

	Parms.UpdatedTag = std::move(UpdatedTag);
	Parms.Exists = Exists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.PlayerBattleStateController.RemoveActiveBattleStateTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerBattleStateController::RemoveActiveBattleStateTrigger(const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBattleStateController", "RemoveActiveBattleStateTrigger");

	Params::PlayerBattleStateController_RemoveActiveBattleStateTrigger Parms{};

	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.PlayerBattleStateController.SetCanEnterBattle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewCanEnterBattle                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerBattleStateController::SetCanEnterBattle(bool bNewCanEnterBattle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBattleStateController", "SetCanEnterBattle");

	Params::PlayerBattleStateController_SetCanEnterBattle Parms{};

	Parms.bNewCanEnterBattle = bNewCanEnterBattle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.PlayerBattleStateController.UpdateActiveBattleBlockers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exists                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerBattleStateController::UpdateActiveBattleBlockers(const struct FGameplayTag& GameplayTag, bool Exists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBattleStateController", "UpdateActiveBattleBlockers");

	Params::PlayerBattleStateController_UpdateActiveBattleBlockers Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.Exists = Exists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.PlayerBattleStateController.CanEnterBattle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerBattleStateController::CanEnterBattle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBattleStateController", "CanEnterBattle");

	Params::PlayerBattleStateController_CanEnterBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.PostProcessManager.AddPostEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EPostProcessType                  Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPostProcessManager::AddPostEffect(const EPostProcessType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessManager", "AddPostEffect");

	Params::PostProcessManager_AddPostEffect Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.PostProcessManager.PlayerTagChangedResponse
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              ChangedTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExists                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessManager::PlayerTagChangedResponse(const struct FGameplayTag& ChangedTag, bool bExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessManager", "PlayerTagChangedResponse");

	Params::PostProcessManager_PlayerTagChangedResponse Parms{};

	Parms.ChangedTag = std::move(ChangedTag);
	Parms.bExists = bExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.PostProcessManager.RemovePostEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EPostProcessType                  Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPostProcessManager::RemovePostEffect(const EPostProcessType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessManager", "RemovePostEffect");

	Params::PostProcessManager_RemovePostEffect Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.QTE_StationBase.OnInteracted
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InteractedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQTE_StationBase::OnInteracted(class AActor* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QTE_StationBase", "OnInteracted");

	Params::QTE_StationBase_OnInteracted Parms{};

	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.QuestActionSaveMigrationHandler.RunQuestAction
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class UQuestStep*                       FromQuestStep                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestActionSaveMigrationHandler::RunQuestAction(class UQuestStep* FromQuestStep) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestActionSaveMigrationHandler", "RunQuestAction");

	Params::QuestActionSaveMigrationHandler_RunQuestAction Parms{};

	Parms.FromQuestStep = FromQuestStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SaveLoadSettings.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class USaveLoadSettings*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USaveLoadSettings* USaveLoadSettings::Get()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveLoadSettings", "Get");

	Params::SaveLoadSettings_Get Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SimpleInteractionActor.ChangeActorState
// (Native, Public, BlueprintCallable)
// Parameters:
// EInteractionActorState                  NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASimpleInteractionActor::ChangeActorState(EInteractionActorState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleInteractionActor", "ChangeActorState");

	Params::SimpleInteractionActor_ChangeActorState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SimpleInteractionActor.OnInteracted
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InteractedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASimpleInteractionActor::OnInteracted(class AActor* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleInteractionActor", "OnInteracted");

	Params::SimpleInteractionActor_OnInteracted Parms{};

	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SimpleInteractionActor.PostLogicChanged
// (Event, Public, BlueprintEvent)

void ASimpleInteractionActor::PostLogicChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleInteractionActor", "PostLogicChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.SimpleInteractionActor.PreLogicChanged
// (Event, Public, BlueprintEvent)

void ASimpleInteractionActor::PreLogicChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleInteractionActor", "PreLogicChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.SmutaBuildConfigSubsystem.GetBuildProjectType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBuildProjectType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBuildProjectType USmutaBuildConfigSubsystem::GetBuildProjectType(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmutaBuildConfigSubsystem", "GetBuildProjectType");

	Params::SmutaBuildConfigSubsystem_GetBuildProjectType Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaBuildConfigSubsystem.HandleSettingsDelegate
// (Final, Native, Protected)
// Parameters:
// class USentrySettings*                  Settings                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaBuildConfigSubsystem::HandleSettingsDelegate(class USentrySettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBuildConfigSubsystem", "HandleSettingsDelegate");

	Params::SmutaBuildConfigSubsystem_HandleSettingsDelegate Parms{};

	Parms.Settings = Settings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaBuildConfigSubsystem.InitVersion
// (Final, Native, Public, BlueprintCallable)

void USmutaBuildConfigSubsystem::InitVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBuildConfigSubsystem", "InitVersion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaBuildConfigSubsystem.GetBuildNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaBuildConfigSubsystem::GetBuildNumber() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBuildConfigSubsystem", "GetBuildNumber");

	Params::SmutaBuildConfigSubsystem_GetBuildNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaBuildConfigSubsystem.GetBuildVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USmutaBuildConfigSubsystem::GetBuildVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBuildConfigSubsystem", "GetBuildVersion");

	Params::SmutaBuildConfigSubsystem_GetBuildVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaBuildConfigSubsystem.GetProjectType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EBuildProjectType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBuildProjectType USmutaBuildConfigSubsystem::GetProjectType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBuildConfigSubsystem", "GetProjectType");

	Params::SmutaBuildConfigSubsystem_GetProjectType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaBuildConfigSubsystem.IsEducationBuild
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmutaBuildConfigSubsystem::IsEducationBuild() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaBuildConfigSubsystem", "IsEducationBuild");

	Params::SmutaBuildConfigSubsystem_IsEducationBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaCommonRotator.CallOnRotated
// (Final, Native, Public, BlueprintCallable)

void USmutaCommonRotator::CallOnRotated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaCommonRotator", "CallOnRotated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaDialogueSmartObject.AbortDialogue
// (Final, Native, Public, BlueprintCallable)

void ASmutaDialogueSmartObject::AbortDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaDialogueSmartObject", "AbortDialogue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaDialogueSmartObject.HandleDialogFinished
// (Final, Native, Public)

void ASmutaDialogueSmartObject::HandleDialogFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaDialogueSmartObject", "HandleDialogFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.GetScreenPercentageByQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USmutaGameUserSettings::GetScreenPercentageByQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SmutaGameUserSettings", "GetScreenPercentageByQuality");

	Params::SmutaGameUserSettings_GetScreenPercentageByQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.ResetToDefaultSettings
// (Final, Native, Public, BlueprintCallable)

void USmutaGameUserSettings::ResetToDefaultSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "ResetToDefaultSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetAntiAliasing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetAntiAliasing(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetAntiAliasing");

	Params::SmutaGameUserSettings_SetAntiAliasing Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetDLSS_FG
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetDLSS_FG(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetDLSS_FG");

	Params::SmutaGameUserSettings_SetDLSS_FG Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetFSR_FI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetFSR_FI(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetFSR_FI");

	Params::SmutaGameUserSettings_SetFSR_FI Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetGlobalIllumination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetGlobalIllumination(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetGlobalIllumination");

	Params::SmutaGameUserSettings_SetGlobalIllumination Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetLensFlare
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetLensFlare(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetLensFlare");

	Params::SmutaGameUserSettings_SetLensFlare Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetMotionBlur
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetMotionBlur(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetMotionBlur");

	Params::SmutaGameUserSettings_SetMotionBlur Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetNvidiaReflex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetNvidiaReflex(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetNvidiaReflex");

	Params::SmutaGameUserSettings_SetNvidiaReflex Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetPresetIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetPresetIndex(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetPresetIndex");

	Params::SmutaGameUserSettings_SetPresetIndex Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetReflection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetReflection(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetReflection");

	Params::SmutaGameUserSettings_SetReflection Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetScreenPercentageQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetScreenPercentageQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetScreenPercentageQuality");

	Params::SmutaGameUserSettings_SetScreenPercentageQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetSharpness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetSharpness(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetSharpness");

	Params::SmutaGameUserSettings_SetSharpness Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetVirtualShadowMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetVirtualShadowMap(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetVirtualShadowMap");

	Params::SmutaGameUserSettings_SetVirtualShadowMap Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.SetVolumetricFog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaGameUserSettings::SetVolumetricFog(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "SetVolumetricFog");

	Params::SmutaGameUserSettings_SetVolumetricFog Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaGameUserSettings.GetAntiAliasing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetAntiAliasing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetAntiAliasing");

	Params::SmutaGameUserSettings_GetAntiAliasing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetCurrentLookSensitivity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USmutaGameUserSettings::GetCurrentLookSensitivity(class UObject* WorldContextObject) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetCurrentLookSensitivity");

	Params::SmutaGameUserSettings_GetCurrentLookSensitivity Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetDLSS_FG
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetDLSS_FG() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetDLSS_FG");

	Params::SmutaGameUserSettings_GetDLSS_FG Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetFSR_FI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetFSR_FI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetFSR_FI");

	Params::SmutaGameUserSettings_GetFSR_FI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetGlobalIllumination
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetGlobalIllumination() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetGlobalIllumination");

	Params::SmutaGameUserSettings_GetGlobalIllumination Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetLensFlare
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetLensFlare() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetLensFlare");

	Params::SmutaGameUserSettings_GetLensFlare Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetMotionBlur
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetMotionBlur() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetMotionBlur");

	Params::SmutaGameUserSettings_GetMotionBlur Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetNvidiaReflex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetNvidiaReflex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetNvidiaReflex");

	Params::SmutaGameUserSettings_GetNvidiaReflex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetPresetIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetPresetIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetPresetIndex");

	Params::SmutaGameUserSettings_GetPresetIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetReflection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetReflection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetReflection");

	Params::SmutaGameUserSettings_GetReflection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetScreenPercentageQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetScreenPercentageQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetScreenPercentageQuality");

	Params::SmutaGameUserSettings_GetScreenPercentageQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetSharpness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USmutaGameUserSettings::GetSharpness() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetSharpness");

	Params::SmutaGameUserSettings_GetSharpness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetVirtualShadowMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetVirtualShadowMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetVirtualShadowMap");

	Params::SmutaGameUserSettings_GetVirtualShadowMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaGameUserSettings.GetVolumetricFog
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USmutaGameUserSettings::GetVolumetricFog() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaGameUserSettings", "GetVolumetricFog");

	Params::SmutaGameUserSettings_GetVolumetricFog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SmutaNPCEquipmentComponent.ApplyNPCAppearance
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FNPCAppearanceWrapper&     Appearance                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USmutaNPCEquipmentComponent::ApplyNPCAppearance(const struct FNPCAppearanceWrapper& Appearance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaNPCEquipmentComponent", "ApplyNPCAppearance");

	Params::SmutaNPCEquipmentComponent_ApplyNPCAppearance Parms{};

	Parms.Appearance = std::move(Appearance);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaNPCEquipmentComponent.ChangeActiveSlot_Finish
// (Final, Native, Protected)
// Parameters:
// EEquipmentSlotType                      NewSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaNPCEquipmentComponent::ChangeActiveSlot_Finish(EEquipmentSlotType NewSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaNPCEquipmentComponent", "ChangeActiveSlot_Finish");

	Params::SmutaNPCEquipmentComponent_ChangeActiveSlot_Finish Parms{};

	Parms.NewSlot = NewSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaNPCEquipmentComponent.ChangeActiveSlot_TakeNewSlot
// (Final, Native, Protected)
// Parameters:
// EEquipmentSlotType                      NewSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasCanceled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaNPCEquipmentComponent::ChangeActiveSlot_TakeNewSlot(EEquipmentSlotType NewSlot, bool bWasCanceled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaNPCEquipmentComponent", "ChangeActiveSlot_TakeNewSlot");

	Params::SmutaNPCEquipmentComponent_ChangeActiveSlot_TakeNewSlot Parms{};

	Parms.NewSlot = NewSlot;
	Parms.bWasCanceled = bWasCanceled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaNPCEquipmentComponent.OnNPCStateChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const ENPCBehaviorState&                OldState                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENPCBehaviorState&                NewState                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaNPCEquipmentComponent::OnNPCStateChanged(const ENPCBehaviorState& OldState, const ENPCBehaviorState& NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaNPCEquipmentComponent", "OnNPCStateChanged");

	Params::SmutaNPCEquipmentComponent_OnNPCStateChanged Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaNPCEquipmentComponent.OnSmartObjectInteractionFinished
// (Final, Native, Protected)
// Parameters:
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaNPCEquipmentComponent::OnSmartObjectInteractionFinished(bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaNPCEquipmentComponent", "OnSmartObjectInteractionFinished");

	Params::SmutaNPCEquipmentComponent_OnSmartObjectInteractionFinished Parms{};

	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaNPCMovementComponent.ApplyMoveSpeedPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       Preset                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USmutaNPCMovementComponent::ApplyMoveSpeedPreset(const struct FDataTableRowHandle& Preset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaNPCMovementComponent", "ApplyMoveSpeedPreset");

	Params::SmutaNPCMovementComponent_ApplyMoveSpeedPreset Parms{};

	Parms.Preset = std::move(Preset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaNPCMovementComponent.GetMovementSettingsByGroundMovementMode
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FNPCMovementSettings*            NPCMovementSettings                                    (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// const EGroundMovementMode&              SearchGroundMovementMode                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmutaNPCMovementComponent::GetMovementSettingsByGroundMovementMode(struct FNPCMovementSettings* NPCMovementSettings, const EGroundMovementMode& SearchGroundMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaNPCMovementComponent", "GetMovementSettingsByGroundMovementMode");

	Params::SmutaNPCMovementComponent_GetMovementSettingsByGroundMovementMode Parms{};

	Parms.SearchGroundMovementMode = SearchGroundMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NPCMovementSettings != nullptr)
		*NPCMovementSettings = std::move(Parms.NPCMovementSettings);

	return Parms.ReturnValue;
}


// Function Smuta.SmutaNPCMovementComponent.OnNPCStateChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const ENPCBehaviorState&                OldState                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENPCBehaviorState&                NewState                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaNPCMovementComponent::OnNPCStateChanged(const ENPCBehaviorState& OldState, const ENPCBehaviorState& NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaNPCMovementComponent", "OnNPCStateChanged");

	Params::SmutaNPCMovementComponent_OnNPCStateChanged Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaNPCMovementComponent.SetGroundMovementMode
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EGroundMovementMode&              NewGroundMovementMode                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaNPCMovementComponent::SetGroundMovementMode(const EGroundMovementMode& NewGroundMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaNPCMovementComponent", "SetGroundMovementMode");

	Params::SmutaNPCMovementComponent_SetGroundMovementMode Parms{};

	Parms.NewGroundMovementMode = NewGroundMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaNPCMovementComponent.SetLocomotionState
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const ENPCBehaviorState&                BehaviourState                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGroundMovementMode                     NewGroundMovementMode                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmutaNPCMovementComponent::SetLocomotionState(const ENPCBehaviorState& BehaviourState, EGroundMovementMode NewGroundMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaNPCMovementComponent", "SetLocomotionState");

	Params::SmutaNPCMovementComponent_SetLocomotionState Parms{};

	Parms.BehaviourState = BehaviourState;
	Parms.NewGroundMovementMode = NewGroundMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaNPCMovementComponent.UpdateLocomotionState
// (Final, Native, Public, BlueprintCallable)

void USmutaNPCMovementComponent::UpdateLocomotionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaNPCMovementComponent", "UpdateLocomotionState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaTabListWidget.SelectNextTab
// (Final, Native, Protected, BlueprintCallable)

void USmutaTabListWidget::SelectNextTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaTabListWidget", "SelectNextTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaTabListWidget.SelectPreviousTab
// (Final, Native, Protected, BlueprintCallable)

void USmutaTabListWidget::SelectPreviousTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaTabListWidget", "SelectPreviousTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SpawnOptimizationComponent.ShouldSpawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpawnOptimizationComponent::ShouldSpawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnOptimizationComponent", "ShouldSpawn");

	Params::SpawnOptimizationComponent_ShouldSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.SplineVolumeComponent.BeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USplineVolumeComponent::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineVolumeComponent", "BeginOverlap");

	Params::SplineVolumeComponent_BeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SplineVolumeComponent.EndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineVolumeComponent::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineVolumeComponent", "EndOverlap");

	Params::SplineVolumeComponent_EndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SplineVolumeComponent.EnterVolume
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineVolumeComponent::EnterVolume(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineVolumeComponent", "EnterVolume");

	Params::SplineVolumeComponent_EnterVolume Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SplineVolumeComponent.ExitVolume
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineVolumeComponent::ExitVolume(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineVolumeComponent", "ExitVolume");

	Params::SplineVolumeComponent_ExitVolume Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SplineVolumeComponent.UpdateVolume
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineVolumeComponent::UpdateVolume(class AActor* Actor, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineVolumeComponent", "UpdateVolume");

	Params::SplineVolumeComponent_UpdateVolume Parms{};

	Parms.Actor = Actor;
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SpyCameraBase.ActivateSpyCamera
// (Native, Public, BlueprintCallable)

void ASpyCameraBase::ActivateSpyCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCameraBase", "ActivateSpyCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SpyCameraBase.ChangeSpyCameraState
// (Native, Protected)
// Parameters:
// ESpyCameraState                         NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpyCameraBase::ChangeSpyCameraState(ESpyCameraState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCameraBase", "ChangeSpyCameraState");

	Params::SpyCameraBase_ChangeSpyCameraState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SpyCameraBase.DeactivateSpyCamera
// (Native, Public, BlueprintCallable)

void ASpyCameraBase::DeactivateSpyCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCameraBase", "DeactivateSpyCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SpyCameraBase.OnCameraDeactivated
// (Event, Protected, BlueprintEvent)

void ASpyCameraBase::OnCameraDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCameraBase", "OnCameraDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.SpyCameraBase.SpyCameraOut
// (Final, Native, Protected, BlueprintCallable)

void ASpyCameraBase::SpyCameraOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCameraBase", "SpyCameraOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SpyCameraBase.SpyCameraView
// (Final, Native, Protected)

void ASpyCameraBase::SpyCameraView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCameraBase", "SpyCameraView");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SpyCameraBase.StartSpyCamera
// (Native, Public, BlueprintCallable)

void ASpyCameraBase::StartSpyCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCameraBase", "StartSpyCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TeaseAbilityOptionalObject.GetAnimationTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UTeaseAbilityOptionalObject::GetAnimationTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeaseAbilityOptionalObject", "GetAnimationTag");

	Params::TeaseAbilityOptionalObject_GetAnimationTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.AutoCreateDialogueAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDlgDialogue*                     DialogueAsset                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NodesCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::AutoCreateDialogueAsset(class UDlgDialogue* DialogueAsset, const int32 NodesCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "AutoCreateDialogueAsset");

	Params::TechDesignLibrary_AutoCreateDialogueAsset Parms{};

	Parms.DialogueAsset = DialogueAsset;
	Parms.NodesCount = NodesCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.AutoFillDialogueAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDlgDialogue*                     DialogueAsset                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          StringAsset                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FDialogueTableInfo>&DialogueTableInfo                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTechDesignLibrary::AutoFillDialogueAsset(class UDlgDialogue* DialogueAsset, class UObject* StringAsset, const TArray<struct FDialogueTableInfo>& DialogueTableInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "AutoFillDialogueAsset");

	Params::TechDesignLibrary_AutoFillDialogueAsset Parms{};

	Parms.DialogueAsset = DialogueAsset;
	Parms.StringAsset = StringAsset;
	Parms.DialogueTableInfo = std::move(DialogueTableInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.AutoFillSpeechDialogueText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDlgNode*                         Node                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          StringAsset                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    AudioName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::AutoFillSpeechDialogueText(class UDlgNode* Node, class UObject* StringAsset, const class FString& AudioName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "AutoFillSpeechDialogueText");

	Params::TechDesignLibrary_AutoFillSpeechDialogueText Parms{};

	Parms.Node = Node;
	Parms.StringAsset = StringAsset;
	Parms.AudioName = std::move(AudioName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.AutoFillSpeechSequenceDialogueText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDlgNode*                         Node                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          StringAsset                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    AudioName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::AutoFillSpeechSequenceDialogueText(class UDlgNode* Node, class UObject* StringAsset, const class FString& AudioName, int32 NodeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "AutoFillSpeechSequenceDialogueText");

	Params::TechDesignLibrary_AutoFillSpeechSequenceDialogueText Parms{};

	Parms.Node = Node;
	Parms.StringAsset = StringAsset;
	Parms.AudioName = std::move(AudioName);
	Parms.NodeIndex = NodeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.AutoFillStringTable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ToKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ToSourceString                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::AutoFillStringTable(class UObject* Asset, const class FString& ToKey, const class FString& ToSourceString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "AutoFillStringTable");

	Params::TechDesignLibrary_AutoFillStringTable Parms{};

	Parms.Asset = Asset;
	Parms.ToKey = std::move(ToKey);
	Parms.ToSourceString = std::move(ToSourceString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.CheckAndFillStringTable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDataTable*                 DataTable                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             KeyPropertyName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ValuePropertyName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::CheckAndFillStringTable(class UObject* Asset, const class UDataTable* DataTable, class FName KeyPropertyName, class FName ValuePropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "CheckAndFillStringTable");

	Params::TechDesignLibrary_CheckAndFillStringTable Parms{};

	Parms.Asset = Asset;
	Parms.DataTable = DataTable;
	Parms.KeyPropertyName = KeyPropertyName;
	Parms.ValuePropertyName = ValuePropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.CreateCustomAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    AssetName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    AssetPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           AssetClass                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutSuccess                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UTechDesignLibrary::CreateCustomAsset(const class FString& AssetName, const class FString& AssetPath, class UClass* AssetClass, bool* bOutSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "CreateCustomAsset");

	Params::TechDesignLibrary_CreateCustomAsset Parms{};

	Parms.AssetName = std::move(AssetName);
	Parms.AssetPath = std::move(AssetPath);
	Parms.AssetClass = AssetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutSuccess != nullptr)
		*bOutSuccess = Parms.bOutSuccess;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.FillEmotionOnDialogue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UDataTable*                 DataTable                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NodeText                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ValuePropertyName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EmotionPropertyName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTechDesignLibrary::FillEmotionOnDialogue(const class UDataTable* DataTable, const class FString& NodeText, class FName ValuePropertyName, class FName EmotionPropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "FillEmotionOnDialogue");

	Params::TechDesignLibrary_FillEmotionOnDialogue Parms{};

	Parms.DataTable = DataTable;
	Parms.NodeText = std::move(NodeText);
	Parms.ValuePropertyName = ValuePropertyName;
	Parms.EmotionPropertyName = EmotionPropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.GenerateBS
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FBSWalkParams&             WalkParams                                             (Parm, NativeAccessSpecifierPublic)
// class UBlendSpace*                      BlendSpaceTemplate                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::GenerateBS(const struct FBSWalkParams& WalkParams, class UBlendSpace* BlendSpaceTemplate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GenerateBS");

	Params::TechDesignLibrary_GenerateBS Parms{};

	Parms.WalkParams = std::move(WalkParams);
	Parms.BlendSpaceTemplate = BlendSpaceTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.GetBlendSamplesFromBS
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBlendSpace*                      BlendSpace                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBlendSpaceAnalysisInfo>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBlendSpaceAnalysisInfo> UTechDesignLibrary::GetBlendSamplesFromBS(class UBlendSpace* BlendSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GetBlendSamplesFromBS");

	Params::TechDesignLibrary_GetBlendSamplesFromBS Parms{};

	Parms.BlendSpace = BlendSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.GetBranchDialogueName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    SourceString                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTechDesignLibrary::GetBranchDialogueName(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GetBranchDialogueName");

	Params::TechDesignLibrary_GetBranchDialogueName Parms{};

	Parms.SourceString = std::move(SourceString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.GetDialogueNameToTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    SourceString                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTechDesignLibrary::GetDialogueNameToTable(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GetDialogueNameToTable");

	Params::TechDesignLibrary_GetDialogueNameToTable Parms{};

	Parms.SourceString = std::move(SourceString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.GetEffectiveTimeDilation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTechDesignLibrary::GetEffectiveTimeDilation(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GetEffectiveTimeDilation");

	Params::TechDesignLibrary_GetEffectiveTimeDilation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.GetEnchancedSplinePointParams
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnchancedSplineComponent*        EnchancedSplineComponent                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEnchancedSplinePointParams      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FEnchancedSplinePointParams UTechDesignLibrary::GetEnchancedSplinePointParams(class UEnchancedSplineComponent* EnchancedSplineComponent, int32 PointIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GetEnchancedSplinePointParams");

	Params::TechDesignLibrary_GetEnchancedSplinePointParams Parms{};

	Parms.EnchancedSplineComponent = EnchancedSplineComponent;
	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.GetPhraseNum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    SourceString                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTechDesignLibrary::GetPhraseNum(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GetPhraseNum");

	Params::TechDesignLibrary_GetPhraseNum Parms{};

	Parms.SourceString = std::move(SourceString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.GetReferencedMontages
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<TSoftObjectPtr<class UAnimMontage>>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TSet<TSoftObjectPtr<class UAnimMontage>> UTechDesignLibrary::GetReferencedMontages(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GetReferencedMontages");

	Params::TechDesignLibrary_GetReferencedMontages Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.GetSortedByHeights
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class UObject*>&           Unsorted                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<float>&                    Heights                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UObject*>*                 Sorted                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTechDesignLibrary::GetSortedByHeights(const TArray<class UObject*>& Unsorted, const TArray<float>& Heights, TArray<class UObject*>* Sorted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GetSortedByHeights");

	Params::TechDesignLibrary_GetSortedByHeights Parms{};

	Parms.Unsorted = std::move(Unsorted);
	Parms.Heights = std::move(Heights);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Sorted != nullptr)
		*Sorted = std::move(Parms.Sorted);
}


// Function Smuta.TechDesignLibrary.GetSpeakerAudio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    SoundInString                                          (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            SoundArray                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class USoundWave>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class USoundWave> UTechDesignLibrary::GetSpeakerAudio(const class FString& SoundInString, const TArray<class FString>& SoundArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GetSpeakerAudio");

	Params::TechDesignLibrary_GetSpeakerAudio Parms{};

	Parms.SoundInString = std::move(SoundInString);
	Parms.SoundArray = std::move(SoundArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.GetSpeakerPassport
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    Passport                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UDataAsset>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UDataAsset> UTechDesignLibrary::GetSpeakerPassport(const class FString& Passport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GetSpeakerPassport");

	Params::TechDesignLibrary_GetSpeakerPassport Parms{};

	Parms.Passport = std::move(Passport);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.GetStringTableID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          StringAsset                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UTechDesignLibrary::GetStringTableID(class UObject* StringAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "GetStringTableID");

	Params::TechDesignLibrary_GetStringTableID Parms{};

	Parms.StringAsset = StringAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.IsBegunPlay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTechDesignLibrary::IsBegunPlay(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "IsBegunPlay");

	Params::TechDesignLibrary_IsBegunPlay Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.IsPlayInEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTechDesignLibrary::IsPlayInEditor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "IsPlayInEditor");

	Params::TechDesignLibrary_IsPlayInEditor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.MontageHasNotifyOfClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimMontage*               Montage                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           NotifyClass                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTechDesignLibrary::MontageHasNotifyOfClass(const class UAnimMontage* Montage, class UClass* NotifyClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "MontageHasNotifyOfClass");

	Params::TechDesignLibrary_MontageHasNotifyOfClass Parms{};

	Parms.Montage = Montage;
	Parms.NotifyClass = NotifyClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TechDesignLibrary.NormalCurvesFromAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::NormalCurvesFromAnim(class UAnimSequence* AnimationSequence, float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "NormalCurvesFromAnim");

	Params::TechDesignLibrary_NormalCurvesFromAnim Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.ReplaceSmartObjects
// (Final, Native, Static, Public, BlueprintCallable)

void UTechDesignLibrary::ReplaceSmartObjects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "ReplaceSmartObjects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.ScriptSetHiddenSteps
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGenericQuest*                    Quest                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::ScriptSetHiddenSteps(class UGenericQuest* Quest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "ScriptSetHiddenSteps");

	Params::TechDesignLibrary_ScriptSetHiddenSteps Parms{};

	Parms.Quest = Quest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.ScriptSetNameAndDescription
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGenericQuest*                    Quest                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          StringTable                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::ScriptSetNameAndDescription(class UGenericQuest* Quest, class UObject* StringTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "ScriptSetNameAndDescription");

	Params::TechDesignLibrary_ScriptSetNameAndDescription Parms{};

	Parms.Quest = Quest;
	Parms.StringTable = StringTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.SearchAllAnimReferences
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeleton**                       Skeleton                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class UBaseEquipmentSet*, TSubclassOf<class UEquipmentItem>>*Equipment                                              (Parm, OutParm, UObjectWrapper, NativeAccessSpecifierPublic)

void UTechDesignLibrary::SearchAllAnimReferences(class UClass* Class_0, class USkeleton** Skeleton, TMap<class UBaseEquipmentSet*, TSubclassOf<class UEquipmentItem>>* Equipment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "SearchAllAnimReferences");

	Params::TechDesignLibrary_SearchAllAnimReferences Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Skeleton != nullptr)
		*Skeleton = Parms.Skeleton;

	if (Equipment != nullptr)
		*Equipment = std::move(Parms.Equipment);
}


// Function Smuta.TechDesignLibrary.SetEnchancedSplinePointParams
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEnchancedSplineComponent*        EnchancedSplineComponent                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEnchancedSplinePointParams&PointParams                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::SetEnchancedSplinePointParams(class UEnchancedSplineComponent* EnchancedSplineComponent, const struct FEnchancedSplinePointParams& PointParams, int32 PointIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "SetEnchancedSplinePointParams");

	Params::TechDesignLibrary_SetEnchancedSplinePointParams Parms{};

	Parms.EnchancedSplineComponent = EnchancedSplineComponent;
	Parms.PointParams = std::move(PointParams);
	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.SetNodeDataToDialogueAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDlgNode_Speech*                  DialogueNode                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDlgNodeData*                     NodeData                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::SetNodeDataToDialogueAsset(class UDlgNode_Speech* DialogueNode, class UDlgNodeData* NodeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "SetNodeDataToDialogueAsset");

	Params::TechDesignLibrary_SetNodeDataToDialogueAsset Parms{};

	Parms.DialogueNode = DialogueNode;
	Parms.NodeData = NodeData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.SetSmartObjectsCanUseCollectionProperty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SmartObject                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTechDesignLibrary::SetSmartObjectsCanUseCollectionProperty(bool bValue, class UObject* SmartObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "SetSmartObjectsCanUseCollectionProperty");

	Params::TechDesignLibrary_SetSmartObjectsCanUseCollectionProperty Parms{};

	Parms.bValue = bValue;
	Parms.SmartObject = SmartObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TechDesignLibrary.SetupFace
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    Face                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        PostProcessAnimBlueprint                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<TSubclassOf<class UAssetUserData>>&UserDataList                                           (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UTechDesignLibrary::SetupFace(class USkeletalMesh* Face, TSubclassOf<class UAnimInstance> PostProcessAnimBlueprint, const TArray<TSubclassOf<class UAssetUserData>>& UserDataList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TechDesignLibrary", "SetupFace");

	Params::TechDesignLibrary_SetupFace Parms{};

	Parms.Face = Face;
	Parms.PostProcessAnimBlueprint = PostProcessAnimBlueprint;
	Parms.UserDataList = std::move(UserDataList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TraversalInteraction.GenerateMotionWarpingPoints
// (Final, Native, Protected, BlueprintCallable)

void ATraversalInteraction::GenerateMotionWarpingPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraversalInteraction", "GenerateMotionWarpingPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TraversalInteraction.OnInteracted
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InteractedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATraversalInteraction::OnInteracted(class AActor* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraversalInteraction", "OnInteracted");

	Params::TraversalInteraction_OnInteracted Parms{};

	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialComboWidget.OnComboFailed
// (Event, Protected, BlueprintEvent)

void UTutorialComboWidget::OnComboFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialComboWidget", "OnComboFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.TutorialComboWidget.OnComboKeyPressed
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   ComboKeyIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialComboWidget::OnComboKeyPressed(int32 ComboKeyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialComboWidget", "OnComboKeyPressed");

	Params::TutorialComboWidget_OnComboKeyPressed Parms{};

	Parms.ComboKeyIndex = ComboKeyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Smuta.TutorialComboWidget.OnComboRestarted
// (Event, Protected, BlueprintEvent)

void UTutorialComboWidget::OnComboRestarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialComboWidget", "OnComboRestarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.TutorialComboWidget.OnComboSuccess
// (Event, Protected, BlueprintEvent)

void UTutorialComboWidget::OnComboSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialComboWidget", "OnComboSuccess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.TutorialComboWidget.SetContent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InHintName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTutorialComboHintContent*  InContent                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialComboWidget::SetContent(const class FName& InHintName, const class UTutorialComboHintContent* InContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialComboWidget", "SetContent");

	Params::TutorialComboWidget_SetContent Parms{};

	Parms.InHintName = InHintName;
	Parms.InContent = InContent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialComboWidget.GetComboItems
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UTutorialComboItemObject*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTutorialComboItemObject*> UTutorialComboWidget::GetComboItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialComboWidget", "GetComboItems");

	Params::TutorialComboWidget_GetComboItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TutorialConfig.GetContents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bInShowInCodex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutContent                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTutorialConfig::GetContents(bool bInShowInCodex, TArray<class FName>* OutContent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialConfig", "GetContents");

	Params::TutorialConfig_GetContents Parms{};

	Parms.bInShowInCodex = bInShowInCodex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutContent != nullptr)
		*OutContent = std::move(Parms.OutContent);
}


// Function Smuta.TutorialManager.ClearShownTutorials
// (Final, Native, Public, BlueprintCallable)

void UTutorialManager::ClearShownTutorials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "ClearShownTutorials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialManager.CloseTutorialHint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      HintName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::CloseTutorialHint(const class FName& HintName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "CloseTutorialHint");

	Params::TutorialManager_CloseTutorialHint Parms{};

	Parms.HintName = HintName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialManager.OnExitSmutaGame
// (Final, Native, Private)

void UTutorialManager::OnExitSmutaGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "OnExitSmutaGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialManager.OnSubSystemsInited
// (Final, Native, Private)

void UTutorialManager::OnSubSystemsInited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "OnSubSystemsInited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialManager.OnTutorialHintClosed
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      HintName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::OnTutorialHintClosed(const class FName& HintName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "OnTutorialHintClosed");

	Params::TutorialManager_OnTutorialHintClosed Parms{};

	Parms.HintName = HintName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialManager.SetAllCodexTutorialsShown
// (Final, Native, Public, BlueprintCallable)

void UTutorialManager::SetAllCodexTutorialsShown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "SetAllCodexTutorialsShown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.TutorialManager.ShowTutorialHint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      HintName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTutorialManager::ShowTutorialHint(const class FName& HintName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "ShowTutorialHint");

	Params::TutorialManager_ShowTutorialHint Parms{};

	Parms.HintName = HintName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TutorialManager.GetConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UTutorialConfig*            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UTutorialConfig* UTutorialManager::GetConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "GetConfig");

	Params::TutorialManager_GetConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TutorialManager.GetContent
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      HintName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTutorialBaseContent*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialBaseContent* UTutorialManager::GetContent(const class FName& HintName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "GetContent");

	Params::TutorialManager_GetContent Parms{};

	Parms.HintName = HintName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TutorialManager.GetShownTutorials
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bForCodexOnly                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTutorialItemObject*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTutorialItemObject*> UTutorialManager::GetShownTutorials(bool bForCodexOnly) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "GetShownTutorials");

	Params::TutorialManager_GetShownTutorials Parms{};

	Parms.bForCodexOnly = bForCodexOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.TutorialPopupWidget.SetContent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      InHintName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UTutorialBasePopupHintContent*InContent                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialPopupWidget::SetContent(const class FName& InHintName, const class UTutorialBasePopupHintContent* InContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPopupWidget", "SetContent");

	Params::TutorialPopupWidget_SetContent Parms{};

	Parms.InHintName = InHintName;
	Parms.InContent = InContent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.UIFunctionLibrary.GetMostLeftWidgetInPanel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UUniformGridPanel*          ParentWidget                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             RowNumber                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UUIFunctionLibrary::GetMostLeftWidgetInPanel(const class UUniformGridPanel* ParentWidget, const int32 RowNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetMostLeftWidgetInPanel");

	Params::UIFunctionLibrary_GetMostLeftWidgetInPanel Parms{};

	Parms.ParentWidget = ParentWidget;
	Parms.RowNumber = RowNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.UIFunctionLibrary.GetMostRightWidgetInPanel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UUniformGridPanel*          ParentWidget                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             RowNumber                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UUIFunctionLibrary::GetMostRightWidgetInPanel(const class UUniformGridPanel* ParentWidget, const int32 RowNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetMostRightWidgetInPanel");

	Params::UIFunctionLibrary_GetMostRightWidgetInPanel Parms{};

	Parms.ParentWidget = ParentWidget;
	Parms.RowNumber = RowNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.UIFunctionLibrary.GetNextChildWidget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class UPanelWidget*>&      ParentWidgets                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class UWidget*                    ChildWidget                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bNext                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UUIFunctionLibrary::GetNextChildWidget(const TArray<class UPanelWidget*>& ParentWidgets, const class UWidget* ChildWidget, const bool bNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetNextChildWidget");

	Params::UIFunctionLibrary_GetNextChildWidget Parms{};

	Parms.ParentWidgets = std::move(ParentWidgets);
	Parms.ChildWidget = ChildWidget;
	Parms.bNext = bNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.UIFunctionLibrary.GetNextUniformGridSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UUniformGridPanel*          ParentWidget                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UUniformGridSlot*           Slot                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUniformGridPanelDirection        Direction                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUniformGridSlot*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUniformGridSlot* UUIFunctionLibrary::GetNextUniformGridSlot(const class UUniformGridPanel* ParentWidget, const class UUniformGridSlot* Slot, const EUniformGridPanelDirection Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetNextUniformGridSlot");

	Params::UIFunctionLibrary_GetNextUniformGridSlot Parms{};

	Parms.ParentWidget = ParentWidget;
	Parms.Slot = Slot;
	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.UIFunctionLibrary.GetNextUniformGridSlotFromWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UUniformGridPanel*          ParentWidget                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UWidget*                    ChildWidget                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EUniformGridPanelDirection        Direction                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UUIFunctionLibrary::GetNextUniformGridSlotFromWidget(const class UUniformGridPanel* ParentWidget, const class UWidget* ChildWidget, const EUniformGridPanelDirection Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetNextUniformGridSlotFromWidget");

	Params::UIFunctionLibrary_GetNextUniformGridSlotFromWidget Parms{};

	Parms.ParentWidget = ParentWidget;
	Parms.ChildWidget = ChildWidget;
	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.UIFunctionLibrary.GetWidgetColumnInPanel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UUniformGridPanel*          ParentWidget                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UWidget*                    ChildWidget                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetWidgetColumnInPanel(const class UUniformGridPanel* ParentWidget, const class UWidget* ChildWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetWidgetColumnInPanel");

	Params::UIFunctionLibrary_GetWidgetColumnInPanel Parms{};

	Parms.ParentWidget = ParentWidget;
	Parms.ChildWidget = ChildWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.UIFunctionLibrary.GetWidgetRowInPanel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UUniformGridPanel*          ParentWidget                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UWidget*                    ChildWidget                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetWidgetRowInPanel(const class UUniformGridPanel* ParentWidget, const class UWidget* ChildWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetWidgetRowInPanel");

	Params::UIFunctionLibrary_GetWidgetRowInPanel Parms{};

	Parms.ParentWidget = ParentWidget;
	Parms.ChildWidget = ChildWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.UIFunctionLibrary.IsWidgetMostLeftInPanel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UUniformGridPanel*          ParentWidget                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UWidget*                    ChildWidget                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsWidgetMostLeftInPanel(const class UUniformGridPanel* ParentWidget, const class UWidget* ChildWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsWidgetMostLeftInPanel");

	Params::UIFunctionLibrary_IsWidgetMostLeftInPanel Parms{};

	Parms.ParentWidget = ParentWidget;
	Parms.ChildWidget = ChildWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.UIFunctionLibrary.IsWidgetMostRightInPanel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UUniformGridPanel*          ParentWidget                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UWidget*                    ChildWidget                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsWidgetMostRightInPanel(const class UUniformGridPanel* ParentWidget, const class UWidget* ChildWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsWidgetMostRightInPanel");

	Params::UIFunctionLibrary_IsWidgetMostRightInPanel Parms{};

	Parms.ParentWidget = ParentWidget;
	Parms.ChildWidget = ChildWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.UIFunctionLibrary.SetMousePosition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   LocationX                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LocationY                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::SetMousePosition(float LocationX, float LocationY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "SetMousePosition");

	Params::UIFunctionLibrary_SetMousePosition Parms{};

	Parms.LocationX = LocationX;
	Parms.LocationY = LocationY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.UpgradesSubsystem.GetUpgradeClassFromRowHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       UpgradeRowHandle                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class UBaseUpgradeObject>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UBaseUpgradeObject> UUpgradesSubsystem::GetUpgradeClassFromRowHandle(const struct FDataTableRowHandle& UpgradeRowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UpgradesSubsystem", "GetUpgradeClassFromRowHandle");

	Params::UpgradesSubsystem_GetUpgradeClassFromRowHandle Parms{};

	Parms.UpgradeRowHandle = std::move(UpgradeRowHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.UpgradesSubsystem.ApplyUpgradeByClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UBaseUpgradeObject>   Upgrade                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUpgradesSubsystem::ApplyUpgradeByClass(TSubclassOf<class UBaseUpgradeObject> Upgrade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UpgradesSubsystem", "ApplyUpgradeByClass");

	Params::UpgradesSubsystem_ApplyUpgradeByClass Parms{};

	Parms.Upgrade = Upgrade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.UpgradesSubsystem.ApplyUpgradeByRowHandle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       UpgradeRowHandle                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUpgradesSubsystem::ApplyUpgradeByRowHandle(const struct FDataTableRowHandle& UpgradeRowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UpgradesSubsystem", "ApplyUpgradeByRowHandle");

	Params::UpgradesSubsystem_ApplyUpgradeByRowHandle Parms{};

	Parms.UpgradeRowHandle = std::move(UpgradeRowHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.UpgradesSubsystem.IsUpgradeClassApplied
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UBaseUpgradeObject>   Upgrade                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUpgradesSubsystem::IsUpgradeClassApplied(TSubclassOf<class UBaseUpgradeObject> Upgrade) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UpgradesSubsystem", "IsUpgradeClassApplied");

	Params::UpgradesSubsystem_IsUpgradeClassApplied Parms{};

	Parms.Upgrade = Upgrade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.UpgradesSubsystem.IsUpgradeRowHandleApplied
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDataTableRowHandle&       UpgradeRowHandle                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUpgradesSubsystem::IsUpgradeRowHandleApplied(const struct FDataTableRowHandle& UpgradeRowHandle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UpgradesSubsystem", "IsUpgradeRowHandleApplied");

	Params::UpgradesSubsystem_IsUpgradeRowHandleApplied Parms{};

	Parms.UpgradeRowHandle = std::move(UpgradeRowHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VATSubsystem.AddVertexActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AVertexActor*                     VertexActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVATSubsystem::AddVertexActor(class AVertexActor* VertexActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VATSubsystem", "AddVertexActor");

	Params::VATSubsystem_AddVertexActor Parms{};

	Parms.VertexActor = VertexActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VATSubsystem.RemoveVertexActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AVertexActor*                     VertexActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVATSubsystem::RemoveVertexActor(class AVertexActor* VertexActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VATSubsystem", "RemoveVertexActor");

	Params::VATSubsystem_RemoveVertexActor Parms{};

	Parms.VertexActor = VertexActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VATSubsystem.GetGlobalVATTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVATSubsystem::GetGlobalVATTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VATSubsystem", "GetGlobalVATTime");

	Params::VATSubsystem_GetGlobalVATTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.GetAudioComponentVoice
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* AVertexActorDialogue::GetAudioComponentVoice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "GetAudioComponentVoice");

	Params::VertexActorDialogue_GetAudioComponentVoice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.GetAudioTriggerComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USphereComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USphereComponent* AVertexActorDialogue::GetAudioTriggerComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "GetAudioTriggerComponent");

	Params::VertexActorDialogue_GetAudioTriggerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.GetPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVertexActorDialogue::GetPlayRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "GetPlayRate");

	Params::VertexActorDialogue_GetPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.GetTimeOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVertexActorDialogue::GetTimeOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "GetTimeOffset");

	Params::VertexActorDialogue_GetTimeOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.GetVertexActorListener
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UChildActorComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChildActorComponent* AVertexActorDialogue::GetVertexActorListener()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "GetVertexActorListener");

	Params::VertexActorDialogue_GetVertexActorListener Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.GetVertexActorSpeaker
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UChildActorComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChildActorComponent* AVertexActorDialogue::GetVertexActorSpeaker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "GetVertexActorSpeaker");

	Params::VertexActorDialogue_GetVertexActorSpeaker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.GetVertexAssetDialogue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UVertexAssetDialogue*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVertexAssetDialogue* AVertexActorDialogue::GetVertexAssetDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "GetVertexAssetDialogue");

	Params::VertexActorDialogue_GetVertexAssetDialogue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.GetVertexAssetListener
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVertexTalking                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVertexTalking AVertexActorDialogue::GetVertexAssetListener()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "GetVertexAssetListener");

	Params::VertexActorDialogue_GetVertexAssetListener Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.GetVertexAssetSpeaker
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVertexTalking                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVertexTalking AVertexActorDialogue::GetVertexAssetSpeaker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "GetVertexAssetSpeaker");

	Params::VertexActorDialogue_GetVertexAssetSpeaker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.IsPlayerCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ActorCheck                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVertexActorDialogue::IsPlayerCheck(class AActor* ActorCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "IsPlayerCheck");

	Params::VertexActorDialogue_IsPlayerCheck Parms{};

	Parms.ActorCheck = ActorCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.IsPlayerOverlap
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVertexActorDialogue::IsPlayerOverlap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "IsPlayerOverlap");

	Params::VertexActorDialogue_IsPlayerOverlap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.VertexActorDialogue.OnBeginOverlapPlayer
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              ThisComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AVertexActorDialogue::OnBeginOverlapPlayer(class UPrimitiveComponent* ThisComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "OnBeginOverlapPlayer");

	Params::VertexActorDialogue_OnBeginOverlapPlayer Parms{};

	Parms.ThisComp = ThisComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActorDialogue.OnEndOverlapPlayer
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              ThisComp                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActorDialogue::OnEndOverlapPlayer(class UPrimitiveComponent* ThisComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "OnEndOverlapPlayer");

	Params::VertexActorDialogue_OnEndOverlapPlayer Parms{};

	Parms.ThisComp = ThisComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActorDialogue.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewPlayRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActorDialogue::SetPlayRate(float NewPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "SetPlayRate");

	Params::VertexActorDialogue_SetPlayRate Parms{};

	Parms.NewPlayRate = NewPlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActorDialogue.SetTimeOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTimeOffset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActorDialogue::SetTimeOffset(float NewTimeOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "SetTimeOffset");

	Params::VertexActorDialogue_SetTimeOffset Parms{};

	Parms.NewTimeOffset = NewTimeOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActorDialogue.SetVertexAssetDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVertexAssetDialogue*             NewVertexAssetDialogue                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActorDialogue::SetVertexAssetDialogue(class UVertexAssetDialogue* NewVertexAssetDialogue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "SetVertexAssetDialogue");

	Params::VertexActorDialogue_SetVertexAssetDialogue Parms{};

	Parms.NewVertexAssetDialogue = NewVertexAssetDialogue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActorDialogue.SetVertexAssetListener
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FVertexTalking&            NewVertexAssetListener                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AVertexActorDialogue::SetVertexAssetListener(const struct FVertexTalking& NewVertexAssetListener)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "SetVertexAssetListener");

	Params::VertexActorDialogue_SetVertexAssetListener Parms{};

	Parms.NewVertexAssetListener = std::move(NewVertexAssetListener);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActorDialogue.SetVertexAssetSpeaker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FVertexTalking&            NewVertexAssetSpeaker                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AVertexActorDialogue::SetVertexAssetSpeaker(const struct FVertexTalking& NewVertexAssetSpeaker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "SetVertexAssetSpeaker");

	Params::VertexActorDialogue_SetVertexAssetSpeaker Parms{};

	Parms.NewVertexAssetSpeaker = std::move(NewVertexAssetSpeaker);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VertexActorDialogue.ToggleDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVertexActorDialogue::ToggleDialogue(bool Activate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VertexActorDialogue", "ToggleDialogue");

	Params::VertexActorDialogue_ToggleDialogue Parms{};

	Parms.Activate = Activate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.VoiceTagsDataAsset.GetParticipantName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              VoiceTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoiceTagsDataAsset::GetParticipantName(const struct FGameplayTag& VoiceTag, class FString* Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceTagsDataAsset", "GetParticipantName");

	Params::VoiceTagsDataAsset_GetParticipantName Parms{};

	Parms.VoiceTag = std::move(VoiceTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);

	return Parms.ReturnValue;
}


// Function Smuta.WorldMapSubsystem.BP_Initialize
// (Event, Public, BlueprintEvent)

void UWorldMapSubsystem::BP_Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldMapSubsystem", "BP_Initialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Smuta.WorldMapSubsystem.GetCurrentMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AWorldMapBorderActor*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWorldMapBorderActor* UWorldMapSubsystem::GetCurrentMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldMapSubsystem", "GetCurrentMap");

	Params::WorldMapSubsystem_GetCurrentMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.WorldMapSubsystem.GetDefaultMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AWorldMapBorderActor*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWorldMapBorderActor* UWorldMapSubsystem::GetDefaultMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldMapSubsystem", "GetDefaultMap");

	Params::WorldMapSubsystem_GetDefaultMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Smuta.WorldMapSubsystem.PushMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWorldMapBorderActor*             NewMap                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldMapSubsystem::PushMap(class AWorldMapBorderActor* NewMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldMapSubsystem", "PushMap");

	Params::WorldMapSubsystem_PushMap Parms{};

	Parms.NewMap = NewMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.WorldMapSubsystem.RemoveMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWorldMapBorderActor*             Map                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldMapSubsystem::RemoveMap(class AWorldMapBorderActor* Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldMapSubsystem", "RemoveMap");

	Params::WorldMapSubsystem_RemoveMap Parms{};

	Parms.Map = Map;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.WorldMapSubsystem.SetMiniMapVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewVisibility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldMapSubsystem::SetMiniMapVisibility(bool NewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldMapSubsystem", "SetMiniMapVisibility");

	Params::WorldMapSubsystem_SetMiniMapVisibility Parms{};

	Parms.NewVisibility = NewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ZastavaFlag.ActivateFlag
// (Final, Native, Public, BlueprintCallable)

void AZastavaFlag::ActivateFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZastavaFlag", "ActivateFlag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.ZastavaFlag.DeactivateFlag
// (Final, Native, Public, BlueprintCallable)

void AZastavaFlag::DeactivateFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZastavaFlag", "DeactivateFlag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainAIController.SetCharacterFocalPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewFocus                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainAIController::SetCharacterFocalPoint(const struct FVector& NewFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainAIController", "SetCharacterFocalPoint");

	Params::MainAIController_SetCharacterFocalPoint Parms{};

	Parms.NewFocus = std::move(NewFocus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainAIController.SetCharacterFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewFocus                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainAIController::SetCharacterFocus(class AActor* NewFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainAIController", "SetCharacterFocus");

	Params::MainAIController_SetCharacterFocus Parms{};

	Parms.NewFocus = NewFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainAIController.SetEnemyFocalPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewFocus                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainAIController::SetEnemyFocalPoint(const struct FVector& NewFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainAIController", "SetEnemyFocalPoint");

	Params::MainAIController_SetEnemyFocalPoint Parms{};

	Parms.NewFocus = std::move(NewFocus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainAIController.SetEnemyFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewFocus                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainAIController::SetEnemyFocus(class AActor* NewFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainAIController", "SetEnemyFocus");

	Params::MainAIController_SetEnemyFocus Parms{};

	Parms.NewFocus = NewFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainAIController.SetGameplayFocalPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewFocus                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainAIController::SetGameplayFocalPoint(const struct FVector& NewFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainAIController", "SetGameplayFocalPoint");

	Params::MainAIController_SetGameplayFocalPoint Parms{};

	Parms.NewFocus = std::move(NewFocus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainAIController.SetGameplayFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewFocus                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainAIController::SetGameplayFocus(class AActor* NewFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainAIController", "SetGameplayFocus");

	Params::MainAIController_SetGameplayFocus Parms{};

	Parms.NewFocus = NewFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainAIController.SetScriptFocalPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewFocus                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainAIController::SetScriptFocalPoint(const struct FVector& NewFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainAIController", "SetScriptFocalPoint");

	Params::MainAIController_SetScriptFocalPoint Parms{};

	Parms.NewFocus = std::move(NewFocus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.MainAIController.SetScriptFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewFocus                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMainAIController::SetScriptFocus(class AActor* NewFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainAIController", "SetScriptFocus");

	Params::MainAIController_SetScriptFocus Parms{};

	Parms.NewFocus = NewFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Smuta.SmutaCommonButtonBase.SendClickedEvent
// (Final, Native, Public, BlueprintCallable)

void USmutaCommonButtonBase::SendClickedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmutaCommonButtonBase", "SendClickedEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

